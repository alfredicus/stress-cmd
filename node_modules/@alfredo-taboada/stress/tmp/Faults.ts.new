import { stringify } from "querystring"
import { Curve3D } from "./Curve3D"


class Faults{

    static faultNumber
    [faultNumber: string]: number
}

let F1 = new Faults();
F1.A1 = 1

let F2 = new Faults();
F2.A1 = 1



















export class IntegralCurve {
    private r: number
    private exp_cos: number
    private exp_sin: number

    constructor(private lambda: [number, number, number], radius = 1) {
        this.r = radius
        this.exp_sin = ( this.lambda[0] - this.lambda[2] ) / ( this.lambda[1] - this.lambda[0] )
        this.exp_cos = ( this.lambda[2] - this.lambda[1] ) / ( this.lambda[1] - this.lambda[0] )
    }

    /**
     * Define a tangent plane by fixing angles phi and theta in spherical coordinates
     * @param theta In degrees
     * @param phi In degrees
     */
    getIntegral(theta: number, phi: number): string {
        const lineBuilder = new Curve3D()
        let buffer = ''
        let phi_1 = Math.PI * phi /180
        let theta_1 = Math.PI * theta /180

        // Determine integral curve that passes by this point of the sphere surface, by calculating k1
        // k1 is defined as a function of phi and theta for a specific symmetrical tensor
        let k1 = Math.tan(theta_1) / ( Math.sin(phi_1)**this.exp_sin * Math.cos(phi_1)**this.exp_cos )

        // Plot the integral curve that passes by this specific point
        for (let i=0; i<=180; ++i) {
            const phi = Math.PI * i/360
            const theta = Math.atan( k1 * Math.sin(phi)**this.exp_sin * Math.cos(phi)**this.exp_cos )
            const x = this.r * Math.sin(theta) * Math.cos(phi)
            const y = this.r * Math.sin(theta) * Math.sin(phi)
            const z = this.r * Math.cos(theta)
            lineBuilder.addPoint(x, y, z)
        }
        buffer += lineBuilder.buffer + '\n'
    }
}


        // lineBuilder.clear()

        // NORMAL STRESS EQUIPOTENTIALS 

        // The principal stress values are defined according to the rock mechanics sign convention (positive values for compressive stresses)
        const sigma_1 = - this.lambda[0]
        const sigma_2 = - this.lambda[1]
        const sigma_3 = - this.lambda[2]

        // Center and radius of Mohr circle 3 - 1
        const sigma_3_1_mean = ( sigma_1 + sigma_3 ) / 2
        const rad_3_1 = ( sigma_1 - sigma_3 ) / 2
        // Center and radius of Mohr circle 3 - 2
        const sigma_3_2_mean = ( sigma_2 + sigma_3 ) / 2
        const rad_3_2 = ( sigma_2 - sigma_3 ) / 2
        // Center and radius of Mohr circle 2 - 1
        const sigma_2_1_mean = ( sigma_1 + sigma_2 ) / 2
        const rad_2_1 = ( sigma_1 - sigma_2 ) / 2
    
        // The integral lines derive from a scalar function defined by the normal stress component sigma_n
        // sigma_n is calculated for a specific plane tangent to the sphere whose normal vector is defined by (phi_1, theta_1)
        // sigma_n = (this.lambda[0] * cos(phi)**2 +this.lambda[1] * sin(phi)**2 ) * sin(theta)**2 + this.lambda[2] * ( 1 - sin(theta)**2 )
        let sigma_n = (this.lambda[0] * Math.cos(phi_1)**2 +this.lambda[1] * Math.sin(phi_1)**2 ) * Math.sin(theta_1)**2 + this.lambda[2] * ( 1 - Math.sin(theta_1)**2 )

        // Plot equipotential of the normal force that passes through the fixed point:
        //      
        // tau_n0 = shear stress for point pO located in the Mohr circle 3-1 at normal stress sigma_n
        const tau_n0 = Math.sqrt( rad_3_1**2 - (sigma_n - sigma_3_1_mean)**2 )
        // alfa_n0 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-1 and the horizontal axis (sigma_3, sigma_1) :
        const alfa_n0 = Math.atan( tau_n0 / (sigma_n - sigma_3) )


        // if ( sigma_2 == sigma_3) {
        //     // Particular Case 1: revolution stress tensor around sigma_1
        //     // Equipotential curve is a circle sweeping at an angle alfa_n0 around sigma_1
        //     arcCircle( 'sigma_1', alfa_n0 )
        // }
        // else if ( sigma_2 == sigma_1) {
        //     // Particular Case 2: revolution stress tensor around sigma_3
        //     // Equipotential curve is a circle sweeping at an angle PI/2 - alfa_n0 around sigma_3
        //     arcCircle( 'sigma_3', Math.PI/2 - alfa_n0 )
        // }

        if ( sigma_n > sigma_3 && sigma_n < sigma_2 ) {
            // Case 1: the equipotential line lies between circle 3 - 1 and circle 3 - 2:
            // tau_1 = shear stress for point p1 located in the Mohr circle 3-2 at normal stress sigma_n
             const tau_1 = Math.sqrt( rad_3_2**2 - (sigma_n - sigma_3_2_mean)**2 )
             // alfa_1 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :
             const alfa_1 = Math.atan( tau_1 / (sigma_n - sigma_3) )

            // Plot curve corresponding to the line segment between points: (sigma_n, tau_n0) and (sigma_n, tau_1)
            MohrCircleLine( '3_1', sigma_n, tau_n0, alfa_n0, '3_2', sigma_n, tau_1, alfa_1 )
        }   
        else if ( sigma_n > sigma_2 && sigma_n < sigma_1 ) {
            // Case 2: the equipotential line lies between circle 3 - 1 and circle 2 - 1:
            // tau_1 = shear stress for point pO located in the Mohr circle 3-1 at normal stress sigma_n
             const tau_1 = Math.sqrt( rad_2_1**2 - (sigma_n - sigma_2_1_mean)**2 )
             // alfa_1 = angle (in radians) between line segment (sigma_2,tau_n0) in circle 2-1 and the horizontal axis (sigma_2, sigma_1) :
             const alfa_1 = Math.atan( tau_1 / (sigma_n - sigma_2) )

            // Plot curve corresponding to the line segment between points: (sigma_n, tau_n0) and (sigma_n, tau_1)
            MohrCircleLine( '3_1', sigma_n, tau_n0, alfa_n0, '2_1', sigma_n, tau_1, alfa_1 )
        }   
        else if ( sigma_n == sigma_2 )  {
            // Case 3: the equipotential line lies between circle 3 - 1 and sigma_2:
            // tau_1 = shear stress for point pO
             const tau_1 = 0
             // alfa_1 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :
             const alfa_1 = 0

            // Plot curve corresponding to the line segment between points: (sigma_n, tau_n0) and (sigma_n, tau_1)
            MohrCircleLine( '3_1', sigma_n, tau_n0, alfa_n0, '3_2', sigma_n, tau_1, alfa_1 )
        }   


        // for (let i=0; i<=180; ++i) {
        //     const phi = Math.PI * i/360
        //     const var1 =  ( Fn - this.lambda[2]) / ( this.lambda[0] * Math.cos(phi)**2 + this.lambda[1] * Math.sin(phi)**2 - this.lambda[2] )
        //     if (var1 >= 0 && var1 <= 1 ) {
        //         // const theta = Math.asin( Math.sqrt( ( Fn - this.lambda[2]) / ( this.lambda[0] * Math.cos(phi)**2 + this.lambda[1] * Math.sin(phi)**2 - this.lambda[2] ) ) )
        //         const theta = Math.asin( Math.sqrt( var1 ) )
        //         const x = this.r * Math.sin(theta) * Math.cos(phi)
        //         const y = this.r * Math.sin(theta) * Math.sin(phi)
        //         const z = this.r * Math.cos(theta)
        //         lineBuilder.addPoint(x, y, z)
        //     } 
        // }
        // buffer += lineBuilder.buffer + '\n'

        // lineBuilder.clear()



        // MOHR-COULOMB FRICTION

        // The frictional strength law is defined by a Mohr-Coulomb line involving friction and cohesion:
        // These two parameters must be fixed by the user in the menu within a predefined range
        // The cohesion c is defined between [0,0.5] for a normalized stress tensor (sigma_1=1, sigma_2= R, sigma_3=0)
 
        // The friction angle phi_a varies in the range [0, phi_3_1], 
        //      where phi_3_1 is the angle of the line tangent to Mohr circle between sigma_3 - sigma_1 that passes by c
        //      tan(pi / 4 + phi_3_1 / 2) = sigma_1 / (2*c)

        const phi_3_1 = 2 * ( Math.atan( sigma_1 / (2*c) ) - Math.PI/4 ) * 180 / Math.PI

        // We calculate two other threshold angles for lines tangent to Mohr circles between sigma_3 - sigma_2, and sigma_2 - sigma_1

        // Angle phi_3_2 for Mohr circle between sigma_2 - sigma_3 is calculated with a similar equation:

        const phi_3_2 = 2 * ( Math.atan( sigma_2 / (2*c) ) - Math.PI/4 ) * 180 / Math.PI

        // Angle phi_2_1 for Mohr circle between sigma_1 - sigma_2 is calculated from the general equation:
        //      tan(pi / 4 + phi_2_1 / 2) = ( - c + sqrt( c^2 + sigma_2 * sigma_1 ) ) / sigma_2

        const phi_2_1 = 2 * ( Math.atan( ( - c + Math.SQRT( c^2 + sigma_1 * sigma_2 ) ) / sigma_2 ) - Math.PI/4 ) * 180 / Math.PI

        // Let (c, phi_a) be the cohesion and friction angle chosen by the user. The friction coefficient mu is the slope of the line

        const mu = Math.tan( phi_a * Math.PI / 180 )

        // The Mohr-Coulomb line intersects the 3D Mohr circle in 1, 2 or 3 different line segments 

        // The line always intersects circle 1 - 3 in two points named: sigma_3_1[0], tau_3_1[0] and sigma_3_1[1], tau_3_1[1]
        //      such that sigma_3_1[0] <= sigma_3_1[1]
        // sigma_3_1 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:
        const a_qe = 1 + mu**2
        const b_qe = 2 * ( c * mu - sigma_3_1_mean )
        const c_qe = c**2 + sigma_1 * sigma_3
        
        //  Calculate the discriminant of the quadratic equation:
        let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )
        //  Calculate intersection points
        const sigma_3_1[0] = ( - b_qe - delta ) / ( 2 * a_qe )
        const tau_3_1[0] = Math.sqrt( rad_3_1**2 - ( sigma_3_1[0] - sigma_3_1_mean )**2 )
        const sigma_3_1[1] = ( - b_qe + delta ) / ( 2 * a_qe )
        const tau_3_1[1] = Math.sqrt( rad_3_1**2 - ( sigma_3_1[1] - sigma_3_1_mean )**2 )

        // Calculate the angle (in radians) between segment (sigma_3,tau_3_1) in circle 3-1 and the horizontal axis (sigma_3, sigma_1) :
        // alfa_3_1 is the azimuthal angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
        const alfa_3_1[0] = Math.atan( tau_3_1[0] / ( sigma_3_1[0] - sigma_3 ))
        const alfa_3_1[1] = Math.atan( tau_3_1[1] / ( sigma_3_1[1] - sigma_3 ))

        // Define booleans indicating if the friction line intersects the smaller Mohr circles:
        let circle_2_1 = false
        let circle_3_2 = false

        if ( phi_a < phi_3_2 ) {

            let circle_2_1 = true

            // The Mohr-Coulomb line intersects circle 2 - 3 in two points named: sigma_3_2[0], tau_3_2[0] and sigma_3_2[1], tau_3_2[1]
            //      such that sigma_3_2[0] <= sigma_3_2[1]
    
            // sigma_3_2 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:
            const a_qe = 1 + mu**2
            const b_qe = 2 * ( c * mu - sigma_3_2_mean )
            const c_qe = c**2 + sigma_2 * sigma_3
            
            //  Calculate the discriminant of the quadratic equation:
            let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )
            //  Calculate intersection points
            const sigma_3_2[0] = ( - b_qe - delta ) / ( 2 * a_qe )
            const tau_3_2[0] = Math.sqrt( rad_3_2**2 - ( sigma_3_2[0] - sigma_3_2_mean )**2 )
            const sigma_3_2[1] = ( - b_qe + delta ) / ( 2 * a_qe )
            const tau_3_2[1] = Math.sqrt( rad_3_2**2 - ( sigma_3_2[1] - sigma_3_2_mean )**2 )
    
            // Calculate the angle (in radians) between segment (sigma_3,tau_3_2) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :
            // alfa_3_2 is the polar angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
            const alfa_3_2[0] = Math.atan( tau_3_2[0] / ( sigma_3_2[0] - sigma_3 ))
            const alfa_3_2[1] = Math.atan( tau_3_2[1] / ( sigma_3_2[1] - sigma_3 ))

        }

        if ( phi_a < phi_2_1 ) {

            circle_2_1 = true

            // The Mohr-Coulomb line intersects circle 1 - 2 in two points named: sigma_2_1[0], tau_2_1[0] and sigma_2_1[1], tau_2_1[1]
            //      such that sigma_2_1[0] <= sigma_2_1[1]
    
            // sigma_2_1 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:
            const a_qe = 1 + mu**2
            const b_qe = 2 * ( c * mu - sigma_2_1_mean )
            const c_qe = c**2 + sigma_1 * sigma_2
            
            //  Calculate the discriminant of the quadratic equation:
            let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )
            //  Calculate intersection points
            const sigma_2_1[0] = ( - b_qe - delta ) / ( 2 * a_qe )
            const tau_2_1[0] = Math.sqrt( rad_2_1**2 - ( sigma_2_1[0] - sigma_2_1_mean )**2 )
            const sigma_2_1[1] = ( - b_qe + delta ) / ( 2 * a_qe )
            const tau_2_1[1] = Math.sqrt( rad_2_1**2 - ( sigma_2_1[1] - sigma_2_1_mean )**2 )
    
            // Calculate the angle (in radians) between segment (sigma_2,tau_2_1) in circle 2-1 and the horizontal axis (sigma_2, sigma_1) :
            // alfa_2_1 is the latitude in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
            const alfa_2_1[0] = Math.atan( tau_2_1[0] / ( sigma_2_1[0] - sigma_2 ))
            const alfa_2_1[1] = Math.atan( tau_2_1[1] / ( sigma_2_1[1] - sigma_2 ))
        }

        // We calculate the corresponding curves in the sphere:

        if ( !circle_2_1 && !circle_3_2 ) {
            // Case 1: the Mohr-Coulomb line only intersects circle 3 - 1
            // Plot curve corresponding to the line segment between points: 
            //      sigma_3_1[0], tau_3_1[0] and sigma_3_1[1], tau_3_1[1]
            MohrCircleLine( '3_1', sigma_3_1[0], tau_3_1[0], alfa_3_1[0], '3_1', sigma_3_1[1], tau_3_1[1], alfa_3_1[1] )
        }   
        else if ( !circle_2_1 && circle_3_2 )  {
            // Case 2: the Mohr-Coulomb line intersects circle 3 - 1 and circle 3 - 2
            // Plot curves corresponding to the line segment between points: 
            //      sigma_3_1[0], tau_3_1[0] and sigma_3_2[0], tau_3_2[0];
            MohrCircleLine( '3_1', sigma_3_1[0], tau_3_1[0], alfa_3_1[0], '3_2', sigma_3_2[0], tau_3_2[0], alfa_3_2[0] )
            //      sigma_3_2[1], tau_3_2[1] and sigma_3_1[1], tau_3_1[1];
            MohrCircleLine( '3_2', sigma_3_2[1], tau_3_2[1], alfa_3_2[1], '3_1', sigma_3_1[1], tau_3_1[1], alfa_3_1[1] )            
        }

        else if ( circle_2_1 && !circle_3_2 ) {
            // Case 3: the Mohr-Coulomb line intersects circle 3 - 1 and circle 2 - 1
            // Plot curves corresponding to the line segment between points: 
            //      sigma_3_1[0], tau_3_1[0] and sigma_2_1[0], tau_2_1[0];
            MohrCircleLine( '3_1', sigma_3_1[0], tau_3_1[0], alfa_3_1[0], '2_1', sigma_2_1[0], tau_2_1[0], alfa_2_1[0] )
            //      sigma_2_1[1], tau_2_1[1] and sigma_3_1[1], tau_3_1[1];
            MohrCircleLine( '2_1', sigma_2_1[1], tau_2_1[1], alfa_2_1[1], '3_1', sigma_3_1[1], tau_3_1[1], alfa_3_1[1] )
        }

        else {
            // Case 4: the Mohr-Coulomb line intersects circle 3 - 1, circle 3 - 2, and circle 2 - 1
            // Plot curves corresponding to the line segment between points: 
            //      sigma_3_1[0], tau_3_1[0] and sigma_3_2[0], tau_3_2[0];
            MohrCircleLine( '3_1', sigma_3_1[0], tau_3_1[0], alfa_3_1[0], '3_2', sigma_3_2[0], tau_3_2[0], alfa_3_2[0] )
            //      sigma_3_2[1], tau_3_2[1] and sigma_2_1[0], tau_2_1[0];
            MohrCircleLine( '3_2', sigma_3_2[1], tau_3_2[1], alfa_3_2[1], '2_1', sigma_2_1[0], tau_2_1[0], alfa_2_1[0] )            
            //      sigma_2_1[1], tau_2_1[1] and sigma_3_1[1], tau_3_1[1];
            MohrCircleLine( '2_1', sigma_2_1[1], tau_2_1[1], alfa_2_1[1], '3_1', sigma_3_1[1], tau_3_1[1], alfa_3_1[1] )
        }

        function MohrCircleLine( MohrCirc0: string, p0X: number, p0Y: number, alfa0: number,
                                MohrCirc1: string, p1X: number, p1y: number, alfa1: number ): void {
            
            lineBuilder.clear()

            if ( sigma_2 == sigma_3) {
                // Particular Case 1: revolution stress tensor around sigma_1
                // In such situation, points pO and p1 have equal coordinates and alfa angles
                // Curve is a circle sweeping at an angle alfa0 around sigma_1
                arcCircle( 'sigma_1', alfa0 )
            }
            else if ( sigma_2 == sigma_1) {
                // Particular Case 2: revolution stress tensor around sigma_3
                // In such situation, points pO and p1 have equal coordinates and alfa angles
                // Curve is a circle sweeping at an angle PI/2 - alfa0 around sigma_3
                arcCircle( 'sigma_3', Math.PI/2 - alfa0 )
            }   
            else {
                // General Case:
                // Add to the list the initial point of the line segment located in one of the 3 Mohr circles
                MohrCirclePoint( MohrCirc0, alfa0)

                // Add to the list the intermediate points of the line segment located between 2 Mohr circles
                // We calculate the direction cosines of the unit vector normal to the fault whose stress state is given by (X, Y)
                //      Note that (X,Y) are the normal and shear stress of a moving point along the Mohr-Coulomb line segment 

                // Without loss of generality, we suppose a stress tensor in strike-slip regime (fixing sigma_1 Eastward and sigma_3 Northward)
                let sigma_X = sigma_1
                let sigma_Y = sigma_3
                let sigma_Z = sigma_2

                for (let i=1; i<=180; ++i) {
                    let X = p0X + (p1X - p0X) * i / 180
                    let Y = p0Y + (p1Y - p0Y) * i / 180

                    let nx = Math.sqrt( ( (sigma_Y - X) * (sigma_Z - X) + Y**2 ) / ( (sigma_Y - sigma_X) * (sigma_Z - sigma_X) ))
                    let ny = Math.sqrt( ( (sigma_Z - X) * (sigma_X - X) + Y**2 ) / ( (sigma_Z - sigma_Y) * (sigma_X - sigma_Y) ))
                    let nz = Math.sqrt( ( (sigma_X - X) * (sigma_Y - X) + Y**2 ) / ( (sigma_X - sigma_Z) * (sigma_Y - sigma_Z) ))

                    const x = this.r * nx
                    const y = this.r * ny
                    const z = this.r * nz

                    lineBuilder.addPoint(x, y, z)  
                }
            }
        
            // Add to the list the final point of the line segment located in one of the 3 Mohr circles
            MohrCirclePoint( MohrCirc1, alfa1)
            // Insert empty line in list

            buffer += lineBuilder.buffer + '\n'
        }

        function MohrCirclePoint( MohrCirc: string, alfa: number): void {
            // Add to the list the initial or final point of the line segment located in one of the 3 Mohr circles
                
            if (MohrCirc == '3_1' ) {
                // The point is located in Mohr circle between sigma_3 and sigma_1
                // alfa is the azimuthal angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
                const theta = Math.PI/2
                const phi = alfa
                const x = this.r * Math.sin(theta) * Math.cos(phi)
                const y = this.r * Math.sin(theta) * Math.sin(phi)
                const z = this.r * Math.cos(theta)
            }
            else if (MohrCirc == '3_2' ) {
                // The point is located in Mohr circle between sigma_3 and sigma_2
                // alfa is the polar angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
                const theta = alfa
                const phi = Math.PI/2
                const x = this.r * Math.sin(theta) * Math.cos(phi)
                const y = this.r * Math.sin(theta) * Math.sin(phi)
                const z = this.r * Math.cos(theta)    

            }      
            else { // MohrCirc == '2_1'
                // The point is located in Mohr circle between sigma_2 and sigma_1
                // alfa is the latitude angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)
                const theta = 0
                const phi =  Math.PI/2 - alfa
                const x = this.r * Math.sin(theta) * Math.cos(phi)
                const y = this.r * Math.sin(theta) * Math.sin(phi)
                const z = this.r * Math.cos(theta)
            } 

            // Add the point in the Mohr Circle to the list
            lineBuilder.addPoint(x, y, z)  
        }

        function arcCircle( sigma: string, alfa: number ) {

            lineBuilder.clear()

            if (sigma == 'sigma_1' ) {
                // Particular case 1: sigma_2 = sigma_3 (revolution stress tensor around sigma_1)
                // Generate a circular segment (one quarter of a circle) sweeping an angle alfa around sigma_1
                const x = this.r * Math.cos( alfa )
                const rad_circle = this.r * Math.sin( alfa )

                for (let i=1; i<=180; ++i) {

                    let beta = Math.PI * i / 360

                    const y = rad_circle * Math.cos( beta )
                    const Z = rad_circle * Math.sin( beta )
    
                    lineBuilder.addPoint(x, y, z)  
                }
            }

            else if (sigma == 'sigma_3' ) {
                // Particular case 2: sigma_2 = sigma_1 (revolution stress tensor around sigma_3)
                // Generate a circular segment (one quarter of a circle) sweeping an angle alfa around sigma_3
                const y = this.r * Math.cos( alfa )
                const rad_circle = this.r * Math.sin( alfa )
    
                for (let i=1; i<=180; ++i) {
    
                    let beta = Math.PI * i / 360
    
                    const x = rad_circle * Math.cos( beta )
                    const Z = rad_circle * Math.sin( beta )
        
                    lineBuilder.addPoint(x, y, z)  
                }
            }

           // Insert empty line in list
            buffer += lineBuilder.buffer + '\n'
        }


        return buffer

