!function(t,a){"object"==typeof exports&&"object"==typeof module?module.exports=a():"function"==typeof define&&define.amd?define("@alfredo-taboada/stress",[],a):"object"==typeof exports?exports["@alfredo-taboada/stress"]=a():t["@alfredo-taboada/stress"]=a()}("undefined"!=typeof self?self:this,(function(){return(()=>{"use strict";var t={d:(a,s)=>{for(var i in s)t.o(s,i)&&!t.o(a,i)&&Object.defineProperty(a,i,{enumerable:!0,get:s[i]})},o:(t,a)=>Object.prototype.hasOwnProperty.call(t,a),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},a={};t.r(a),t.d(a,{Curve3D:()=>s,EquipotentialCurve:()=>o,IntegralCurve:()=>n,MohrCoulombCurve:()=>c,Vector:()=>i});class s{constructor(){this.points=[]}addPoint(t,a,s=0){"number"==typeof t?this.points.push(t,a,s):this.points.push(t[0],t[1],t[2])}clear(){this.points=[]}get buffer(){let t="GOCAD PLine 1.0\n        HEADER {\n            name: curve3d\n        }\n        PROPERTIES rake\n        ";const a=this.points.length/3;let s=0;for(let a=0;a<this.points.length;a+=3){const i=0;t+="PVRTX "+s+" "+this.points[a]+" "+this.points[a+1]+" "+this.points[a+2]+" "+i+"\n",s++}for(let s=0;s<a-1;++s)t+="SEG "+s+" "+(s+1)+"\n";return t+="END",t}}class i{constructor(t,a,s){this.radius=t,this.theta=a,this.phi=s,this.x=this.radius*Math.sin(this.phi)*Math.cos(this.theta),this.y=this.radius*Math.sin(this.phi)*Math.sin(this.theta),this.z=this.radius*Math.cos(this.phi)}vector_rotation(t){this.x=Math.sin(t)}}class n{constructor(t,a=1){this.lambda=t,this.r=a,this.exp_sin=(this.lambda[0]-this.lambda[2])/(this.lambda[1]-this.lambda[0]),this.exp_cos=(this.lambda[2]-this.lambda[1])/(this.lambda[1]-this.lambda[0])}generate(t,a){const i=new s;let n=Math.PI*a/180,h=Math.PI*t/180,e=Math.tan(h)/(Math.sin(n)**this.exp_sin*Math.cos(n)**this.exp_cos);for(let t=0;t<=180;++t){const a=Math.PI*t/360,s=Math.atan(e*Math.sin(a)**this.exp_sin*Math.cos(a)**this.exp_cos),n=this.r*Math.sin(s)*Math.cos(a),h=this.r*Math.sin(s)*Math.sin(a),r=this.r*Math.cos(s);i.addPoint(n,h,r)}return i.buffer}}function h({r:t,first:a,second:i,sigma_1:n,sigma_2:h,sigma_3:o}){const c=new s;if(h==o)return r({sigma:"sigma_1",alpha:a.angle});if(h==n)return r({sigma:"sigma_3",alpha:Math.PI/2-a.angle});{c.addPoint(e({mohrCirc:a.circle,alfa:a.angle,r:t}));let s=n,r=o,l=h;for(let n=1;n<=180;++n){let h=a.p[0]+(i.p[0]-a.p[0])*n/180,e=a.p[1]+(i.p[1]-a.p[1])*n/180;const o=t*Math.sqrt(((r-h)*(l-h)+e**2)/((r-s)*(l-s))),_=t*Math.sqrt(((l-h)*(s-h)+e**2)/((l-r)*(s-r))),M=t*Math.sqrt(((s-h)*(r-h)+e**2)/((s-l)*(r-l)));c.addPoint(o,_,M)}return c.addPoint(e({mohrCirc:i.circle,alfa:i.angle,r:t})),c.buffer}}function e({r:t,mohrCirc:a,alfa:s}){if("3_1"==a){const a=Math.PI/2,i=s;return[t*Math.sin(a)*Math.cos(i),t*Math.sin(a)*Math.sin(i),t*Math.cos(a)]}if("3_2"==a){const a=s,i=Math.PI/2;return[t*Math.sin(a)*Math.cos(i),t*Math.sin(a)*Math.sin(i),t*Math.cos(a)]}{const a=0,i=Math.PI/2-s;return[t*Math.sin(a)*Math.cos(i),t*Math.sin(a)*Math.sin(i),t*Math.cos(a)]}}function r({sigma:t,alpha:a}){const i=new s;if("sigma_1"===t){const t=this.r*Math.cos(a),s=this.r*Math.sin(a);for(let a=1;a<=180;++a){let n=Math.PI*a/360;const h=s*Math.cos(n),e=s*Math.sin(n);i.addPoint(t,h,e)}}else if("sigma_3"===t){const t=this.r*Math.cos(a),s=this.r*Math.sin(a);for(let a=1;a<=180;++a){let n=Math.PI*a/360;const h=s*Math.cos(n),e=s*Math.sin(n);i.addPoint(h,t,e)}}return i.buffer}class o{constructor(t,a=1){this.lambda=t,this.r=a,this.exp_sin=(this.lambda[0]-this.lambda[2])/(this.lambda[1]-this.lambda[0]),this.exp_cos=(this.lambda[2]-this.lambda[1])/(this.lambda[1]-this.lambda[0])}generate(t,a){new s;const i=-this.lambda[0],n=-this.lambda[1],e=-this.lambda[2],r=(i+e)/2,o=(i-e)/2,c=(n+e)/2,l=(n-e)/2,_=(i+n)/2,M=(i-n)/2;let m=(this.lambda[0]*Math.cos(a)**2+this.lambda[1]*Math.sin(a)**2)*Math.sin(t)**2+this.lambda[2]*(1-Math.sin(t)**2);const d=Math.sqrt(o**2-(m-r)**2),g=Math.atan(d/(m-e));if(m>e&&m<n){const t=Math.sqrt(l**2-(m-c)**2),a={circle:"3_1",p:[m,d],angle:g},s={circle:"3_2",p:[m,t],angle:Math.atan(t/(m-e))};return h({r:this.r,first:a,second:s,sigma_1:i,sigma_2:n,sigma_3:e})}if(m>n&&m<i){const t=Math.sqrt(M**2-(m-_)**2),a={circle:"3_1",p:[m,d],angle:g},s={circle:"2_1",p:[m,t],angle:Math.atan(t/(m-n))};return h({r:this.r,first:a,second:s,sigma_1:i,sigma_2:n,sigma_3:e})}if(m==n){const t={circle:"3_1",p:[m,d],angle:g},a={circle:"3_2",p:[m,0],angle:0};return h({r:this.r,first:t,second:a,sigma_1:i,sigma_2:n,sigma_3:e})}return""}}class c{constructor(t,a=1){this.lambda=t,this.r=a}generate(t,a){new s;const i=-this.lambda[0],n=-this.lambda[1],e=-this.lambda[2],r=(i+e)/2,o=(i-e)/2,c=(n+e)/2,l=(n-e)/2,_=(i+n)/2,M=(i-n)/2;if(a<0||a>.5)throw new Error("Cohesion must be in [0, 0.5]");const m=a,d=t*Math.PI/180;Math.atan(i/(2*m)),Math.PI,Math.PI;const g=2*(Math.atan(n/(2*m))-Math.PI/4)*180/Math.PI,f=2*(Math.atan((-m+Math.sqrt(m^2+i*n))/n)-Math.PI/4)*180/Math.PI,u=Math.tan(d*Math.PI/180),p=[0,0],b=[0,0],P=[0,0],I=[0,0],q=[0,0],y=[0,0],x=[0,0],w=[0,0],v=[0,0],C={sigma_3_1:p,tau_3_1:b,alfa_3_1:P,sigma_3_2:I,tau_3_2:q,alfa_3_2:y,sigma_2_1:x,tau_2_1:w,alfa_2_1:v},E=1+u**2,S=2*(m*u-r),j=m**2+i*e;let O=Math.sqrt(S**2-4*E*j);p[0]=(-S-O)/(2*E),b[0]=Math.sqrt(o**2-(p[0]-r)**2),p[1]=(-S+O)/(2*E),b[1]=Math.sqrt(o**2-(p[1]-r)**2),P[0]=Math.atan(b[0]/(p[0]-e)),P[1]=Math.atan(b[1]/(p[1]-e));let D=!1;if(d<g){const t=1+u**2,a=2*(m*u-c),s=m**2+n*e;let i=Math.sqrt(a**2-4*t*s);I[0]=(-a-i)/(2*t),q[0]=Math.sqrt(l**2-(I[0]-c)**2),I[1]=(-a+i)/(2*t),q[1]=Math.sqrt(l**2-(I[1]-c)**2),y[0]=Math.atan(q[0]/(I[0]-e)),y[1]=Math.atan(q[1]/(I[1]-e))}if(d<f){D=!0;const t=1+u**2,a=2*(m*u-_),s=m**2+i*n;let h=Math.sqrt(a**2-4*t*s);x[0]=(-a-h)/(2*t),w[0]=Math.sqrt(M**2-(x[0]-_)**2),x[1]=(-a+h)/(2*t),w[1]=Math.sqrt(M**2-(x[1]-_)**2),v[0]=Math.atan(w[0]/(x[0]-n)),v[1]=Math.atan(w[1]/(x[1]-n))}if(D){if(D){let t=h({r:this.r,first:this.getPoint(0,"3_1",C),second:this.getPoint(0,"2_1",C),sigma_1:i,sigma_2:n,sigma_3:e});return t+="\n",t+=h({r:this.r,first:this.getPoint(1,"2_1",C),second:this.getPoint(1,"3_1",C),sigma_1:i,sigma_2:n,sigma_3:e}),t}{let t=h({r:this.r,first:this.getPoint(0,"3_1",C),second:this.getPoint(0,"3_2",C),sigma_1:i,sigma_2:n,sigma_3:e});return t+="\n",t+=h({r:this.r,first:this.getPoint(1,"3_2",C),second:this.getPoint(0,"2_1",C),sigma_1:i,sigma_2:n,sigma_3:e}),t+="\n",t+=h({r:this.r,first:this.getPoint(1,"2_1",C),second:this.getPoint(1,"3_1",C),sigma_1:i,sigma_2:n,sigma_3:e}),t}}return h({r:this.r,first:this.getPoint(0,"3_1",C),second:this.getPoint(1,"3_1",C),sigma_1:i,sigma_2:n,sigma_3:e})}getPoint(t,a,s){if("3_1"===a)return{circle:a,p:[s.sigma_3_1[t],s.tau_3_1[t]],angle:s.alfa_3_1[t]};if("3_2"===a)return{circle:a,p:[s.sigma_3_2[t],s.tau_3_2[t]],angle:s.alfa_3_2[t]};if("2_1"===a)return{circle:a,p:[s.sigma_2_1[t],s.tau_2_1[t]],angle:s.alfa_2_1[t]};throw new Error(`name ${a} is unknown. Should be 3_1, 3_2 or 2_1`)}}return a})()}));
//# sourceMappingURL=stress.js.map