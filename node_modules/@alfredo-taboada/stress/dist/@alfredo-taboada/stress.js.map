{"version":3,"sources":["webpack://@alfredo-taboada/stress/webpack/universalModuleDefinition","webpack://@alfredo-taboada/stress/webpack/bootstrap","webpack://@alfredo-taboada/stress/webpack/runtime/define property getters","webpack://@alfredo-taboada/stress/webpack/runtime/hasOwnProperty shorthand","webpack://@alfredo-taboada/stress/webpack/runtime/make namespace object","webpack://@alfredo-taboada/stress/./lib/Curve3D.ts","webpack://@alfredo-taboada/stress/./lib/Stress_Tensor_1.ts","webpack://@alfredo-taboada/stress/./lib/IntegralCurve.ts","webpack://@alfredo-taboada/stress/./lib/utils.ts","webpack://@alfredo-taboada/stress/./lib/EquipotentialCurve.ts","webpack://@alfredo-taboada/stress/./lib/MohrCoulombCurves.ts"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Curve3D","points","addPoint","x","y","z","push","clear","buffer","s","nbPoints","length","index","i","attr","Vector","constructor","radius","theta","phi","Math","sin","cos","vector_rotation","rotAx_phi","IntegralCurve","lambda","r","exp_sin","exp_cos","generate","lineBuilder","phi_1","PI","theta_1","k1","tan","atan","mohrCircleLine","first","second","sigma_1","sigma_2","sigma_3","arcCircle","sigma","alpha","angle","mohrCirclePoint","mohrCirc","circle","alfa","sigma_X","sigma_Y","sigma_Z","X","p","Y","sqrt","rad_circle","beta","EquipotentialCurve","sigma_3_1_mean","rad_3_1","sigma_3_2_mean","rad_3_2","sigma_2_1_mean","rad_2_1","sigma_n","tau_0","alfa_0","tau_1","MohrCoulombCurve","frictionAngle","cohesion","Error","c","phi_a","phi_3_2","phi_2_1","mu","sigma_3_1","tau_3_1","alfa_3_1","sigma_3_2","tau_3_2","alfa_3_2","sigma_2_1","tau_2_1","alfa_2_1","struct","a_qe","b_qe","c_qe","delta","circle_2_1","getPoint","name"],"mappings":"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","file":"@alfredo-taboada/stress.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@alfredo-taboada/stress\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@alfredo-taboada/stress\"] = factory();\n\telse\n\t\troot[\"@alfredo-taboada/stress\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Point3D } from \"./types\"\n\nexport class Curve3D {\n    private points: Array<number> = []\n\n    addPoint(x: number | Point3D, y?: number, z: number = 0) {\n        if (typeof x === 'number') {\n            this.points.push(x,y,z)\n        }\n        else {\n            this.points.push(x[0], x[1], x[2])\n        }\n    }\n\n    clear() {\n        this.points = []\n    }\n\n    get buffer(): string {\n        let s = `GOCAD PLine 1.0\n        HEADER {\n            name: curve3d\n        }\n        PROPERTIES rake\n        `\n\n        const nbPoints = this.points.length/3\n        let index = 0\n        \n        for (let i=0; i<this.points.length; i+=3) {\n            const attr = 0\n            s += 'PVRTX ' + index+' ' + this.points[i] + ' ' + this.points[i+1] + ' ' + this.points[i+2] + ' ' + attr + '\\n'\n            index++\n        }\n\n        for (let i=0; i<nbPoints-1; ++i) {\n            s += 'SEG '+i+' '+(i+1) +'\\n'\n        }\n        s += 'END'\n\n        return s\n    }\n}\n","export class Vector {\n    // Define vector in spherical coordinates\n    // All properties are public by default\n    // Define vector in catesian coordinates\n    x: number; \n    y: number;  \n    z: number;\n\n    /**\n     * \n     * @param radius The radius of the sphere\n     * @param theta \n     * @param phi \n     */\n    constructor(public radius: number, public theta: number, public phi: number) {\n        this.x = this.radius * Math.sin( this.phi) * Math.cos( this.theta);;\n        this.y = this.radius * Math.sin( this.phi) * Math.sin( this.theta);;\n        this.z = this.radius * Math.cos( this.phi);\n    }\n\n    /**\n     * Rotate the tensor about an angle...\n     * @param rotAx_phi \n     */\n    vector_rotation(rotAx_phi: number): void {\n        this.x = Math.sin( rotAx_phi);\n    }\n}\n","import { Curve3D } from \"./Curve3D\"\nimport { GenericCurve } from \"./types\"\n\nexport class IntegralCurve implements GenericCurve {\n    private r: number\n    private exp_cos: number\n    private exp_sin: number\n\n    constructor(private lambda: [number, number, number], radius = 1) {\n        this.r = radius\n        this.exp_sin = ( this.lambda[0] - this.lambda[2] ) / ( this.lambda[1] - this.lambda[0] )\n        this.exp_cos = ( this.lambda[2] - this.lambda[1] ) / ( this.lambda[1] - this.lambda[0] )\n    }\n\n    /**\n     * Define a tangent plane by fixing angles phi and theta in spherical coordinates\n     * @param theta In degrees\n     * @param phi In degrees\n     */\n    generate(theta: number, phi: number): string {\n        const lineBuilder = new Curve3D()\n        let phi_1 = Math.PI * phi /180\n        let theta_1 = Math.PI * theta /180\n\n        // Determine integral curve that passes by this point of the sphere surface, by calculating k1\n        // k1 is defined as a function of phi and theta for a specific symmetrical tensor\n        let k1 = Math.tan(theta_1) / ( Math.sin(phi_1)**this.exp_sin * Math.cos(phi_1)**this.exp_cos )\n\n        // Plot the integral curve that passes by this specific point\n        for (let i=0; i<=180; ++i) {\n            const phi = Math.PI * i/360\n            const theta = Math.atan( k1 * Math.sin(phi)**this.exp_sin * Math.cos(phi)**this.exp_cos )\n            const x = this.r * Math.sin(theta) * Math.cos(phi)\n            const y = this.r * Math.sin(theta) * Math.sin(phi)\n            const z = this.r * Math.cos(theta)\n            lineBuilder.addPoint(x, y, z)\n        }\n        \n        return lineBuilder.buffer\n    }\n}\n","import { Curve3D } from \"./Curve3D\"\nimport { MohrPoint, Point3D } from \"./types\"\n\nexport function deg2rad(a: number): number {\n    return a*Math.PI/180\n}\n\nexport const rad2deg = (a: number): number => a/Math.PI*180\n\nexport function mohrCircleLine(\n    {r, first, second, sigma_1, sigma_2, sigma_3}:\n    {r: number, first: MohrPoint, second: MohrPoint, sigma_1: number, sigma_2: number, sigma_3: number}): string\n{\n    const lineBuilder = new Curve3D()\n\n    if (sigma_2 == sigma_3) {\n        // Particular Case 1: revolution stress tensor around sigma_1\n        // In such situation, points pO and p1 have equal coordinates and alfa angles\n        // Curve is a circle sweeping at an angle alfa0 around sigma_1\n        return arcCircle({sigma: 'sigma_1', alpha: first.angle})\n    }\n    else if (sigma_2 == sigma_1) {\n        // Particular Case 2: revolution stress tensor around sigma_3\n        // In such situation, points pO and p1 have equal coordinates and alfa angles\n        // Curve is a circle sweeping at an angle PI/2 - alfa0 around sigma_3\n        return arcCircle({sigma: 'sigma_3', alpha: Math.PI / 2 - first.angle})\n    }\n    else {\n        // General Case:\n        // Add to the list the initial point of the line segment located in one of the 3 Mohr circles\n        lineBuilder.addPoint(mohrCirclePoint( {mohrCirc: first.circle, alfa: first.angle, r} ))\n\n        // Add to the list the intermediate points of the line segment located between 2 Mohr circles\n        // We calculate the direction cosines of the unit vector normal to the fault whose stress state is given by (X, Y)\n        //      Note that (X,Y) are the normal and shear stress of a moving point along the Mohr-Coulomb line segment \n\n        // Without loss of generality, we suppose a stress tensor in strike-slip regime (fixing sigma_1 Eastward and sigma_3 Northward)\n        let sigma_X = sigma_1\n        let sigma_Y = sigma_3\n        let sigma_Z = sigma_2\n\n        for (let i = 1; i <= 180; ++i) {\n            let X = first.p[0] + (second.p[0] - first.p[0]) * i / 180\n            let Y = first.p[1] + (second.p[1] - first.p[1]) * i / 180\n\n            let nx = Math.sqrt(((sigma_Y - X) * (sigma_Z - X) + Y ** 2) / ((sigma_Y - sigma_X) * (sigma_Z - sigma_X)))\n            let ny = Math.sqrt(((sigma_Z - X) * (sigma_X - X) + Y ** 2) / ((sigma_Z - sigma_Y) * (sigma_X - sigma_Y)))\n            let nz = Math.sqrt(((sigma_X - X) * (sigma_Y - X) + Y ** 2) / ((sigma_X - sigma_Z) * (sigma_Y - sigma_Z)))\n\n            const x = r * nx\n            const y = r * ny\n            const z = r * nz\n\n            lineBuilder.addPoint(x, y, z)\n        }\n\n        // Add to the list the final point of the line segment located in one of the 3 Mohr circles\n        lineBuilder.addPoint(mohrCirclePoint( {mohrCirc: second.circle, alfa: second.angle, r} ))\n\n        return lineBuilder.buffer\n    }\n}\n\nexport function mohrCirclePoint(\n    {r, mohrCirc, alfa}:\n    {r: number, mohrCirc: string, alfa: number}): Point3D\n{\n    // Add to the list the initial or final point of the line segment located in one of the 3 Mohr circles\n\n    if (mohrCirc == '3_1') {\n        // The point is located in Mohr circle between sigma_3 and sigma_1\n        // alfa is the azimuthal angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n        const theta = Math.PI / 2\n        const phi = alfa\n        return [\n            r * Math.sin(theta) * Math.cos(phi),\n            r * Math.sin(theta) * Math.sin(phi),\n            r * Math.cos(theta)\n        ]\n    }\n    else if (mohrCirc == '3_2') {\n        // The point is located in Mohr circle between sigma_3 and sigma_2\n        // alfa is the polar angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n        const theta = alfa\n        const phi = Math.PI / 2\n        return [\n            r * Math.sin(theta) * Math.cos(phi),\n            r * Math.sin(theta) * Math.sin(phi),\n            r * Math.cos(theta)\n        ]\n\n    }\n    else {\n        // MohrCirc == '2_1'\n        // The point is located in Mohr circle between sigma_2 and sigma_1\n        // alfa is the latitude angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n        const theta = 0\n        const phi = Math.PI / 2 - alfa\n        return [\n            r * Math.sin(theta) * Math.cos(phi),\n            r * Math.sin(theta) * Math.sin(phi),\n            r * Math.cos(theta)\n        ]\n    }\n}\n\n/**\n * Usage:\n * ```ts\n * const arc = arcCircle({alpha: deg2rad(12), sigma: '3_1'})\n * ```\n */\nexport function arcCircle(\n    {sigma, alpha}:\n    {sigma: string, alpha: number}): string\n{\n\n    const lineBuilder = new Curve3D()\n\n    if (sigma === 'sigma_1') {\n        // Particular case 1: sigma_2 = sigma_3 (revolution stress tensor around sigma_1)\n        // Generate a circular segment (one quarter of a circle) sweeping an angle alfa around sigma_1\n        const x = this.r * Math.cos(alpha)\n        const rad_circle = this.r * Math.sin(alpha)\n\n        for (let i = 1; i <= 180; ++i) {\n\n            let beta = Math.PI * i / 360\n\n            const y = rad_circle * Math.cos(beta)\n            const z = rad_circle * Math.sin(beta)\n\n            lineBuilder.addPoint(x, y, z)\n        }\n    }\n\n    else if (sigma === 'sigma_3') {\n        // Particular case 2: sigma_2 = sigma_1 (revolution stress tensor around sigma_3)\n        // Generate a circular segment (one quarter of a circle) sweeping an angle alfa around sigma_3\n        const y = this.r * Math.cos(alpha)\n        const rad_circle = this.r * Math.sin(alpha)\n\n        for (let i = 1; i <= 180; ++i) {\n\n            let beta = Math.PI * i / 360\n\n            const x = rad_circle * Math.cos(beta)\n            const z = rad_circle * Math.sin(beta)\n\n            lineBuilder.addPoint(x, y, z)\n        }\n    }\n\n    return lineBuilder.buffer\n}\n","import { Curve3D } from \"./Curve3D\"\nimport { GenericCurve, MohrPoint } from \"./types\"\nimport { mohrCircleLine } from \"./utils\"\n\nexport class EquipotentialCurve implements GenericCurve {\n    private r: number\n    private exp_cos: number\n    private exp_sin: number\n\n    constructor(private lambda: [number, number, number], radius = 1) {\n        this.r = radius\n        this.exp_sin = ( this.lambda[0] - this.lambda[2] ) / ( this.lambda[1] - this.lambda[0] )\n        this.exp_cos = ( this.lambda[2] - this.lambda[1] ) / ( this.lambda[1] - this.lambda[0] )\n    }\n\n    generate(theta: number, phi: number): string {\n        const lineBuilder = new Curve3D()\n\n        // NORMAL STRESS EQUIPOTENTIALS \n\n        // The principal stress values are defined according to the rock mechanics sign convention (positive values for compressive stresses)\n        const sigma_1 = - this.lambda[0]\n        const sigma_2 = - this.lambda[1]\n        const sigma_3 = - this.lambda[2]\n\n        // Center and radius of Mohr circle 3 - 1\n        const sigma_3_1_mean = ( sigma_1 + sigma_3 ) / 2\n        const rad_3_1 = ( sigma_1 - sigma_3 ) / 2\n        // Center and radius of Mohr circle 3 - 2\n        const sigma_3_2_mean = ( sigma_2 + sigma_3 ) / 2\n        const rad_3_2 = ( sigma_2 - sigma_3 ) / 2\n        // Center and radius of Mohr circle 2 - 1\n        const sigma_2_1_mean = ( sigma_1 + sigma_2 ) / 2\n        const rad_2_1 = ( sigma_1 - sigma_2 ) / 2\n    \n        // The integral lines derive from a scalar function defined by the normal stress component sigma_n\n        // sigma_n is calculated for a specific plane tangent to the sphere whose normal vector is defined by (phi_1, theta_1)\n        // sigma_n = (this.lambda[0] * cos(phi)**2 +this.lambda[1] * sin(phi)**2 ) * sin(theta)**2 + this.lambda[2] * ( 1 - sin(theta)**2 )\n        let sigma_n = (this.lambda[0] * Math.cos(phi)**2 +this.lambda[1] * Math.sin(phi)**2 ) * Math.sin(theta)**2 + this.lambda[2] * ( 1 - Math.sin(theta)**2 )\n\n        // Plot equipotential of the normal force that passes through the fixed point:\n        //      \n        // tau_n0 = shear stress for point pO located in the Mohr circle 3-1 at normal stress sigma_n\n        const tau_0 = Math.sqrt( rad_3_1**2 - (sigma_n - sigma_3_1_mean)**2 )\n        // alfa_n0 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-1 and the horizontal axis (sigma_3, sigma_1) :\n        const alfa_0 = Math.atan( tau_0 / (sigma_n - sigma_3) )\n\n        // if ( sigma_2 == sigma_3) {\n        //     // Particular Case 1: revolution stress tensor around sigma_1\n        //     // Equipotential curve is a circle sweeping at an angle alfa_n0 around sigma_1\n        //     arcCircle( 'sigma_1', alfa_n0 )\n        // }\n        // else if ( sigma_2 == sigma_1) {\n        //     // Particular Case 2: revolution stress tensor around sigma_3\n        //     // Equipotential curve is a circle sweeping at an angle PI/2 - alfa_n0 around sigma_3\n        //     arcCircle( 'sigma_3', Math.PI/2 - alfa_n0 )\n        // }\n\n        if ( sigma_n > sigma_3 && sigma_n < sigma_2 ) {\n            // Case 1: the equipotential line lies between circle 3 - 1 and circle 3 - 2:\n            // tau_1 = shear stress for point p1 located in the Mohr circle 3-2 at normal stress sigma_n\n             const tau_1 = Math.sqrt( rad_3_2**2 - (sigma_n - sigma_3_2_mean)**2 )\n             // alfa_1 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :\n             const alfa_1 = Math.atan( tau_1 / (sigma_n - sigma_3) )\n\n            // Plot curve corresponding to the line segment between points: (sigma_n, tau_0) and (sigma_n, tau_1)\n            const first = {\n                circle: '3_1',\n                p: [sigma_n, tau_0],\n                angle: alfa_0\n            } as MohrPoint\n\n            const second = {\n                circle: '3_2',\n                p: [sigma_n, tau_1],\n                angle: alfa_1\n            }  as MohrPoint\n\n            return mohrCircleLine( {r: this.r, first, second, sigma_1, sigma_2, sigma_3} )\n        }   \n        else if ( sigma_n > sigma_2 && sigma_n < sigma_1 ) {\n            // Case 2: the equipotential line lies between circle 3 - 1 and circle 2 - 1:\n            // tau_1 = shear stress for point pO located in the Mohr circle 3-1 at normal stress sigma_n\n             const tau_1 = Math.sqrt( rad_2_1**2 - (sigma_n - sigma_2_1_mean)**2 )\n             // alfa_1 = angle (in radians) between line segment (sigma_2,tau_n0) in circle 2-1 and the horizontal axis (sigma_2, sigma_1) :\n             const alfa_1 = Math.atan( tau_1 / (sigma_n - sigma_2) )\n\n            // Plot curve corresponding to the line segment between points: (sigma_n, tau_n0) and (sigma_n, tau_1)\n            const first = {\n                circle: '3_1',\n                p: [sigma_n, tau_0],\n                angle: alfa_0\n            } as MohrPoint\n\n            const second = {\n                circle: '2_1',\n                p: [sigma_n, tau_1],\n                angle: alfa_1\n            }  as MohrPoint\n\n            return mohrCircleLine( {r: this.r, first, second, sigma_1, sigma_2, sigma_3} )\n        }   \n        else if ( sigma_n == sigma_2 )  {\n            // Case 3: the equipotential line lies between circle 3 - 1 and sigma_2:\n            // tau_1 = shear stress for point pO\n             const tau_1 = 0\n             // alfa_1 = angle (in radians) between line segment (sigma_3,tau_n0) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :\n             const alfa_1 = 0\n\n            // Plot curve corresponding to the line segment between points: (sigma_n, tau_n0) and (sigma_n, tau_1)\n            const first = {\n                circle: '3_1',\n                p: [sigma_n, tau_0],\n                angle: alfa_0\n            } as MohrPoint\n\n            const second = {\n                circle: '3_2',\n                p: [sigma_n, tau_1],\n                angle: alfa_1\n            }  as MohrPoint\n\n            return mohrCircleLine( {r: this.r, first, second, sigma_1, sigma_2, sigma_3} )\n        }\n        \n        return ''\n    }\n}\n\n","import { Curve3D } from \"./Curve3D\"\nimport { GenericCurve, MohrPoint } from \"./types\"\nimport { deg2rad, mohrCircleLine } from \"./utils\"\n\nexport class MohrCoulombCurve implements GenericCurve {\n    private r: number\n\n    constructor(private lambda: [number, number, number], radius = 1) {\n        this.r = radius\n    }\n\n    /**\n     * Define a tangent plane by fixing angles phi and theta in spherical coordinates\n     * @param frictionAngle Friction angle in degrees\n     * @param cohesion In [0, 0.5]\n     */\n    generate(frictionAngle: number, cohesion: number): string {\n        const lineBuilder = new Curve3D()\n\n        const sigma_1 = - this.lambda[0]\n        const sigma_2 = - this.lambda[1]\n        const sigma_3 = - this.lambda[2]\n\n        // Center and radius of Mohr circle 3 - 1\n        const sigma_3_1_mean = ( sigma_1 + sigma_3 ) / 2\n        const rad_3_1 = ( sigma_1 - sigma_3 ) / 2\n        // Center and radius of Mohr circle 3 - 2\n        const sigma_3_2_mean = ( sigma_2 + sigma_3 ) / 2\n        const rad_3_2 = ( sigma_2 - sigma_3 ) / 2\n        // Center and radius of Mohr circle 2 - 1\n        const sigma_2_1_mean = ( sigma_1 + sigma_2 ) / 2\n        const rad_2_1 = ( sigma_1 - sigma_2 ) / 2\n\n        if (cohesion<0 || cohesion>0.5) {\n            throw new Error('Cohesion must be in [0, 0.5]')\n        }\n\n        const c = cohesion\n        const phi_a = deg2rad(frictionAngle)\n\n        // MOHR-COULOMB FRICTION\n\n        // The frictional strength law is defined by a Mohr-Coulomb line involving friction and cohesion:\n        // These two parameters must be fixed by the user in the menu within a predefined range\n        // The cohesion c is defined between [0,0.5] for a normalized stress tensor (sigma_1=1, sigma_2= R, sigma_3=0)\n \n        // The friction angle phi_a varies in the range [0, phi_3_1], \n        //      where phi_3_1 is the angle of the line tangent to Mohr circle between sigma_3 - sigma_1 that passes by c\n        //      tan(pi / 4 + phi_3_1 / 2) = sigma_1 / (2*c)\n\n        const phi_3_1 = 2 * ( Math.atan( sigma_1 / (2*c) ) - Math.PI/4 ) * 180 / Math.PI\n\n        // We calculate two other threshold angles for lines tangent to Mohr circles between sigma_3 - sigma_2, and sigma_2 - sigma_1\n\n        // Angle phi_3_2 for Mohr circle between sigma_2 - sigma_3 is calculated with a similar equation:\n\n        const phi_3_2 = 2 * ( Math.atan( sigma_2 / (2*c) ) - Math.PI/4 ) * 180 / Math.PI\n\n        // Angle phi_2_1 for Mohr circle between sigma_1 - sigma_2 is calculated from the general equation:\n        //      tan(pi / 4 + phi_2_1 / 2) = ( - c + sqrt( c^2 + sigma_2 * sigma_1 ) ) / sigma_2\n\n        const phi_2_1 = 2 * ( Math.atan( ( - c + Math.sqrt( c^2 + sigma_1 * sigma_2 ) ) / sigma_2 ) - Math.PI/4 ) * 180 / Math.PI\n\n        // Let (c, phi_a) be the cohesion and friction angle chosen by the user. The friction coefficient mu is the slope of the line\n\n        const mu = Math.tan( phi_a * Math.PI / 180 )\n\n        const sigma_3_1: number[] = [0, 0]\n        const tau_3_1  : number[] = [0, 0]\n        const alfa_3_1 : number[] = [0, 0]\n\n        const sigma_3_2: number[] = [0, 0]\n        const tau_3_2  : number[] = [0, 0]\n        const alfa_3_2 : number[] = [0, 0]\n\n        const sigma_2_1: number[] = [0, 0]\n        const tau_2_1  : number[] = [0, 0]\n        const alfa_2_1 : number[] = [0, 0]\n\n        const struct = {\n            sigma_3_1,\n            tau_3_1,\n            alfa_3_1,\n\n            sigma_3_2,\n            tau_3_2,\n            alfa_3_2,\n\n            sigma_2_1,\n            tau_2_1,\n            alfa_2_1,\n        }\n\n        // The Mohr-Coulomb line intersects the 3D Mohr circle in 1, 2 or 3 different line segments \n\n        // The line always intersects circle 1 - 3 in two points named: sigma_3_1[0], tau_3_1[0] and sigma_3_1[1], tau_3_1[1]\n        //      such that sigma_3_1[0] <= sigma_3_1[1]\n        // sigma_3_1 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:\n        const a_qe = 1 + mu**2\n        const b_qe = 2 * ( c * mu - sigma_3_1_mean )\n        const c_qe = c**2 + sigma_1 * sigma_3\n        \n        //  Calculate the discriminant of the quadratic equation:\n        let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )\n        //  Calculate intersection points\n        sigma_3_1[0] = ( - b_qe - delta ) / ( 2 * a_qe )\n        tau_3_1[0] = Math.sqrt( rad_3_1**2 - ( sigma_3_1[0] - sigma_3_1_mean )**2 )\n        sigma_3_1[1] = ( - b_qe + delta ) / ( 2 * a_qe )\n        tau_3_1[1] = Math.sqrt( rad_3_1**2 - ( sigma_3_1[1] - sigma_3_1_mean )**2 )\n\n        // Calculate the angle (in radians) between segment (sigma_3,tau_3_1) in circle 3-1 and the horizontal axis (sigma_3, sigma_1) :\n        // alfa_3_1 is the azimuthal angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n        alfa_3_1[0] = Math.atan( tau_3_1[0] / ( sigma_3_1[0] - sigma_3 ))\n        alfa_3_1[1] = Math.atan( tau_3_1[1] / ( sigma_3_1[1] - sigma_3 ))\n\n        // Define booleans indicating if the friction line intersects the smaller Mohr circles:\n        let circle_2_1 = false\n        let circle_3_2 = false\n\n        if ( phi_a < phi_3_2 ) {\n\n            let circle_2_1 = true\n\n            // The Mohr-Coulomb line intersects circle 2 - 3 in two points named: sigma_3_2[0], tau_3_2[0] and sigma_3_2[1], tau_3_2[1]\n            //      such that sigma_3_2[0] <= sigma_3_2[1]\n    \n            // sigma_3_2 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:\n            const a_qe = 1 + mu**2\n            const b_qe = 2 * ( c * mu - sigma_3_2_mean )\n            const c_qe = c**2 + sigma_2 * sigma_3\n            \n            //  Calculate the discriminant of the quadratic equation:\n            let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )\n            //  Calculate intersection points\n            sigma_3_2[0] = ( - b_qe - delta ) / ( 2 * a_qe )\n            tau_3_2[0] = Math.sqrt( rad_3_2**2 - ( sigma_3_2[0] - sigma_3_2_mean )**2 )\n            sigma_3_2[1] = ( - b_qe + delta ) / ( 2 * a_qe )\n            tau_3_2[1] = Math.sqrt( rad_3_2**2 - ( sigma_3_2[1] - sigma_3_2_mean )**2 )\n    \n            // Calculate the angle (in radians) between segment (sigma_3,tau_3_2) in circle 3-2 and the horizontal axis (sigma_3, sigma_2) :\n            // alfa_3_2 is the polar angle in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n            alfa_3_2[0] = Math.atan( tau_3_2[0] / ( sigma_3_2[0] - sigma_3 ))\n            alfa_3_2[1] = Math.atan( tau_3_2[1] / ( sigma_3_2[1] - sigma_3 ))\n\n        }\n\n        if ( phi_a < phi_2_1 ) {\n\n            circle_2_1 = true\n\n            // The Mohr-Coulomb line intersects circle 1 - 2 in two points named: sigma_2_1[0], tau_2_1[0] and sigma_2_1[1], tau_2_1[1]\n            //      such that sigma_2_1[0] <= sigma_2_1[1]\n    \n            // sigma_2_1 values are given by the roots of a quadratic equation a x^2 + b x + c = 0, with coeffcients a, b, anc c, as follows:\n            const a_qe = 1 + mu**2\n            const b_qe = 2 * ( c * mu - sigma_2_1_mean )\n            const c_qe = c**2 + sigma_1 * sigma_2\n            \n            //  Calculate the discriminant of the quadratic equation:\n            let delta = Math.sqrt( b_qe**2 - 4 * a_qe * c_qe )\n            //  Calculate intersection points\n            sigma_2_1[0] = ( - b_qe - delta ) / ( 2 * a_qe )\n            tau_2_1[0] = Math.sqrt( rad_2_1**2 - ( sigma_2_1[0] - sigma_2_1_mean )**2 )\n            sigma_2_1[1] = ( - b_qe + delta ) / ( 2 * a_qe )\n            tau_2_1[1] = Math.sqrt( rad_2_1**2 - ( sigma_2_1[1] - sigma_2_1_mean )**2 )\n    \n            // Calculate the angle (in radians) between segment (sigma_2,tau_2_1) in circle 2-1 and the horizontal axis (sigma_2, sigma_1) :\n            // alfa_2_1 is the latitude in the reference frame (x,y,z) = (sigma_1,sigma_3, sigma_2) = (East, North, Up)\n            alfa_2_1[0] = Math.atan( tau_2_1[0] / ( sigma_2_1[0] - sigma_2 ))\n            alfa_2_1[1] = Math.atan( tau_2_1[1] / ( sigma_2_1[1] - sigma_2 ))\n        }\n\n        // We calculate the corresponding curves in the sphere:\n\n        if ( !circle_2_1 && !circle_3_2 ) {\n            // Case 1: the Mohr-Coulomb line only intersects circle 3 - 1\n            // Plot curve corresponding to the line segment between points: \n            //      sigma_3_1[0], tau_3_1[0] and sigma_3_1[1], tau_3_1[1]\n            return mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(0, '3_1', struct), \n                second: this.getPoint(1, '3_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n            // return mohrCircleLine( {r: this.r, first, second, sigma_1, sigma_2, sigma_3} )\n        }   \n        else if ( !circle_2_1 && circle_3_2 )  {\n            // Case 2: the Mohr-Coulomb line intersects circle 3 - 1 and circle 3 - 2\n            // Plot curves corresponding to the line segment between points: \n            \n            //      sigma_3_1[0], tau_3_1[0] and sigma_3_2[0], tau_3_2[0];\n            let buffer = mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(0, '3_1', struct), \n                second: this.getPoint(0, '3_2', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n            buffer += '\\n'\n\n            //      sigma_3_2[1], tau_3_2[1] and sigma_3_1[1], tau_3_1[1];\n            buffer += mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(1, '3_2', struct), \n                second: this.getPoint(1, '3_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n\n            return buffer\n        }\n\n        else if ( circle_2_1 && !circle_3_2 ) {\n            // Case 3: the Mohr-Coulomb line intersects circle 3 - 1 and circle 2 - 1\n            // Plot curves corresponding to the line segment between points: \n\n            //      sigma_3_1[0], tau_3_1[0] and sigma_2_1[0], tau_2_1[0];\n            let buffer = mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(0, '3_1', struct), \n                second: this.getPoint(0, '2_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n            buffer += '\\n'\n\n            //      sigma_2_1[1], tau_2_1[1] and sigma_3_1[1], tau_3_1[1];\n            buffer += mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(1, '2_1', struct), \n                second: this.getPoint(1, '3_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n\n            return buffer\n        }\n\n        else {\n            // Case 4: the Mohr-Coulomb line intersects circle 3 - 1, circle 3 - 2, and circle 2 - 1\n            // Plot curves corresponding to the line segment between points: \n\n            //      sigma_3_1[0], tau_3_1[0] and sigma_3_2[0], tau_3_2[0];\n            let buffer = mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(0, '3_1', struct), \n                second: this.getPoint(0, '3_2', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n            buffer += '\\n'\n\n            //      sigma_3_2[1], tau_3_2[1] and sigma_2_1[0], tau_2_1[0];\n            buffer += mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(1, '3_2', struct), \n                second: this.getPoint(0, '2_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n            buffer += '\\n'\n\n            //      sigma_2_1[1], tau_2_1[1] and sigma_3_1[1], tau_3_1[1];\n            buffer += mohrCircleLine( {\n                r: this.r, \n                first : this.getPoint(1, '2_1', struct), \n                second: this.getPoint(1, '3_1', struct),\n                sigma_1, sigma_2, sigma_3\n            } )\n\n            return buffer\n        }\n    }\n\n    private getPoint(index: number, name: string, struct: any): MohrPoint {\n        if (name === '3_1') {\n            return {\n                circle: name,\n                p: [struct.sigma_3_1[index], struct.tau_3_1[index]],\n                angle: struct.alfa_3_1[index]\n            } as MohrPoint\n        }\n        else if (name === '3_2') {\n            return {\n                circle: name,\n                p: [struct.sigma_3_2[index], struct.tau_3_2[index]],\n                angle: struct.alfa_3_2[index]\n            } as MohrPoint\n        }\n        else if (name === '2_1') {\n            return {\n                circle: name,\n                p: [struct.sigma_2_1[index], struct.tau_2_1[index]],\n                angle: struct.alfa_2_1[index]\n            } as MohrPoint\n        }\n        else {\n            throw new Error(`name ${name} is unknown. Should be 3_1, 3_2 or 2_1`)\n        } \n        \n    }\n}\n"],"sourceRoot":""}