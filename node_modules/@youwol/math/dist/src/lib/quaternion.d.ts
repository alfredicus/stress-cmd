import { mat } from './matrix3';
import { vec } from './vectors';
export declare class Quaternion {
    private q;
    /**
     *
     * @param {Vector3} axis Axis of ratation
     * @param {number} angle Angle of rotation in radian
     */
    static fromAxisAngle(axis: vec.Vector3, angle: number): Quaternion;
    static fromProd(a: Quaternion, b: Quaternion): Quaternion;
    static fromBase(X: vec.Vector3, Y: vec.Vector3, Z: vec.Vector3): Quaternion;
    static fromRotationMatrix(r: mat.Matrix3): Quaternion;
    static fromTo(from: vec.Vector3, to: vec.Vector3): Quaternion;
    get data(): number[];
    get axis(): vec.Vector3;
    get angle(): number;
    equals(q: Quaternion): boolean;
    notEquals(q: Quaternion): boolean;
    prod(q: Quaternion): this;
    inverse(): Quaternion;
    invert(): this;
    negate(): this;
    normalize(): number;
    dot(A: Quaternion, B: Quaternion): number;
    /**
     * Rorate inverse a vector
     * @param {Vec3} V The vector to inverse rotate
     * @returns {Vec3} The rotated vector
     */
    iRotate(v: vec.Vector3): vec.Vector3;
    /**
     * Rotate a vector
     * @param {Vec3} v The vector to rotate
     * @returns {Vec3} The rotated vector
     */
    rotate(v: vec.Vector3): number[];
    /**
     * @return [xx,xy,xz,yy,yz,zz] the rotation matrix (symm) (?? should be antisym)
     */
    toMatrix(): mat.Matrix3;
    setFrom(q: Quaternion): this;
    /**
     *
     * @param {Vec3} v The axis of rotation
     * @param {Number} angle
     */
    setAxisAngle(v: vec.Vector3, angle: number): this;
    setFromTo(from: vec.Vector3, to: vec.Vector3): this;
    /**
     *
     * @param {Mat3} r The roration matrix
     */
    setFromRotationMatrix(m: mat.Matrix3): this;
    setFromBase(X: vec.Vector3, Y: vec.Vector3, Z: vec.Vector3): this;
}
