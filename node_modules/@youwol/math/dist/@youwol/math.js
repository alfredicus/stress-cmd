!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r(require("@youwol/dataframe")):"function"==typeof define&&define.amd?define("@youwol/math",["@youwol/dataframe"],r):"object"==typeof exports?exports["@youwol/math"]=r(require("@youwol/dataframe")):e["@youwol/math"]=r(e["@youwol/dataframe"])}("undefined"!=typeof self?self:this,(e=>(()=>{"use strict";var r={595:r=>{r.exports=e}},t={};function i(e){var n=t[e];if(void 0!==n)return n.exports;var o=t[e]={exports:{}};return r[e](o,o.exports,i),o.exports}i.d=(e,r)=>{for(var t in r)i.o(r,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},i.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{AreaDecomposer:()=>xe,ComponentDecomposer:()=>ae,Eigen:()=>Me,EigenValuesDecomposer:()=>ye,EigenVectorsDecomposer:()=>we,Fringes:()=>Ee,IQR:()=>W,InterpolateDirection:()=>Ze,MinMax:()=>We,NormalsDecomposer:()=>pe,PositionDecomposer:()=>de,Quaternion:()=>rr,ValenceDecomposer:()=>Se,VectorNormDecomposer:()=>ze,abs:()=>w,add:()=>t,addNumber:()=>o,areas:()=>j,barycenters:()=>L,barycentric2:()=>_e,barycentric3:()=>Fe,barycentric4:()=>Pe,biLerp:()=>Le,bins:()=>se,closeTo:()=>F,covariance:()=>Q,cross:()=>p,dectectNan:()=>Ye,describe:()=>oe,determinant:()=>O,div:()=>m,dot:()=>z,eigen:()=>Ie,eigenValue:()=>e,eigenVector:()=>r,equals:()=>_,flatten:()=>ke,getNaN:()=>P,getRotationAxis:()=>ir,inv:()=>$,inverseCDF:()=>fr,invert:()=>g,isOutliers:()=>re,lerp:()=>je,mat:()=>nr,max:()=>V,maxArray:()=>De,mean:()=>B,meshInterpolate:()=>Je,min:()=>T,minArray:()=>Ce,minMax:()=>N,minMaxArray:()=>Re,movingAverage:()=>cr,mult:()=>a,multMat:()=>c,negate:()=>E,norm:()=>h,norm2:()=>l,normalize:()=>S,normalizeArray:()=>Ge,normals:()=>k,notOutliers:()=>te,outliers:()=>ee,q25:()=>H,q50:()=>J,q75:()=>K,quantile:()=>Z,rand:()=>I,randomMT:()=>or,rotate:()=>C,rotateAxis:()=>tr,round:()=>M,scale:()=>R,scaleArray:()=>Oe,shuffle:()=>G,square:()=>y,std:()=>ne,sub:()=>s,sum:()=>q,switchConvention:()=>Y,tagNaN:()=>A,tetraLerp:()=>Ue,trace:()=>f,translate:()=>D,transpose:()=>d,triLerp:()=>Be,triangleLerp2D:()=>Qe,triangleLerp3D:()=>Xe,trunc:()=>b,unitInterval:()=>x,variance:()=>X,vec:()=>He,weightedMean:()=>U,weightedSum:()=>v});const e=e=>{if(void 0===e)throw new Error("series is undefined");const r=e.dimension;if((2!==e.dimension||3!==e.itemSize&&4!==e.itemSize)&&(3!==e.dimension||6!==e.itemSize&&9!==e.itemSize))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${e.itemSize}`);const t=e.image(e.count,r),i=e.count;let n=0;for(let o=0;o<i;++o){const i=Ie(e.itemAt(o));for(let e=0;e<r;++e)t.array[n++]=i.values[e]}return t},r=e=>{if(void 0===e)throw new Error("series is undefined");const r=e.dimension;if((2!==e.dimension||3!==e.itemSize&&4!==e.itemSize)&&(3!==e.dimension||6!==e.itemSize&&9!==e.itemSize))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${e.itemSize}`);const t=e.image(e.count,r**2),i=e.count;let n=0;for(let r=0;r<i;++r)Ie(e.itemAt(r)).vectors.forEach((e=>t.array[n++]=e));return t},t=e=>{if(e.length<=1)throw new Error("nb series should be greater than 1");const r=e[0].clone(!0);return e.forEach((e=>{if(e.length!==r.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${e.length} != ${r.length})`);e.array.forEach(((e,t)=>r.array[t]+=e))})),r},o=(e,r)=>{const t=e.clone(!1);return 0===r||t.array.forEach(((e,i)=>t.array[i]+=r)),t},s=(e,...r)=>{if(void 0===e)throw new Error("serie s is undefined");if(!r)throw new Error("cannot subtract undefined to s");const t=e.clone();return r&&r.forEach((r=>{if("number"==typeof r)t.array.forEach(((e,i)=>t.array[i]-=r));else{if(r.length!==e.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${r.length} != ${e.length})`);r.array.forEach(((e,r)=>t.array[r]-=e))}})),t},a=(e,...r)=>{if(void 0===e)return;if(!r)throw new Error("cannot multiply undefined to s");const t=e.clone();return r.forEach((r=>{if("number"==typeof r)t.array.forEach(((e,i)=>t.array[i]*=r));else{if(r.length!==e.length)throw new Error(`size mistmatch. Cannot multiply 2 Series of different sizes (${r.length} != ${e.length})`);r.array.forEach(((e,r)=>t.array[r]*=e))}})),t};var u=i(595);const c=(e,r)=>{if(void 0===e)throw new Error("s1 is undefined");if(void 0===r)throw new Error("s2 is undefined");if("number"==typeof r)return a(e,r);if(1===r.itemSize)return e.map(((e,t)=>e*r.itemAt(t)));if(1===e.itemSize){if(1!==r.itemSize)throw new Error("s2 should have itemSize=1 (same as s1)");return e.map(((e,t)=>e*r.itemAt(t)))}if(3===e.itemSize){if(3===r.itemSize)return e.map(((e,t)=>{const i=r.itemAt(t);return e[0]*i[0]+e[1]*i[1]+e[2]*i[2]}));throw new Error("since s1 has itemSize=3, s2 should have itemSize=1 or 3")}if(6===e.itemSize||9===e.itemSize){if(3===r.itemSize)return e.map(((t,i)=>{const n=6===e.itemSize?(0,u.symSquaredMatrix)(t):(0,u.squaredMatrix)(t),o=new u.Vector(r.itemAt(i));return n.multVec(o).array}));if(6===r.itemSize||9===r.itemSize)return e.map(((t,i)=>{const n=6===e.itemSize?(0,u.symSquaredMatrix)(t):(0,u.squaredMatrix)(t),o=6===r.itemSize?(0,u.symSquaredMatrix)(r.itemAt(i)):(0,u.squaredMatrix)(r.itemAt(i));return n.multMat(o).array}))}throw new Error("Cannot multMat")},m=(e,...r)=>{if(void 0===e)return;if(!r)throw new Error("cannot divide undefined to s");const t=e.clone();return r&&r.forEach((r=>{if("number"==typeof r)t.array.forEach(((e,i)=>t.array[i]/=r));else{if(r.length!==e.length)throw new Error(`size mistmatch. Cannot divide 2 Series of different sizes (${r.length} != ${e.length})`);r.array.forEach(((e,r)=>t.array[r]/=e))}})),t};function f(e){if(void 0===e)throw new Error("series is undefined");if(1!==e.itemSize&&3!==e.itemSize&&4!==e.itemSize&&6!==e.itemSize&&9!==e.itemSize)throw new Error("item size should be 1, 3, 4, 6 or 9");if(1===e.itemSize)return e.clone();const r=e.itemSize,t=e.image(e.count,1);for(let i=0;i<e.count;++i){const n=e.itemAt(i);t.array[i]=3===r?n[0]+n[2]:4===r?n[0]+n[3]:6===r?n[0]+n[3]+n[5]:n[0]+n[4]+n[8]}return t}const h=e=>l(e).map((e=>Math.sqrt(e))),l=e=>{if(void 0===e)throw new Error("series is undefined");const r=e.image(e.count,1);if(1===e.itemSize)return r;for(let t=0;t<e.count;++t){const i=e.itemAt(t);r.array[t]=i.reduce(((e,r)=>e+r**2),0)}return r},d=e=>{if(void 0===e)return;if(9!==e.itemSize)throw new Error("items size should be 9 only (for now)");const r=e.clone(),t=r.array;let i=0;return e.forEach((e=>{t[i++]=e[0],t[i++]=e[3],t[i++]=e[6],t[i++]=e[1],t[i++]=e[4],t[i++]=e[7],t[i++]=e[2],t[i++]=e[5],t[i++]=e[8]})),r},y=e=>{if(void 0===e)throw new Error("series is undefined");return u.Serie.create({array:e.array.map((e=>e**2)),itemSize:e.itemSize,dimension:e.dimension})},w=e=>{if(void 0===e)throw new Error("series is undefined");return u.Serie.create({array:e.array.map((e=>Math.abs(e))),itemSize:e.itemSize,dimension:e.dimension})},z=(e,r)=>{if(void 0===e)throw new Error("serie a is undefined");if(void 0===r)throw new Error("serie or Vector b is undefined");return!0===u.Serie.isSerie(r)?(0,u.map)([e,r],(([e,r])=>(0,u.vector)(e).dot((0,u.vector)(r)))):(0,u.map)(e,(e=>(0,u.vector)(e).dot((0,u.vector)(r))))},p=(e,r)=>{if(void 0===e)throw new Error("serie A is undefined");if(void 0===r)throw new Error("serie B is undefined");if(3!==e.itemSize)throw new Error("cross only supports itemSize=3");if(3!==r.itemSize)throw new Error("cross only supports itemSize=3");return e.map(((e,t)=>{const i=r.itemAt(t);return[e[1]*i[2]-e[2]*i[1],e[2]*i[0]-e[0]*i[2],e[0]*i[1]-e[1]*i[0]]}))},S=e=>{if(void 0===e)throw new Error("series is undefined");if(1===e.itemSize){const r=u.array.minMax(e.array),t=r[0],i=1/(r[1]-t);return e.map((e=>i*(e-t)))}return e.map((e=>{const r=1/Math.sqrt(e.reduce(((e,r)=>e+r*r),0));return e.map((e=>e*r))}))},x=e=>{if(void 0===e)throw new Error("series is undefined");if(1===e.itemSize){const r=u.array.minMax(e.array),t=r[0],i=1/(r[1]-t);return e.map((e=>i*(e-t)))}return e.map((e=>{const r=u.array.minMax(e),t=r[0],i=1/(r[1]-t);return e.map((e=>i*(e-t)))}))},E=e=>{if(void 0===e)throw new Error("series is undefined");return u.Serie.create({array:e.array.map((e=>-e)),itemSize:e.itemSize,dimension:e.dimension})},g=e=>{if(void 0===e)throw new Error("series is undefined");return u.Serie.create({array:e.array.map((e=>1/e)),itemSize:e.itemSize,dimension:e.dimension})},v=(e,r)=>{if(r.length!==e.length)throw new Error(`data length (${e.length}) should be equal to alpha length (${r.length})`);return t(e.map(((e,t)=>a(e,r[t]))))},q=e=>{if(1===e.itemSize){let r=0;return e.forEach((e=>r+=e)),r}const r=new Array(e.itemSize).fill(0);return e.forEach((e=>e.forEach(((e,t)=>r[t]+=e)))),r},A=(e,r)=>1===e.itemSize?e.map(((t,i)=>r(t,i,e)?Number.NaN:t)):e.map(((t,i)=>r(t,i,e)?new Array(e.itemSize).fill(Number.NaN):t)),I=(e,r=0,t=1)=>{const i=t-r;return 1===e.itemSize?e.map((()=>r+i*Math.random())):e.map((()=>new Array(e.itemSize).fill(0).map((()=>r+i*Math.random()))))},M=e=>1===e.itemSize?e.map((e=>Math.round(e))):e.map((e=>e.map((e=>Math.round(e))))),b=e=>1===e.itemSize?e.map((e=>Math.trunc(e))):e.map((e=>e.map((e=>Math.trunc(e))))),N=e=>{if(void 0===e)throw new Error("series is undefined");if(1===e.itemSize)return u.array.minMax(e.array);const r=new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),t=new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY);return e.forEach((e=>{e.forEach(((e,i)=>{e<r[i]&&(r[i]=e),e>t[i]&&(t[i]=e)}))})),[...r,...t]},T=e=>{if(void 0===e)throw new Error("series is undefined");if(1===e.itemSize)return u.array.min(e.array);const r=new Array(e.itemSize).fill(Number.POSITIVE_INFINITY);return e.forEach((e=>{e.forEach(((e,t)=>{e<r[t]&&(r[t]=e)}))})),r},V=e=>{if(void 0===e)throw new Error("series is undefined");if(1===e.itemSize)return u.array.max(e.array);const r=new Array(e.itemSize).fill(Number.POSITIVE_INFINITY);return e.forEach((e=>{e.forEach(((e,t)=>{e>r[t]&&(r[t]=e)}))})),r},_=(e,r)=>{if(void 0===e)throw new Error("serie s1 is undefined");if(void 0===r)throw new Error("serie s2 is undefined");return e.itemSize===r.itemSize&&e.count===r.count&&(0,u.reduce)([e,r],((e,[r,t])=>e&&r===t),!0)},F=(e,r,t=1e-7)=>{if(void 0===e)throw new Error("serie s1 is undefined");if(void 0===r)throw new Error("serie s2 is undefined");return e.itemSize===r.itemSize&&e.count===r.count&&(0,u.reduce)([e,r],((e,[r,i])=>e&&Math.abs(r-i)<t),!0)},P=e=>{const r=[];if(1===e.itemSize)e.forEach(((e,t)=>{Number.isNaN(e)&&r.push(t)}));else{const t=e.itemSize;e.forEach(((e,i)=>{for(let n=0;n<t;++n)if(Number.isNaN(e[n])){r.push(i);break}}))}return r},$=(e,r=!1)=>{if(void 0===e)throw new Error("series is undefined");const t=e.itemSize;if(2!==e.dimension||3!==t&&4!==t){if(3!==e.dimension||6!==t&&9!==t)throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${t}`);return 9===t?e.map(((e,t)=>{const i=e[0]*(e[4]*e[8]-e[7]*e[5])-e[1]*(e[3]*e[8]-e[5]*e[6])+e[2]*(e[3]*e[7]-e[4]*e[6]);if(0===i){const e=`matrix at index${t} has a determinant = 0`;if(!0===r)throw new Error(e);return console.warn(e),[0,0,0,0,0,0,0,0,0]}const n=1/i,o=[];return o[0]=(e[4]*e[8]-e[7]*e[5])*n,o[1]=(e[2]*e[7]-e[1]*e[8])*n,o[2]=(e[1]*e[5]-e[2]*e[4])*n,o[3]=(e[5]*e[6]-e[3]*e[8])*n,o[4]=(e[0]*e[8]-e[2]*e[6])*n,o[5]=(e[3]*e[2]-e[0]*e[5])*n,o[6]=(e[3]*e[7]-e[6]*e[4])*n,o[7]=(e[6]*e[1]-e[0]*e[7])*n,o[8]=(e[0]*e[4]-e[3]*e[1])*n,o})):e.map(((e,t)=>{const i=e[0],n=e[1],o=e[2],s=n,a=e[3],u=e[4],c=o,m=u,f=e[5],h=f*a-m*u,l=m*o-f*n,d=u*n-a*o,y=i*h+s*l+c*d;if(0===y){const e=`matrix at index${t} has a determinant = 0`;if(!0===r)throw new Error(e);return console.warn(e),[0,0,0,0,0,0]}const w=1/y;return[h*w,l*w,d*w,(f*i-c*o)*w,(c*n-m*i)*w,(a*i-s*n)*w]}))}return e.map(((e,i)=>{const n=[0,0,0,0];4===t?(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3]):(n[0]=e[0],n[1]=e[1],n[2]=e[1],n[3]=e[2]);const o=n[0]*n[3]-n[1]*n[2];if(0===o){const e=`matrix at index${i} has a determinant = 0`;if(!0===r)throw new Error(e);return console.warn(e),3===t?[0,0,0]:[0,0,0,0]}const s=1/o;return 3===t?[n[3]*s,-n[1]*s,n[0]*s]:[n[3]*s,-n[1]*s,-n[2]*s,n[0]*s]}))},C=(e,r,t=!1)=>{if(void 0===e)throw new Error("s is undefined");if(void 0===r)throw new Error("rot is undefined");if(t){if(Array.isArray(r)){if(1===e.itemSize)return e.clone();if(3===e.itemSize){const t=nr.transpose(r);return e.map((e=>nr.multVec(t,e)))}return 9===e.itemSize?e.map((e=>nr.rotateInverse(nr.unpack(e),r))):e.map((e=>nr.pack(nr.rotateInverse(nr.unpack(e),r),!0)))}if(9!==r.itemSize)throw new Error("rot should have itemSize=9");return 1===e.itemSize?e.clone():3===e.itemSize?c(d(r),e):c(d(r),c(e,r))}if(Array.isArray(r))return 1===e.itemSize?e.clone():3===e.itemSize?e.map((e=>nr.multVec(r,e))):9===e.itemSize?e.map((e=>nr.rotateForward(nr.unpack(e),r))):e.map((e=>nr.pack(nr.rotateForward(nr.unpack(e),r),!0)));if(9!==r.itemSize)throw new Error("rot should have itemSize=9");return 1===e.itemSize?e.clone():3===e.itemSize?c(r,e):c(r,c(e,d(r)))},D=(e,r)=>{if(void 0===e)throw new Error("s is undefined");if(void 0===r)throw new Error("t is undefined");if(r.length!==e.itemSize)throw new Error(`t should be of length ${e.itemSize} (same as serie itemSize)`);return 1===e.itemSize?e.map((e=>e*r[0])):e.map((e=>e.map(((e,t)=>e+r[t]))))},R=(e,r)=>{if(void 0===e)throw new Error("s is undefined");if(void 0===r)throw new Error("t is undefined");if(Array.isArray(r)){if(1===e.itemSize)return e.map((e=>e*r[0]));if(r.length!==e.itemSize)throw new Error(`t should be of length ${e.itemSize} (same as serie itemSize)`);return e.map((e=>e.map(((e,t)=>e*r[t]))))}return 1===e.itemSize?e.map((e=>e*r)):e.map((e=>e.map((e=>e*r))))};function G(e){const r=[];e.forEach((e=>r.push(e)));let t,i=r.length;for(;0!=i;)t=Math.floor(Math.random()*i),i--,[r[i],r[t]]=[r[t],r[i]];return u.Serie.create({array:u.array.flatten(r),itemSize:e.itemSize,dimension:e.dimension})}function O(e){if(void 0===e)throw new Error("series is undefined");if(3!==e.itemSize&&4!==e.itemSize||2!==e.dimension){if(6!==e.itemSize&&9!==e.itemSize||3!==e.dimension)throw new Error("item size should be 3, 4, 6 or 9");{const r=e=>6===e.length?(0,u.symSquaredMatrix)(e):(0,u.squaredMatrix)(e);return e.map((e=>{const t=r(e);return t.at(0,0)*t.at(1,1)*t.at(2,2)-t.at(0,0)*t.at(1,2)*t.at(2,1)-t.at(0,1)*t.at(1,0)*t.at(2,2)+t.at(0,1)*t.at(1,2)*t.at(2,0)+t.at(0,2)*t.at(1,0)*t.at(2,1)-t.at(0,2)*t.at(1,1)*t.at(2,0)}))}}{const r=e=>3===e.length?(0,u.symSquaredMatrix)(e):(0,u.squaredMatrix)(e);return e.map((e=>{const t=r(e);return t.at(0,0)*t.at(1,1)-t.at(0,1)*t.at(1,0)}))}}const Y=e=>{if(void 0===e)throw new Error("series is undefined");if(6!==e.itemSize&&3!==e.itemSize)throw new Error("Series does not have itemSize = 3 or 6 (symmetric tensor [xx,xy,yy] or [xx,xy,xz,yy,yz,zz])");return e.map((e=>e.map((e=>-e))))};function k(e,r){if(!e||!r)return;const t=new Array(r.count).fill(0);let i=0;return r.forEach((r=>{const n=e.itemAt(r[0]),o=e.itemAt(r[1]),s=e.itemAt(r[2]),a=He.cross(He.create(n,o),He.create(n,s));t[i++]=a[0],t[i++]=a[1],t[i++]=a[2]})),u.Serie.create({array:(0,u.createTyped)(Float32Array,t,!0),itemSize:3})}const j=(e,r)=>{if(!e||!r)return;const t=k(e,r);return void 0===t?void 0:m(h(t),2)};function L(e,r){if(!e||!r)return;const t=new Array(r.count).fill(0);let i=0;return r.forEach((r=>{const n=e.itemAt(r[0]),o=e.itemAt(r[1]),s=e.itemAt(r[2]);t[i++]=(n[0]+o[0]+s[0])/3,t[i++]=(n[1]+o[1]+s[1])/3,t[i++]=(n[2]+o[2]+s[2])/3})),u.Serie.create({array:(0,u.createTyped)(Float32Array,t,!0),itemSize:3})}const B=e=>{if(void 0===e)throw new Error("series is undefined");const r=e.itemSize;if(1===r)return e.array.reduce(((e,r)=>e+r),0)/e.length;const t=new Array(r).fill(0);return e.forEach((i=>{for(let n=0;n<r;++n)t[n]+=i[n]/e.count})),t},Q=(e,r)=>{if(e.length!==r.length)throw new Error("x and y must have the same length");if(1!==e.itemSize)throw new Error("x must have itemSize = 1");if(1!==r.itemSize)throw new Error("y must have itemSize = 1");const t=e.length,i=B(e),n=B(r);return a(s(e,i),s(r,n)).array.reduce(((e,r)=>e+r/t),0)},X=e=>Q(e,e),U=(e,r)=>{if(void 0===e)throw new Error("s is undefined");if(void 0===r)throw new Error("w is undefined");if(r.count!==e.count)throw new Error(`count mismatch for s (${e.count}) and w (${r.count})`);if(1!==r.itemSize)throw new Error(`itemSize for w should be 1 (got ${r.itemSize})`);const t=r.array.reduce(((e,r)=>e+r),0),i=e.itemSize;if(1===i)return e.array.reduce(((e,t,i)=>e+t*r.array[i]),0)/t;const n=new Array(i).fill(0);return e.forEach(((e,t)=>{for(let o=0;o<i;++o)n[o]+=r.array[t]*e[o]})),n.map((e=>e/t))},Z=(e,r)=>{if(void 0===e)throw new Error("series is undefined");if(1!==e.itemSize)throw new Error("quantile algorithm: itemSize must be 1");if(r<0)throw new Error("quantile must be >= 0");if(r>1)throw new Error("quantile must be <= 1");const t=(0,u.sort)(e).array,i=(t.length-1)*r,n=Math.floor(i),o=i-n;return void 0!==t[n+1]?t[n]+o*(t[n+1]-t[n]):t[n]},H=e=>Z(e,.25),J=e=>Z(e,.5),K=e=>Z(e,.75),W=e=>Z(e,.75)-Z(e,.25),ee=(e,r)=>{const t=ie(e,r);return(0,u.cut)(e,(e=>e<t.min||e>t.max))},re=(e,r)=>{const t=ie(e,r);return(0,u.check)(e,(e=>e<t.min||e>t.max))},te=(e,r=1.5)=>{const t=ie(e,r);return(0,u.cut)(e,(e=>e>=t.min&&e<=t.max))},ie=(e,r)=>{const t=H(e),i=K(e),n=i-t;return{min:t-r*n,max:i+r*n}},ne=e=>{if(void 0===e)throw new Error("series is undefined");if(1!==e.itemSize)throw new Error("quantile algorithm: itemSize must be 1");const r=B(e),t=e.map((e=>(e-r)**2));return Math.sqrt(q(t)/(e.length-1))},oe=e=>{if(void 0===e)throw new Error("serie is undefined");if(1!==e.itemSize)throw new Error("serie must have itemSize = 1");return{count:e.count,mean:B(e),std:ne(e),min:T(e),q25:H(e),q50:J(e),q75:K(e),max:V(e)}};function se(e,{size:r,nb:t,start:i,stop:n}){if(1!==e.itemSize)throw new Error("itemSize should be 1");if(void 0===r&&void 0===t)throw new Error("size or nb must be provided");const o=N(e);void 0===i&&(i=o[0]),void 0===n&&(n=o[1]),void 0!==t?r=(n-i)/t:t=Math.trunc(n-i)/r;const s=new Array(t).fill(0);return e.forEach((e=>{let n=Math.trunc((e-i)/r);if(n>=t&&(n=t-1),n<0||n>=t)throw new Error(`index for bin (${n}) out of bounds (0, ${t})`);s[n]++})),u.Serie.create({array:s,itemSize:1})}class ae{names(e,r,t,i){if("positions"===i||"indices"===i)return[];const n=(0,u.nameOfSerie)(e,t);if(i===n&&1===t.itemSize)return[];if(r>1)return[];if(2===t.dimension)switch(t.itemSize){case 2:return ue.map((e=>i+e));case 3:return ce.map((e=>i+e));case 4:return me.map((e=>i+e))}else switch(t.itemSize){case 3:return fe.map((e=>i+e));case 6:return he.map((e=>i+e));case 9:return le.map((e=>i+e))}const o=[];for(let e=0;e<r;++e)o.push(i+e);return o}serie(e,r,t){if(r>1)return;let i=t.substring(0,t.length-1),n=e.series[i];if(n)if(2===n.dimension){for(let e=0;e<ue.length;++e)if(t===i+ue[e])return(0,u.apply)(n,(r=>r[e]))}else for(let e=0;e<fe.length;++e)if(t===i+fe[e])return(0,u.apply)(n,(r=>r[e]));if(i=t.substring(0,t.length-2),n=e.series[i],n)if(2===n.dimension){for(let e=0;e<ce.length;++e)if(t===i+ce[e])return(0,u.apply)(n,(r=>r[e]));for(let e=0;e<me.length;++e)if(t===i+me[e])return(0,u.apply)(n,(r=>r[e]))}else{for(let e=0;e<he.length;++e)if(t===i+he[e])return(0,u.apply)(n,(r=>r[e]));for(let e=0;e<le.length;++e)if(t===i+le[e])return(0,u.apply)(n,(r=>r[e]))}if(i=t.substring(0,t.length-1),n=e.series[i],n)for(let e=0;e<r;++e)if(t===i+e)return(0,u.apply)(n,(r=>r[e]))}}const ue=["x","y"],ce=["xx","xy","yy"],me=["xx","xy","yx","yy"],fe=["x","y","z"],he=["xx","xy","xz","yy","yz","zz"],le=["xx","xy","xz","yx","yy","yz","zx","zy","zz"];class de{constructor(e=["x","y","z"]){if(this.names_=e,3!==e.length)throw new Error("names must be an array of 3 strings (the dimension)")}names(e,r,t,i){return 1!==r||"positions"!==i?[]:this.names_}serie(e,r,t){if(1===r){const r=e.series.positions;switch(t){case this.names_[0]:return(0,u.apply)(r,(e=>e[0]));case this.names_[1]:return(0,u.apply)(r,(e=>e[1]));case this.names_[2]:return(0,u.apply)(r,(e=>e[2]))}}}}class ye{names(e,r,t,i){return"positions"===i||"indices"===i?[]:(2!==t.dimension||3===t.itemSize&&1===r)&&(3!==t.dimension||6===t.itemSize&&1===r)?2===t.dimension?[i+"1",i+"2"]:[i+"1",i+"2",i+"3"]:[]}serie(r,t,i){if(1!==t)return;const n=i.substring(0,i.length-1),o=r.series[n],s=parseInt(i.charAt(i.length-1));if(void 0!==o){if(2===o.dimension){if(3!==o.itemSize)return;if(s<1||s>2)return}else{if(6!==o.itemSize)return;if(s<1||s>3)return}return(0,u.apply)(e(o),(e=>e[s-1]))}}}class we{names(e,r,t,i){return"positions"===i||"indices"===i?[]:2===t.dimension?3!==t.itemSize||2!==r?[]:[i+"1",i+"2"]:6!==t.itemSize||3!==r?[]:[i+"1",i+"2",i+"3"]}serie(e,t,i){const n=i.substring(0,i.length-1);let o=parseInt(i.charAt(i.length-1));const s=e.series[n];if(void 0!==s){if(2===s.dimension){if(2!==t)return;if(void 0===s)return;if(3!==s.itemSize)return;if(o<1||o>2)return;return o-=1,(0,u.apply)(r(s),(e=>[e[2*o],e[2*o+1]]))}if(3===t&&void 0!==s&&6===s.itemSize&&!(o<1||o>3))return o-=1,(0,u.apply)(r(s),(e=>[e[3*o],e[3*o+1],e[3*o+2]]))}}}class ze{names(e,r,t,i){return"positions"===i||"indices"===i||t.itemSize<=1||1!==r?[]:2===t.dimension&&2===t.itemSize||3===t.dimension&&3===t.itemSize?[i]:[]}serie(e,r,t){if(1!==r)return;if("positions"===t||"indices"===t)return;const i=e.series[t];return void 0===i||i.itemSize<=1?void 0:2===i.dimension&&2===i.itemSize||3===i.dimension&&3===i.itemSize?h(i):void 0}}class pe{constructor(e="normals"){this.name=e}names(e,r,t,i){return 3!==r?[]:(0,u.exists)(e,"positions")||(0,u.exists)(e,"indices")?[this.name]:[]}serie(e,r,t){if(t!==this.name)return;const i=e.series.positions,n=e.series.indices;if(!i||!n)return;const o=new Array(n.count).fill(0);let s=0;return n.forEach((e=>{const r=i.itemAt(e[0]),t=i.itemAt(e[1]),n=i.itemAt(e[2]),a=He.cross(He.create(r,t),He.create(r,n));o[s++]=a[0],o[s++]=a[1],o[s++]=a[2]})),u.Serie.create({array:(0,u.createTyped)(Float32Array,o,!0),itemSize:3})}}class Se{constructor(e="valence"){this.name=e}names(e,r,t,i){return 1!==r?[]:(0,u.exists)(e,"positions")||(0,u.exists)(e,"indices")?[this.name]:[]}serie(e,r,t){if(t!==this.name)return;const i=e.series.positions,n=e.series.indices;if(!i||!n)return;const o=new Array(i.count).fill(0);return n.forEach((e=>{o[e[0]]++,o[e[1]]++,o[e[2]]++})),u.Serie.create({array:(0,u.createTyped)(Int8Array,o,!0),itemSize:1})}}class xe{constructor(e="area"){this.name=e}names(e,r,t,i){return 1!==r?[]:(0,u.exists)(e,"positions")||(0,u.exists)(e,"indices")?[this.name]:[]}serie(e,r,t){if(t!==this.name)return;const i=(new pe).serie(e,r,"normals");return i?m(h(i),2):void 0}}class Ee{constructor(e,r){this.name=e,this.fringes=r}names(e,r,t,i){return 1!==r?[]:[this.name]}serie(e,r,t){if(t!==this.name)return;const i=e.series[this.name];return i?(0,u.apply)(i,(e=>{return Math.abs(this.fringes*((r=e/this.fringes)-Math.floor(r)));var r})):void 0}}const ge=1e-5,ve=100,qe=Math.cos(Math.PI/4),Ae=Math.sin(Math.PI/4);function Ie(e){const r=[],t=[],i=[],n=[],o=[];let s=0,a=0,u=0,c=0,m=0,f=0,h=0,l=0,d=0,y=0,w=0,z=0,p=0,S=0,x=0,E=0,g=0;if(3===e.length)g=2,i[0]=e[0],i[1]=e[1],i[2]=e[2];else if(4===e.length)g=2,i[0]=e[0],i[1]=e[1],i[2]=e[3];else if(6===e.length)g=3,i[0]=e[0],i[1]=e[1],i[2]=e[3],i[3]=e[2],i[4]=e[4],i[5]=e[5];else{if(9!==e.length)throw new Error(`matrix-array should be of size 2 (xx,xy,yy),\n        4 (xx,xy,yx,yy), 6 (xx,xy,xz,yy,yz,zz) or 9 (xx,xy,xz,yx,yy,yz,zx,zy,zz).\n        Got ${e.length}`);g=3,i[0]=e[0],i[1]=e[1],i[2]=e[4],i[3]=e[2],i[4]=e[5],i[5]=e[8]}const v=g*(g+1)/2;let q=0;for(let e=0;e<g;++e)for(let r=0;r<g;++r)n[q++]=e===r?1:0;q=1;let A=0;for(let e=1;e<=g;++e)for(let r=1;r<=e;++r)e!==r&&(d=i[q-1],A+=d*d),++q;if(0!==A){const e=A*ge;let r=A;for(;r>e&&s<ve;){++s,a=r/v;for(let e=1;e<g;++e)for(let t=e+1;t<=g;++t){const o=(e*e-e)/2,s=(t*t-t)/2,u=e+s,c=i[u-1],m=c*c;if(m<a)continue;const d=e+o,v=t+s,q=i[d-1],A=i[v-1],I=q-A;0===I?(S=-Math.PI/4,x=Ae,E=qe):(S=-Math.atan((c+c)/I)/2,x=Math.sin(S),E=Math.cos(S));const M=x*x,b=E*E,N=x*E;let T=g*(e-1),V=g*(t-1);for(let r=1;r<=g;++r)r!==e&&r!==t&&(h=(r*r-r)/2,f=r<t?r+s:t+h,y=i[f-1],l=r<e?r+o:e+h,w=i[l-1],i[l-1]=w*E-y*x,i[f-1]=w*x+y*E),++T,++V,z=n[T-1],p=n[V-1],n[T-1]=E*z-x*p,n[V-1]=x*z+E*p;S=c*N,S+=S,i[d-1]=q*b+A*M-S,i[v-1]=q*M+A*b+S,i[u-1]=0,r=Math.abs(r-m)}}}for(let e=0;e<g;++e)c=e+e*(e+1)/2,r[e]=i[c],o[e]=e;for(let e=0;e<g-1;++e){S=r[e],c=e;for(let t=e+1;t<g;++t)S<r[t]&&(c=t,S=r[t]);r[c]=r[e],r[e]=S,u=o[c],o[c]=o[e],o[e]=u}q=0;for(let e=0;e<g;++e){m=o[e]*g;for(let e=0;e<g;++e)t[q++]=n[m++]}return{values:r,vectors:t}}class Me{constructor(){this.eigenValues=[],this.eigenVectors=[],console.warn("Deprecated class. Use instead eigen(mat: Array<number>")}compute(e){const r=Ie(e);return this.eigenValues=r.values,this.eigenVectors=r.vectors,r}vector(e){return console.assert(e>=0&&e<3),[this.eigenVectors[3*e],this.eigenVectors[3*e+1],this.eigenVectors[3*e+2]]}get vectors(){return this.eigenVectors}value(e){return console.assert(e>=0&&e<3),this.eigenValues[e]}get values(){return this.eigenValues}}const be=(e,r)=>e.reduce(((e,t,i)=>e+t*r[i]),0),Ne=(e,r)=>e.reduce(((e,t,i)=>e+t*r[i]),0),Te=(e,r)=>[r[0]-e[0],r[1]-e[1]],Ve=(e,r)=>[r[0]-e[0],r[1]-e[1],r[2]-e[2]];function _e(e,r,t,i){const n=Te(r,t),o=Te(r,i),s=Te(r,e),a=be(n,n),u=be(n,o),c=be(o,o),m=be(s,n),f=be(s,o),h=1/(a*c-u*u),l=(c*m-u*f)*h,d=(a*f-u*m)*h;return[1-l-d,l,d]}function Fe(e,r,t,i){const n=Ve(r,t),o=Ve(r,i),s=Ve(r,e),a=Ne(n,n),u=Ne(n,o),c=Ne(o,o),m=Ne(s,n),f=Ne(s,o),h=1/(a*c-u*u),l=(c*m-u*f)*h,d=(a*f-u*m)*h;return[1-l-d,l,d]}function Pe(e,r,t,i,n){const o=e=>[e[0],e[1],e[2],1],s=o(r),a=o(t),u=o(i),c=o(n),m=o(e),f=$e(s,a,u,c);return[$e(m,a,u,c)/f,$e(s,m,u,c)/f,$e(s,a,m,c)/f,$e(s,a,u,m)/f]}function $e(e,r,t,i){return e[3]*r[2]*t[1]*i[0]-e[2]*r[3]*t[1]*i[0]-e[3]*r[1]*t[2]*i[0]+e[1]*r[3]*t[2]*i[0]+e[2]*r[1]*t[3]*i[0]-e[1]*r[2]*t[3]*i[0]-e[3]*r[2]*t[0]*i[1]+e[2]*r[3]*t[0]*i[1]+e[3]*r[0]*t[2]*i[1]-e[0]*r[3]*t[2]*i[1]-e[2]*r[0]*t[3]*i[1]+e[0]*r[2]*t[3]*i[1]+e[3]*r[1]*t[0]*i[2]-e[1]*r[3]*t[0]*i[2]-e[3]*r[0]*t[1]*i[2]+e[0]*r[3]*t[1]*i[2]+e[1]*r[0]*t[3]*i[2]-e[0]*r[1]*t[3]*i[2]-e[2]*r[1]*t[0]*i[3]+e[1]*r[2]*t[0]*i[3]+e[2]*r[0]*t[1]*i[3]-e[0]*r[2]*t[1]*i[3]-e[1]*r[0]*t[2]*i[3]+e[0]*r[1]*t[2]*i[3]}function Ce(e){let r=Number.POSITIVE_INFINITY;const t=e.length;for(let i=0;i<t;++i){const t=e[i];t<r&&(r=t)}return r}function De(e){let r=Number.NEGATIVE_INFINITY;const t=e.length;for(let i=0;i<t;++i){const t=e[i];t>r&&(r=t)}return r}function Re(e){let r=Number.POSITIVE_INFINITY,t=Number.NEGATIVE_INFINITY;const i=e.length;for(let n=0;n<i;++n){const i=e[n];i<r&&(r=i),i>t&&(t=i)}return[r,t]}function Ge(e){const r=Re(e);return e.map((e=>(e-r[0])/(r[1]-r[0])))}function Oe(e,r){return e.map((e=>e*r))}function Ye(e){return e.map(((e,r)=>({value:e,i:r}))).filter((e=>Number.isNaN(e.value))).map((e=>e.i))}function ke(e){const r=[];return e.forEach((e=>r.push(...e))),r}function je(e,r,t,i,n){const o=1/(t-r);return i*(t-e)*o+n*(e-r)*o}function Le(e,r,t,i,n,o,s){const a=je(e[0],r[0],t[0],i,o),u=je(e[0],r[0],t[0],n,s);return je(e[1],r[1],t[1],a,u)}function Be(e,r,t,i,n,o,s,a,u,c,m){const f=je(e[0],r[0],t[0],i,a),h=je(e[0],r[0],t[0],o,c),l=je(e[0],r[0],t[0],n,u),d=je(e[0],r[0],t[0],s,m),y=je(e[1],r[1],t[1],f,l),w=je(e[1],r[1],t[1],h,d);return je(e[2],r[2],t[2],y,w)}function Qe(e,r,t,i,n,o,s){const a=_e(e,r,t,i);if(Array.isArray(n))return n.map(((e,r)=>e*a[0]+o[r]*a[1]+s[r]*a[2]));const u=o,c=s;return a[0]*n+a[1]*u+a[2]*c}function Xe(e,r,t,i,n,o,s){const a=Fe(e,r,t,i);if(Array.isArray(n))return n.map(((e,r)=>e*a[0]+o[r]*a[1]+s[r]*a[2]));const u=o,c=s;return a[0]*n+a[1]*u+a[2]*c}function Ue(e,r,t,i,n,o,s,a,u){const c=Pe(e,r,t,i,n);if(Array.isArray(o))return o.map(((e,r)=>e*c[0]+s[r]*c[1]+a[r]*c[2]+u[r]*c[3]));const m=s,f=a,h=u;return c[0]*o+c[1]*m+c[2]*f+c[3]*h}var Ze,He;function Je({attribute:e,topology:r,size:t=3,direction:i=Ze.INCREASING}){let n;if(void 0!==e)if(0!==e.length)if(void 0!==r)if(0!==r.length){if(Array.isArray(r[0]))n=r;else{if(n=[],r.length%t!=0)throw new Error(`Cannot meshInterpolate, topology (of size ${r.length}) is not divisable by ${t}`);for(let e=0;e<r.length;e+=t){const i=[];for(let n=0;n<t;++n)i.push(r[e+n]);n.push(i)}}switch(i){case Ze.INCREASING:return function({from:e,topology:r}){if(Ke(r)[0]<0)throw new Error("Topology contains negatif indices");let t=e[0];t=Array.isArray(t)?t.slice().fill(0):0;const i=new Array(r.length).fill(t);return"number"==typeof t?r.forEach(((r,t)=>{i[t]=r.reduce(((r,t)=>r+e[t]))/r.length})):r.forEach(((r,n)=>{let o=t.slice();r.forEach((r=>{const t=e[r];o=o.map(((e,r)=>e+t[r]))})),i[n]=Oe(o,1/r.length)})),i}({from:e,topology:n});case Ze.DECREASING:return function({from:e,topology:r}){const t=Ke(r);if(t[0]<0)throw new Error("Topology contains negatif indices");let i,n=e[0],o=1;Array.isArray(n)?(n=n.slice().fill(0),o=n.length,i=new Array(t[1]+1).fill(void 0).map((e=>n.slice()))):(n=0,i=new Array(t[1]+1).fill(0));const s=new Array(i.length).fill(0);if(Array.isArray(n)){r.forEach(((r,t)=>{const n=e[t];r.forEach((e=>{const r=i[e];for(let e=0;e<o;++e)r[e]+=n[e];s[e]++}))}));for(let e=0;e<i.length;++e)for(let r=0;r<o;++r)i[e][r]/=s[e]}else{const t=i;r.forEach(((r,i)=>{const n=e[i];r.forEach((e=>{t[e]+=n,s[e]++}))}));for(let e=0;e<i.length;++e)t[e]/=s[e]}return i}({from:e,topology:n})}}else console.warn("Cannot meshInterpolate, topology is empty");else console.warn("Cannot meshInterpolate, attribute is topology");else console.warn("Cannot meshInterpolate, attribute is empty");else console.warn("Cannot meshInterpolate, attribute is undefined")}function Ke(e){const r=[1/0,-1/0];return e.forEach((e=>{const t=Re(e);r[0]=Math.min(r[0],t[0]),r[1]=Math.max(r[1],t[1])})),r}!function(e){e[e.INCREASING=0]="INCREASING",e[e.DECREASING=1]="DECREASING"}(Ze||(Ze={}));class We{constructor(e){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],void 0!==e&&this.add(e)}reset(){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]}get min(){return this.m_[0]}get max(){return this.m_[1]}get length(){return this.m_[1]-this.m_[0]}get value(){return this.m_}normalize(e){return(e-this.min)/(this.max-this.min)}add(e){if(Array.isArray(e))e.forEach((e=>{e<this.m_[0]&&(this.m_[0]=e),e>this.m_[1]&&(this.m_[1]=e)}));else{const r=e;r<this.m_[0]&&(this.m_[0]=r),r>this.m_[1]&&(this.m_[1]=r)}return this}}!function(e){e.create=(e,r)=>r.map(((r,t)=>r-e[t])),e.norm2=e=>e.reduce(((e,r)=>e+r**2),0),e.norm=r=>Math.sqrt(e.norm2(r)),e.add=(e,r)=>e.map(((e,t)=>e+r[t])),e.sub=(e,r)=>e.map(((e,t)=>e-r[t])),e.scale=(e,r)=>e.map((e=>e*r)),e.setCoord=(e,r,t)=>e[r]=t,e.set=(e,r)=>r.forEach(((t,i)=>e[i]=r[i])),e.dot=(e,r)=>e.reduce(((e,t,i)=>e+t*r[i]),0),e.cross=(e,r)=>[e[1]*r[2]-e[2]*r[1],e[2]*r[0]-e[0]*r[2],e[0]*r[1]-e[1]*r[0]],e.normalize=r=>{const t=e.norm(r);return r.map((e=>e/t))},e.clone=e=>[...e]}(He||(He={}));const er=(e,r,t)=>{e[r][0]=t[0],e[r][1]=t[1],e[r][2]=t[2]};class rr{constructor(){this.q=[0,0,0,1]}static fromAxisAngle(e,r){const t=new rr;return t.setAxisAngle(e,r),t}static fromProd(e,r){const t=new rr;return t.q[0]=e.q[3]*r.q[0]+r.q[3]*e.q[0]+e.q[1]*r.q[2]-e.q[2]*r.q[1],t.q[1]=e.q[3]*r.q[1]+r.q[3]*e.q[1]+e.q[2]*r.q[0]-e.q[0]*r.q[2],t.q[2]=e.q[3]*r.q[2]+r.q[3]*e.q[2]+e.q[0]*r.q[1]-e.q[1]*r.q[0],t.q[3]=e.q[3]*r.q[3]-r.q[0]*e.q[0]-e.q[1]*r.q[1]-e.q[2]*r.q[2],t}static fromBase(e,r,t){const i=new rr;return i.setFromBase(e,r,t),i}static fromRotationMatrix(e){const r=new rr;return r.setFromRotationMatrix(e),r}static fromTo(e,r){const t=new rr;return t.setFromTo(e,r),t}get data(){return this.q}get axis(){const e=[this.q[0],this.q[1],this.q[2]],r=He.norm(e);return r>1e-8&&He.scale(e,1/r),Math.acos(this.q[3])<=Math.PI/2?e:He.scale(e,-1)}get angle(){const e=2*Math.acos(this.q[3]);return e<=Math.PI?e:2*Math.PI-e}equals(e){for(let r=0;r<4;++r)if(this.q[r]!==e.q[r])return!1;return!0}notEquals(e){return!this.equals(e)}prod(e){const r=rr.fromProd(this,e);return this.setFrom(r)}inverse(){const e=new rr;for(let r=0;r<3;++r)e.q[r]=-this.q[r];return e.q[3]=this.q[3],e}invert(){return this.q[0]*=-1,this.q[1]*=-1,this.q[2]*=-1,this}negate(){return this.invert(),this.q[3]*=-1,this}normalize(){const e=this.q,r=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]);for(let t=0;t<4;++t)e[t]/=r;return r}dot(e,r){const t=e.q,i=r.q;return t[0]*i[0]+t[1]*i[1]+t[2]*i[2]+t[3]*i[3]}iRotate(e){const r=this.q,t=2*r[0]*r[0],i=2*r[1]*r[1],n=2*r[2]*r[2],o=2*r[0]*r[1],s=2*r[0]*r[2],a=2*r[0]*r[3],u=2*r[1]*r[2],c=2*r[1]*r[3],m=2*r[2]*r[3];return[(1-i-n)*e[0]+(o+m)*e[1]+(s-c)*e[2],(o-m)*e[0]+(1-n-t)*e[1]+(u+a)*e[2],(s+c)*e[0]+(u-a)*e[1]+(1-i-t)*e[2]]}rotate(e){const r=this.q,t=2*r[0]*r[0],i=2*r[1]*r[1],n=2*r[2]*r[2],o=2*r[0]*r[1],s=2*r[0]*r[2],a=2*r[0]*r[3],u=2*r[1]*r[2],c=2*r[1]*r[3],m=2*r[2]*r[3];return[(1-i-n)*e[0]+(o-m)*e[1]+(s+c)*e[2],(o+m)*e[0]+(1-n-t)*e[1]+(u-a)*e[2],(s-c)*e[0]+(u+a)*e[1]+(1-i-t)*e[2]]}toMatrix(){this.normalize();const e=this.q,r=[[0,0,0],[0,0,0],[0,0,0]],t=e[0],i=e[1],n=e[2],o=e[3];return r[0][0]=2*(t*t+i*i)-1,r[0][1]=2*(i*n-t*o),r[0][2]=2*(i*o+t*n),r[1][0]=2*(i*n+t*o),r[1][1]=2*(t*t+n*n)-1,r[1][2]=2*(n*o-t*i),r[2][0]=2*(i*o-t*n),r[2][1]=2*(n*o+t*i),r[2][2]=2*(t*t+o*o)-1,r}setFrom(e){for(let r=0;r<4;++r)this.q[r]=e.q[r];return this}setAxisAngle(e,r){const t=He.norm(e);if(t<1e-9)this.q[0]=0,this.q[1]=0,this.q[2]=0,this.q[3]=1;else{const i=Math.sin(r/2);this.q[0]=i*e[0]/t,this.q[1]=i*e[1]/t,this.q[2]=i*e[2]/t,this.q[3]=Math.cos(r/2)}return this}setFromTo(e,r){const t=1e-10,i=He.norm2(e),n=He.norm2(r),o=He.cross(e,r),s=He.norm2(o),a=this.q,u=He.dot(e,r)/Math.sqrt(i*n);if(u<0&&1-Math.abs(u)<t)return a[0]=a[1]=a[2]=0,a[3]=1,this;if(i<t||n<t||s<t)a[0]=a[1]=a[2]=0,a[3]=1;else{let t=Math.asin(Math.sqrt(s/i/n));He.dot(e,r)<0&&(t=Math.PI-t),this.setAxisAngle(o,t)}return this}setFromRotationMatrix(e){let r=2;if(e[0][0]>e[1][1]?e[0][0]>e[2][2]&&(r=0):e[1][1]>e[2][2]&&(r=1),e[0][0]+e[1][1]+e[2][2]>e[r][r])this.q[3]=Math.sqrt(e[0][0]+e[1][1]+e[2][2]+1)/2,this.q[0]=(e[2][1]-e[1][2])/(4*this.q[3]),this.q[1]=(e[0][2]-e[2][0])/(4*this.q[3]),this.q[2]=(e[1][0]-e[0][1])/(4*this.q[3]);else{const t=(r+1)%3,i=(r+2)%3;this.q[r]=Math.sqrt(e[r][r]-e[t][t]-e[i][i]+1)/2,this.q[t]=(e[r][t]+e[t][r])/(4*this.q[r]),this.q[i]=(e[r][i]+e[i][r])/(4*this.q[r]),this.q[3]=(e[i][t]-e[t][i])/(4*this.q[r])}return this}setFromBase(e,r,t){const i=[[0,0,0],[0,0,0],[0,0,0]],n=He.norm(e),o=He.norm(r),s=He.norm(t);for(let a=0;a<3;++a)er(i,a,[e[a]/n,r[a]/o,t[a]/s]);return this.setFromRotationMatrix(i)}}function tr(e,r,t){const i=He.norm(e),n=[0,0,0,1];if(i>1e-9){const t=Math.sin(.5*r)/i;n[0]=t*e[0],n[1]=t*e[1],n[2]=t*e[2],n[3]=Math.cos(.5*r)}const o=2*n[0]**2,s=2*n[1]**2,a=2*n[2]**2,u=2*n[0]*n[1],c=2*n[0]*n[2],m=2*n[0]*n[3],f=2*n[1]*n[2],h=2*n[1]*n[3],l=2*n[2]*n[3];return[(1-s-a)*t[0]+(u-l)*t[1]+(c+h)*t[2],(u+l)*t[0]+(1-a-o)*t[1]+(f-m)*t[2],(c-h)*t[0]+(f+m)*t[1]+(1-s-o)*t[2]]}function ir(e,r){if(Array.isArray(e))return rr.fromAxisAngle(e,r).toMatrix();let t=2;"x"===e||"X"===e?t=0:"y"!==e&&"Y"!==e||(t=1);const i=[[0,0,0],[0,0,0],[0,0,0]],n=Math.cos(r*Math.PI/180),o=Math.sin(r*Math.PI/180);return 2===t?(i[0][0]=n,i[0][1]=-o,i[1][0]=o,i[1][1]=n,i[2][2]=1):0===t?(i[0][0]=1,i[1][1]=n,i[1][2]=-o,i[2][1]=o,i[2][2]=n):(i[0][0]=n,i[0][2]=o,i[2][0]=-o,i[1][1]=1,i[2][2]=n),i}var nr;!function(e){function r(e){return 6===e.length?[[e[0],e[1],e[2]],[e[1],e[3],e[4]],[e[2],e[4],e[5]]]:[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]]]}function t(e,r){const t=[[0,0,0],[0,0,0],[0,0,0]];return t[0][0]=e[0][0]*r[0][0]+e[0][1]*r[1][0]+e[0][2]*r[2][0],t[0][1]=e[0][0]*r[0][1]+e[0][1]*r[1][1]+e[0][2]*r[2][1],t[0][2]=e[0][0]*r[0][2]+e[0][1]*r[1][2]+e[0][2]*r[2][2],t[1][0]=e[1][0]*r[0][0]+e[1][1]*r[1][0]+e[1][2]*r[2][0],t[1][1]=e[1][0]*r[0][1]+e[1][1]*r[1][1]+e[1][2]*r[2][1],t[1][2]=e[1][0]*r[0][2]+e[1][1]*r[1][2]+e[1][2]*r[2][2],t[2][0]=e[2][0]*r[0][0]+e[2][1]*r[1][0]+e[2][2]*r[2][0],t[2][1]=e[2][0]*r[0][1]+e[2][1]*r[1][1]+e[2][2]*r[2][1],t[2][2]=e[2][0]*r[0][2]+e[2][1]*r[1][2]+e[2][2]*r[2][2],t}function i(e){return[[e[0][0],e[1][0],e[2][0]],[e[0][1],e[1][1],e[2][1]],[e[0][2],e[1][2],e[2][2]]]}function n(e,r){return t(r,t(e,i(r)))}e.unpack=r,e.pack=function(e,r=!0){return r?[e[0][0],e[0][1],e[0][2],e[1][1],e[1][2],e[2][2]]:[e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2]]},e.det=function(e){return e[0][0]*e[1][1]*e[2][2]-e[0][0]*e[1][2]*e[2][1]-e[0][1]*e[1][0]*e[2][2]+e[0][1]*e[1][2]*e[2][0]+e[0][2]*e[1][0]*e[2][1]-e[0][2]*e[1][1]*e[2][0]},e.multMat=t,e.multVec=function(e,r){const t=r[0],i=r[1],n=r[2];return[e[0][0]*t+e[0][1]*i+e[0][2]*n,e[1][0]*t+e[1][1]*i+e[1][2]*n,e[2][0]*t+e[2][1]*i+e[2][2]*n]},e.multTVec=function(e,r){const t=r[0],i=r[1],n=r[2];return[e[0][0]*t+e[1][0]*i+e[2][0]*n,e[0][1]*t+e[1][1]*i+e[2][1]*n,e[0][2]*t+e[1][2]*i+e[2][2]*n]},e.inv=function(e,r){const t=e[0][0],i=e[0][1],n=e[0][2],o=e[1][0],s=e[1][1],a=e[1][2],u=e[2][0],c=e[2][1],m=e[2][2],f=m*s-a*c,h=a*u-m*o,l=c*o-s*u,d=t*f+i*h+n*l;if(0===d){const e="Matrix3: .getInverse() can't invert matrix, determinant is 0";if(!0===r)throw new Error(e);return console.warn(e),this.identity()}const y=1/d;return[[f*y,(n*c-m*i)*y,(a*i-n*s)*y],[h*y,(m*t-n*u)*y,(n*o-a*t)*y],[l*y,(i*u-c*t)*y,(s*t-i*o)*y]]},e.transpose=i,e.transposeSelf=function(e){let r;return r=e[0][1],e[0][1]=e[1][0],e[1][0]=r,r=e[0][2],e[0][2]=e[2][0],e[2][0]=r,r=e[1][2],e[1][2]=e[2][1],e[2][1]=r,this},e.rotate=function(e,r,t){return n(e,ir(t,r))},e.rotateInverse=function(e,r){return t(i(r),t(e,r))},e.rotateForward=n,e.makeRotationX=function(e){const t=Math.cos(e*Math.PI/180),i=Math.sin(e*Math.PI/180);return r([1,0,0,0,t,-i,0,i,t])},e.makeRotationY=function(e){const t=Math.cos(e*Math.PI/180),i=Math.sin(e*Math.PI/180);return r([t,0,i,0,1,0,-i,0,t])},e.makeRotationZ=function(e){const t=Math.cos(e*Math.PI/180),i=Math.sin(e*Math.PI/180);return r([t,-i,0,i,t,0,0,0,1])}}(nr||(nr={}));const or=(e,r=!1)=>{let t=function(){0==ar&&(ur||function(e){sr[0]=e;for(let e=1;624>e;++e)sr[e]=1812433253*(sr[e-1]^sr[e]>>30)+e&4294967295}(+new Date),function(){for(let e=0;624>e;++e){const r=2147483648&sr[e]|2147483647&sr[(e+1)%624];sr[e]=sr[(e+397)%624]^r>>1,r%2==1&&(sr[e]^=2567483615)}}());let e=sr[ar];return e^=e>>11,e^=e<<7&2636928640,e^=e<<15&4022730752,e^=e>>18,ar=(ar+1)%624,e/2147483648}();return null!=e&&(t*=e),r?~~t:t},sr=[];let ar=0;const ur=!1;function cr(e,{x:r=0,y:t=0,z:i=0,lx:n,Lx:o,ly:s,Ly:a,nx:c,ny:m,name:f}){const h=o/(c-1),l=a/(m-1),d=e.series.positions,y=e.series[f];if(void 0===d)throw new Error("positions is undefined");if(void 0===y)throw new Error(`attribute named ${f} is undefined`);const w=new mr(n,s),z=[],p=[];for(let e=0;e<c;++e){w.x=r+e*h;for(let e=0;e<m;++e)w.y=t+e*l,p.push(w.x,w.y,i),z.push(w.density(d,y))}return{nx:c,ny:m,positions:u.Serie.create({array:p,itemSize:3}),solution:u.Serie.create({array:z,itemSize:y.itemSize})}}class mr{constructor(e,r){this.w=e,this.h=r,this.x=0,this.y=0}contains(e){return e[0]>=this.x&&e[1]>=this.y&&e[0]<=this.x+this.w&&e[1]<=this.y+this.h}density(e,r){let t,i=0;return t=1===r.itemSize?0:new Array(r.itemSize).fill(0),(0,u.forEach)([e,r],(([e,n])=>{if(this.contains(e))if(i++,1===r.itemSize)t+=n;else for(let e=0;e<r.itemSize;++e)t[e]+=n[e]})),1===r.itemSize?0===i?0:t/i:0===i?t:t.map((e=>e/i))}}function fr(e,r=100){let t=[],i=0;for(let n=0;n<r;++n)i+=e(n/(r-1)),t.push(i);t=t.map((e=>e/i));const n=1/r;return e=>{if(e<t[0])return e/t[0]*n;const r=hr(t,e);return(r+(e-t[r-1])/(t[r]-t[r-1]))*n}}const hr=(e,r)=>{let t=0,i=e.length;for(;t<i;){const n=Math.floor((t+i)/2);e[n]<r?t=n+1:i=n}return t}})(),n})()));
//# sourceMappingURL=math.js.map