{"version":3,"file":"@youwol/dataframe.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,2BAA4B,GAAIH,GACb,iBAAZC,QACdA,QAAQ,4BAA8BD,IAEtCD,EAAK,4BAA8BC,GACpC,CATD,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,uBCRhD,IAAIC,EAAsB,CCA1BA,EAAwB,CAACN,EAASO,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAET,EAASQ,IAC5EE,OAAOC,eAAeX,EAASQ,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBN,IACH,oBAAXmB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeX,EAASmB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeX,EAAS,aAAc,CAAEqB,OAAO,GAAO,0hBCQvD,MAAMC,EAAQ,CAACC,EAAkBC,KAGpC,IAAIC,EAASF,EAAIG,QAAO,CAACC,EAAKC,KAAM,IAAMD,KAAQC,EAAEH,UAAW,CAAC,GAC5DI,EAAWN,EAAIG,QAAO,CAACC,EAAKC,KAAM,IAAMD,KAAQC,EAAEC,YAAa,CAAC,GAChEC,EAAWP,EAAIG,QAAO,CAACC,EAAKC,KAAM,IAAMD,KAAQC,EAAEE,YAAa,CAAC,GAEpE,OAAOC,EAAUC,OAAO,CAAEP,SAAQI,WAAUC,WAAUN,SAAQ,EAerDS,EAAS,EAAGR,SAAQD,QAAOM,WAAUD,YAAuBK,IAE9DH,EAAUC,OAAO,CAAEP,OAAQ,IAAKA,KAAWS,GAAQV,QAAOM,WAAUD,aAWlEM,EAAc,EAAGC,KAAIC,QAAOC,WAErC,MAAMC,EAAQ7B,OAAO8B,QAAQJ,EAAGX,QAAQgB,KAAI,EAAEH,EAAMD,KAAWC,IACzDI,EAAyB,IAAjBH,EAAMI,OAAeP,EAAGX,OAAOc,EAAM,IAAIG,MAAQ,EAE/D,GAAc,IAAVA,GAAeL,EAAMK,QAAUA,EAC/B,MAAM,IAAIE,MAAM,+DAIpB,OADAR,EAAGX,OAAOa,GAAQD,EACXD,CAAE,EAgBAS,EAAS,CAACC,EAAsBrB,IAClCqB,EAAUD,OAAOpB,GAMrB,MAAMM,EA2BFgB,QAAQC,GACXtC,OAAO8B,QAAQnC,KAAKoB,QAAQsB,SAAQ,EAAET,EAAMD,GAAQY,IAAMD,EAAGV,EAAMD,EAAOY,IAC9E,CAmBA,YACIxB,EACAD,EACAK,EACAC,GAlBY,KAAAN,WAA4B0B,EAMrC,KAAArB,SAAmC,CAAC,EAM3B,KAAAC,SAAmC,CAAC,EAQhDzB,KAAKoB,OAASA,EACdpB,KAAKmB,MAAQA,EACbnB,KAAKwB,SAAWA,EAChBxB,KAAKyB,SAAWA,CACpB,CAMAqB,SAASb,GACL,YAA6BY,IAAtB7C,KAAKoB,OAAOa,EACvB,CAqBAc,eACI,OAAE3B,EAAM,SAAEI,EAAQ,SAAEC,EAAQ,MAAEN,IAM9B,OAAO,IAAIO,EAAUN,EAAQD,EAAOK,GAAY,CAAC,EAAGC,GAAY,CAAC,EACrE,CAaAe,OAAOQ,GACH,MAAMjB,EAAK/B,KAAKiD,QAchB,OAZIC,MAAMC,QAAQH,GACdA,EAAUN,SAAQT,IACVF,EAAGX,OAAOR,eAAeqB,WAClBF,EAAGX,OAAOa,MAKrBF,EAAGX,OAAOR,eAAeoC,WAClBjB,EAAGX,OAAO4B,GAGlBjB,CACX,CAEAkB,QACI,OAAO,IAAIvB,EAAU1B,KAAKoB,OAAQpB,KAAKmB,MAAOnB,KAAKwB,SAAUxB,KAAKyB,SACtE,EClMG,SAAS2B,EAAYd,EAAgBe,GACxC,YAAaR,IAATQ,EAA2B,IAAIH,MAAMZ,GAAQgB,UAAKT,GAClDQ,aAAgBE,SACT,IAAIL,MAAMZ,GAAQgB,UAAKT,GAAWT,KAAK,CAACoB,EAAEZ,IAAMS,EAAKT,KAEzD,IAAIM,MAAMZ,GAAQgB,KAAKD,EAClC,CA6BO,SAASI,EAAuCC,EAAWC,EAAwBC,GAEtF,GAAIV,MAAMC,QAAQQ,GAAQ,CACtB,MAAMrB,EAASqB,EAAMrB,OAAOoB,EAAKG,kBACjC,IAAIC,EAEAC,EAAkD,oBAAtBC,kBAShC,OANIF,EAAK,IAAIJ,EADTE,GAAUG,EACI,IAAIC,kBAAkB1B,GAGtB,IAAI2B,YAAY3B,IAElCwB,EAAGI,IAAIP,GACAG,EAEN,CACD,MAAMK,EAAIR,EAAMD,EAAKG,kBACrB,OACW,IAAIH,EADXE,EACgB,IAAII,kBAAkBG,GAE1B,IAAIF,YAAYE,IAExC,CAgBO,SAASC,GACZ,KAACV,EAAI,MAAErB,EAAK,SAAEgC,EAAS,EAAC,UAAEC,EAAU,EAAC,OAAEV,GAAO,EAAK,SAAEpC,IAIrD,GAAI6C,GAAU,EAAI,MAAM,IAAI9B,MAAM,wBAClC,GAAIF,GAAO,EAAG,MAAM,IAAIE,MAAM,qBAE9B,QAAWM,IAAPa,GAAoBR,MAAMC,QAAS,IAAIO,EAAK,IAC5C,OAAOa,EAAM5C,OAAO,CAChBgC,MAAO,IAAIT,MAAMb,EAAMgC,GAAUf,KAAK,GACtCe,aAKR,MAAM/B,EAASD,EAAMgC,EAASX,EAAKG,kBACnC,OAAID,EACOW,EAAM5C,OAAO,CAChBgC,MAAO,IAAID,EAAK,IAAIM,kBAAkB1B,IAAU+B,WAAU7C,WAAU8C,cAErEC,EAAM5C,OAAO,CAAEgC,MAAM,IAAID,EAAK,IAAIO,YAAY3B,IAAU+B,WAAU7C,WAAU8C,aACvF,CCtFO,MAAMC,EA+BT,YACIZ,EACAU,EACAT,EACApC,EAAmC,CAAC,EACpC8C,EAAoB,GAGpB,GArBY,KAAAA,UAAoB,EAW7B,KAAA9C,SAAmC,CAAC,EAUnCmC,EAAMrB,OAAS+B,GAAa,EAC5B,MAAM,IAAI9B,MAAM,iBAAiBoB,EAAMrB,0CAA0C+B,MACrFrE,KAAK2D,MAAQA,EACb3D,KAAKqE,SAAWA,EAChBrE,KAAK4D,OAASA,EACd5D,KAAKwB,SAAWA,EAChBxB,KAAKsE,UAAYA,CACrB,CAEAvB,eAAeyB,GACX,MAAO,UAAWA,GAAK,aAAcA,CACzC,CAUAzB,eACI,MACIY,EAAK,SAAEU,EAAQ,SAAE7C,EAAQ,UAAE8C,EAAY,IAQ3C,GAAID,GAAY,EAAG,MAAM,IAAI9B,MAAM,wBACnC,QAAcM,IAAVc,EAAqB,MAAM,IAAIpB,MAAM,0BAGzC,GAAiC,oBAAtByB,kBACP,OAAO,IAAIO,EAAMZ,EAAOU,GAAU,EAAO7C,EAAU8C,GAGvD,MAAMV,EAAUD,EAAcc,kBAAkBT,kBAChD,OAAO,IAAIO,EAAMZ,EAAOU,EAAUT,EAAQpC,EAAU8C,EACxD,CAIIhC,aACA,OAAOtC,KAAK2D,MAAMrB,MACtB,CAKID,YACA,OAAOrC,KAAK2D,MAAMrB,OAAStC,KAAKqE,QACpC,CAKIlB,cACA,OAAOD,MAAMC,QAAQnD,KAAK2D,MAC9B,CAMIe,oBACA,OAAO1E,KAAK2E,YAChB,CAMIA,mBACA,OAAQ3E,KAAKmD,OACjB,CAMIyB,eACA,OAAI5E,KAAKmD,SACDnD,KAAK2D,MAAcc,kBAAkBT,iBACjD,CAEAa,GAAGjC,GACC,OAAO5C,KAAK2D,MAAMf,EACtB,CAEAkC,OAAOlC,GACH,MAAMmC,EAAO/E,KAAKqE,SAClB,GAAa,IAATU,EAAY,OAAO/E,KAAK6E,GAAGjC,GAC/B,MAAMoC,EAAQpC,EAAImC,EACZE,EAAI,IAAI/B,MAAM6B,GAAMzB,KAAK,GAC/B,IAAK,IAAI4B,EAAI,EAAGA,EAAIH,IAAQG,EAAGD,EAAEC,GAAKlF,KAAK2D,MAAMqB,EAAQE,GACzD,OAAOD,CACX,CAEAE,UAAUvC,EAAW5B,GACjB,GAAI4B,GAAK5C,KAAKqC,MAAO,MAAM,IAAIE,MAAM,6BAErC,MAAMwC,EAAO/E,KAAKqE,SAElB,GAAa,IAATU,EAAY,CACZ,GAAI7B,MAAMC,QAAQnC,GAAQ,MAAM,IAAIuB,MAAM,0BAE1C,YADAvC,KAAK2D,MAAMf,GAAK5B,GAIpB,MAAMoE,EAAIpE,EACV,GAAIoE,EAAE9C,SAAWyC,EAAM,MAAM,IAAIxC,MAAM,iBAAiB6C,EAAE9C,iCAAiCyC,MAC3F,IAAK,IAAIG,EAAI,EAAGA,EAAIH,IAAQG,EACxBlF,KAAK2D,MAAMf,EAAImC,EAAOG,GAAKlE,EAAMkE,EAEzC,CAMAxC,QAAQ2C,GACJ,IAAK,IAAIzC,EAAI,EAAGA,EAAI5C,KAAKqC,QAASO,EAC9ByC,EAASrF,KAAK8E,OAAOlC,GAAIA,EAAG5C,KAEpC,CAKAoC,IAAIiD,GACA,MAAMC,EAAMD,EAASrF,KAAK8E,OAAO,GAAI,EAAG9E,MAElCqE,EAAYnB,MAAMC,QAAQmC,GAAOA,EAAIhD,OAAS,EAC9CiD,EAAIvF,KAAKwF,MAAMxF,KAAKqC,MAAOgC,GAEjC,IAAIoB,EAAK,EACT,IAAK,IAAI7C,EAAI,EAAGA,EAAI5C,KAAKqC,QAASO,EAAG,CACjC,MAAMqC,EAAII,EAASrF,KAAK8E,OAAOlC,GAAIA,EAAG5C,MACtC,GAAiB,IAAbqE,EACAkB,EAAE5B,MAAM8B,KAAQR,OAGhB,IAAK,IAAIC,EAAI,EAAGA,EAAIb,IAAYa,EAC5BK,EAAE5B,MAAM8B,KAAQR,EAAEC,GAI9B,OAAOK,CACX,CAgCAtC,MAAMyC,GAAuB,GACzB,MAAMlB,EAAI,IAAID,EAAMvE,KAAK2D,MAAMgC,MAAM,EAAG3F,KAAKqC,MAAQrC,KAAKqE,UAAWrE,KAAKqE,SAAUrE,KAAK4D,OAAQ5D,KAAKwB,SAAUxB,KAAKsE,WAIrH,OAHIoB,GACAlB,EAAEb,MAAMjB,SAAQ,CAACc,EAAGZ,IAAM4B,EAAEb,MAAMf,GAAK,IAEpC4B,CACX,CAOAoB,aAAY,MAAEvD,EAAK,SAAEgC,EAAQ,WAAEwB,GAAa,IACxC,MAAMrB,EAAI,IAAID,EAAMuB,EAAW,CAAEnC,MAAO3D,KAAK2D,MAAOtB,QAAOgC,aAAaA,EAAUrE,KAAK4D,OAAQ5D,KAAKwB,SAAUxB,KAAKsE,WACnH,GAAIuB,EACA,IAAK,IAAIjD,EAAI,EAAGA,EAAI4B,EAAEb,MAAMrB,SAAUM,EAAG4B,EAAEb,MAAMf,GAAK,EAE1D,OAAO4B,CACX,CAWAgB,MAAMnD,EAAegC,GACjB,OAAOrE,KAAK4F,YAAY,CAAEvD,QAAOgC,YACrC,EAQG,SAASyB,GACZ,MAAEnC,EAAK,MAAEtB,EAAK,SAAEgC,IAGhB,MAAM/B,EAASD,EAAQgC,EAEvB,GAAInB,MAAMC,QAAQQ,GACd,OAAO,IAAIT,MAAMZ,GAGrB,IAAIsC,GAAW,EAMf,MALiC,oBAAtBZ,oBACPY,EAAYjB,EAAcc,kBAAkBT,mBAI5CL,aAAiBoC,UAAkBtC,EAAYsC,UAAWzD,EAAQsC,GAClEjB,aAAiBqC,WAAmBvC,EAAYuC,WAAY1D,EAAQsC,GACpEjB,aAAiBsC,kBAA0BxC,EAAYwC,kBAAmB3D,EAAQsC,GAClFjB,aAAiBuC,WAAmBzC,EAAYyC,WAAY5D,EAAQsC,GACpEjB,aAAiBwC,YAAoB1C,EAAY0C,YAAa7D,EAAQsC,GACtEjB,aAAiByC,WAAmB3C,EAAY2C,WAAY9D,EAAQsC,GACpEjB,aAAiB0C,YAAoB5C,EAAY4C,YAAa/D,EAAQsC,GACtEjB,aAAiB2C,aAAqB7C,EAAY6C,aAAchE,EAAQsC,GACxEjB,aAAiB4C,aAAqB9C,EAAY8C,aAAcjE,EAAQsC,GACxEjB,aAAiB6C,cAAsB/C,EAAY+C,cAAelE,EAAQsC,GAC1EjB,aAAiB8C,eAAuBhD,EAAYgD,eAAgBnE,EAAQsC,QAAhF,CACJ,CC3SO,MAAMxC,EAAM,CAAChB,EAAyBuB,KACzC,GAAIO,MAAMC,QAAQ/B,GAAS,CACvB,IAAImE,EACApC,GAAY,EACZsC,EAAY,EAEhB,MAAMpD,EAAUjB,EAAO,GAAGiB,MACpBqE,EAAU,IAAIxD,MAAuB9B,EAAOkB,QAElD,IAAK,IAAIM,EAAE,EAAGA,EAAEP,IAASO,EAAG,CACxB,IAAK,IAAIsC,EAAE,EAAGA,EAAE9D,EAAOkB,SAAU4C,EAC7BwB,EAAKxB,GAAK9D,EAAO8D,GAAGJ,OAAOlC,GAG/B,MAAMqC,EAAItC,EAAG+D,QACH7D,IAAN0C,IACApC,EAAUD,MAAMC,QAAQ8B,GACxBM,EAAInE,EAAO,GAAGoE,MAAMnD,EAAOc,EAAU8B,EAAE3C,OAAS,IAGhDa,EACA8B,EAAEvC,SAAS0C,GAAKG,EAAE5B,MAAM8B,KAAQL,IAGhCG,EAAE5B,MAAM8B,KAAQR,EAIxB,OAAOM,EAGX,OAAOnE,EAAOgB,IAAIO,EAAG,ECpCZgE,EAAS,CAACnC,EAAUoC,KAC7B,QAAQ/D,IAAJ2B,EAAe,MAAM,IAAIjC,MAAO,sBAEpC,MAAMF,EAAQmC,EAAEnC,MACV4C,EAAI,GAEV,IAAK,IAAIrC,EAAE,EAAGA,EAAEP,IAASO,EAAG,CACxB,MAAMwC,EAAIZ,EAAEM,OAAOlC,GACfgE,EAAWxB,EAAGxC,EAAG4B,IAAKS,EAAE4B,KAAKzB,GAIrC,MAAM0B,EAAMtC,EAAEb,MAAMgC,MAAM,EAAGV,EAAE3C,QAG/B,OAFA2C,EAAEvC,SAAS,CAAC0C,EAAExC,IAAMkE,EAAGlE,GAAKwC,IAErBb,EAAM5C,OAAO,CAACgC,MAAOmD,EAAIzC,SAAUG,EAAEH,UAAU,ECX7C3B,EAAU,CAACtB,EAAyBiE,KAC7C,QAAaxC,IAATzB,EAAoB,MAAM,IAAImB,MAAO,sBAEzC,IAAMW,MAAMC,QAAQ/B,GAAU,CAC1B,IAAK,IAAIwB,EAAE,EAAGA,EAAExB,EAAOiB,QAASO,EAC5ByC,EAAUjE,EAAO0D,OAAOlC,GAAIA,EAAGxB,GAEnC,OAGJ,IAAIiB,EAAQjB,EAAO,GAAGiB,MACtB,IAAK,IAAIO,EAAE,EAAGA,EAAEP,IAASO,EACrByC,EAAUjE,EAAOgB,KAAKJ,GAASA,EAAM8C,OAAOlC,KAAMA,EAAGxB,ICEhDC,EAAS,SAAS0F,EAA2BC,EAAoBC,GAC1E,GAAM/D,MAAMC,QAAQ4D,GAIf,CACD,MAAM1E,EAAQ0E,EAAS,GAAG1E,MAC1B,IAAK,IAAIO,EAAE,EAAGA,EAAEP,IAASO,EACrBqE,EAAcD,EAAUC,EAAaF,EAAS3E,KAAKJ,GAASA,EAAM8C,OAAOlC,MAK7E,OAAOqE,EAVP,OADAF,EAASrE,SAASE,GAAKqE,EAAcD,EAASC,EAAarE,KACpDqE,CAYf,ECpBaC,EAAQ,CAAClF,EAAcmF,IACzBnF,EAAMI,KAAK,CAACgF,EAAMxE,IAAMuE,EAAGC,EAAMxE,EAAGZ,KCnBlCqF,EAAO,CAACrF,EAAcmF,EAAe,EAACG,EAAEC,IAAKD,EAAEC,MACxD,GAAuB,IAAnBvF,EAAMqC,SAAgB,MAAM,IAAI9B,MAAM,sCAC1C,MAAMiC,EAAIxC,EAAMiB,OAAM,GAEtB,OADAuB,EAAEb,MAAM0D,KAAKF,GACN3C,CAAC,ECFCgD,EAAM,CAAChD,EAAUa,KAC1B,QAAQxC,IAAJ2B,EAAe,MAAM,IAAIjC,MAAO,sBACpC,GAAmB,IAAfiC,EAAEH,SAAgB,MAAM,IAAI9B,MAAO,kCAEvC,OAAOoE,EAAOnC,EAAGa,EAAS,ECNjBoC,EAAS,CAAC1F,EAAeE,SAAqCY,IAApBd,EAAGX,OAAOa,GCApDyF,EAAQ3F,IACjB,GAAIwC,EAAMoD,QAAQ5F,GAAK,CACnB,MAAMyC,EAAIzC,EACV,MAAO,CACHoB,QAASqB,EAAErB,QACXyE,SAAUpD,EAAEE,cACZE,SAAUJ,EAAEZ,OACZtB,OAAQkC,EAAElC,OACVD,MAAOmC,EAAEnC,MACTgC,SAAUG,EAAEH,SACZC,UAAWE,EAAEF,UACbX,MAAOa,EAAEb,OAIjB,MAAMkE,EAAK9F,EAEX,MAAO,CACHP,SAAUqG,EAAGrG,SACbJ,OAAQf,OAAO8B,QAAQ0F,EAAGzG,QAAQgB,KAAK,EAAEH,EAAMD,MACpC,CACHC,OACAT,SAAUQ,EAAMR,SAChB2B,QAASnB,EAAMmB,QACfyE,SAAU5F,EAAM0C,cAChBE,SAAU5C,EAAM4B,OAChBtB,OAAQN,EAAMM,OACdD,MAAOL,EAAMK,MACbgC,SAAUrC,EAAMqC,SAChBC,UAAWtC,EAAMsC,UACjBX,MAAO3B,EAAM2B,UAGxB,EClCE,IAAUA,GAAjB,SAAiB,GAmCb,SAAgBmE,EAAOnE,GACnB,IAAIoE,EAAIC,OAAOC,kBACXC,EAAIF,OAAOG,kBACf,MAAMC,EAAIzE,EAAMrB,OAChB,IAAK,IAAIM,EAAE,EAAGA,EAAEwF,IAAKxF,EAAG,CACpB,MAAM0E,EAAI3D,EAAMf,GACZ0E,EAAIS,IAAGA,EAAIT,GACXA,EAAIY,IAAGA,EAAIZ,GAEnB,MAAO,CAACS,EAAGG,EACf,CApCgB,EAAAG,IAAhB,SAAoB1E,GAChB,IAAIoE,EAAIC,OAAOC,kBACf,MAAMG,EAAIzE,EAAMrB,OAChB,IAAK,IAAIM,EAAE,EAAGA,EAAEwF,IAAKxF,EAAG,CACpB,MAAM0E,EAAI3D,EAAMf,GACZ0E,EAAIS,IAAGA,EAAIT,GAEnB,OAAOS,CACX,EAKgB,EAAAO,IAAhB,SAAoB3E,GAChB,IAAIoE,EAAIC,OAAOG,kBACf,MAAMC,EAAIzE,EAAMrB,OAChB,IAAK,IAAIM,EAAE,EAAGA,EAAEwF,IAAKxF,EAAG,CACpB,MAAM0E,EAAI3D,EAAMf,GACZ0E,EAAIS,IAAGA,EAAIT,GAEnB,OAAOS,CACX,EAKgB,EAAAD,OAAM,EAeN,EAAAS,UAAhB,SAA0B5E,GACtB,MAAMoE,EAAID,EAAOnE,GACjB,OAAOA,EAAMvB,KAAKgD,IAAMA,EAAE2C,EAAE,KAAKA,EAAE,GAAGA,EAAE,KAC5C,EAKgB,EAAAS,MAAhB,SAAsB7E,EAAea,GACjC,OAAOb,EAAMvB,KAAKgD,GAAKA,EAAEZ,GAC7B,EAOgB,EAAAiE,WAAhB,SAA2B9E,GAGvB,OAFeA,EAAMvB,KAAK,CAACpB,EAAM4B,KAAc,CAAC5B,QAAO4B,QACpC+D,QAAQW,GAAKU,OAAOU,MAAMpB,EAAEtG,SACpCoB,KAAKgD,GAAKA,EAAExC,GAC3B,EAKgB,EAAA+F,QAAhB,SAAwBhF,GACpB,MAAMsB,EAAmB,GAEzB,OADAtB,EAAMjB,SAAS4E,GAAKrC,EAAE4B,QAAQS,KACvBrC,CACX,CACH,CAjFD,CAAiBtB,IAAAA,EAAK,KCCf,MAAMiF,EAAO,CAACjF,EAAsB3B,KACvC,GAAIuC,EAAMoD,QAAQhE,GAAQ,CACtB,MAAMkF,EAAIlF,EACV,GAAI3B,EAAM2B,MAAMrB,SAAWuG,EAAElF,MAAMrB,OAAQ,MAAM,IAAIC,MAAM,mCAC3DsG,EAAElF,MAAMjB,SAAS,CAAC0C,EAAExC,IAAMZ,EAAM2B,MAAMf,GAAKwC,QAE1C,CACD,GAAIpD,EAAM2B,MAAMrB,SAAWqB,EAAMrB,OAAQ,MAAM,IAAIC,MAAM,mCACzDoB,EAAMjB,SAAS,CAAC0C,EAAExC,IAAMZ,EAAM2B,MAAMf,GAAKwC,IAE7C,OAAOpD,CAAK,ECVH8G,EAAa9G,GACfA,EAAMiB,OAAM,GCCV8F,EAAc,CAAChH,EAAeyC,IAChCnE,OAAO8B,QAAQJ,EAAGX,QAAQC,QAAQ,CAACC,GAAMW,EAAMD,KAAWwC,IAAMxC,EAAQC,EAAOX,QAAKuB,GCHlFmG,EAAiBjH,GACnB1B,OAAO8B,QAAQJ,EAAGX,QAAQgB,KAAI,EAAEH,EAAMD,KAAWC,ICF/CgH,EAAU7D,GAAgB,IAAI8D,EAAO9D,GAK3C,MAAM8D,EACTC,YAAoB/D,GAAA,KAAAA,EAAAA,CACpB,CAEAP,GAAGjC,GACC,OAAO5C,KAAKoF,EAAExC,EAClB,CAEIN,aACA,OAAOtC,KAAKoF,EAAE9C,MAClB,CAEIqB,YACA,OAAO3D,KAAKoF,CAChB,CAMAmD,YACI,MAAMH,EAAIpI,KAAKoJ,OAEf,OADApJ,KAAKoF,EAAIpF,KAAKoF,EAAEhD,KAAKgD,GAAKA,EAAEgD,IACrBpI,IACX,CAEAoJ,OACI,OAAOC,KAAKC,KAAKtJ,KAAKoF,EAAE/D,QAAQ,CAACC,EAAK8D,IAAM9D,EAAM8D,GAAG,GAAG,GAC5D,CAOAmE,KAAK/E,GAED,OADAxE,KAAKoF,EAAIpF,KAAKoF,EAAEhD,KAAKgD,GAAKA,EAAEZ,IACrBxE,IACX,CAEAwJ,IAAIhF,GAEA,OADAxE,KAAKoF,EAAIZ,EAAEY,EAAEhD,KAAK,CAACqH,EAAE7G,IAAM5C,KAAKoF,EAAExC,IAAM6G,IACjCzJ,IACX,CAEA0J,IAAIlF,GAEA,OADAxE,KAAKoF,EAAIZ,EAAEY,EAAEhD,KAAK,CAACqH,EAAE7G,IAAM5C,KAAKoF,EAAExC,IAAM6G,IACjCzJ,IACX,CAEA2J,IAAIvE,GACA,OAAOpF,KAAK2D,MAAMtC,QAAQ,CAACC,EAAKgG,EAAG1E,IAAMtB,EAAMgG,EAAElC,EAAEzB,MAAMf,IAAI,EACjE,CAEAgH,WACI,IAAIpF,EAAI,GACR,IAAK,IAAI5B,EAAE,EAAGA,EAAE5C,KAAKsC,SAAUM,EAC3B4B,GAAKxE,KAAK6E,GAAGjC,GAAK,KAEtB,OAAO4B,CACX,ECpDG,MAAMqF,EAAUzE,GAAgB0E,EAAc1E,GAMxC0E,EAAiB1E,IAC1B,MAAM2C,EAAIsB,KAAKC,KAAKlE,EAAE9C,QACtB,IAAK0F,OAAO+B,UAAUhC,GAAI,MAAM,IAAIxF,MAAM,mDAAmD6C,EAAE9C,WAC/F,OAAO,IAAI0H,EAAO5E,EAAG2C,EAAE,EAObkC,EAAoB7E,IAC9B,MAAM2C,GAAKsB,KAAKC,KAAK,EAAElE,EAAE9C,OAAO,GAAG,GAAG,EACtC,IAAK0F,OAAO+B,UAAUhC,GAAI,MAAM,IAAIxF,MAAM,4EAA4E6C,EAAE9C,UAExH,MAAMnB,EAAQ,CAACyB,EAASsC,IAAatC,EAAImF,EAAI7C,EACvCgF,EAAS,CAACtH,EAASsC,IAAaA,EAAEtC,EAAI,GAAMsC,GAAK,EAAI6C,EAAI,EAAI7C,GAAKtC,EAAI,GAAMA,GAAK,EAAImF,EAAI,EAAInF,GAAKsC,EAElGuE,EAAI,IAAIvG,MAAM6E,EAAEA,GAAGzE,KAAK,GAC9B,IAAK,IAAIV,EAAE,EAAGA,EAAEmF,IAAKnF,EACjB,IAAK,IAAIsC,EAAE,EAAGA,EAAE6C,IAAK7C,EACjBuE,EAAGtI,EAAM+D,EAAEtC,IAAOwC,EAAG8E,EAAOtH,EAAEsC,IAItC,OADU,IAAI8E,EAAOP,EAAG1B,EAChB,EAOL,MAAMiC,EAETb,YAAsB/D,EAAsB2C,GAAtB,KAAA3C,EAAAA,EAAsB,KAAA2C,EAAAA,CAC5C,CAEA5G,MAAMyB,EAAWsC,GACb,OAAOtC,EAAI5C,KAAK+H,EAAI7C,CACxB,CAEIiF,kBACA,IAAIC,GAAK,EACT,IAAK,IAAIxH,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EACtB,IAAK,IAAIsC,EAAEtC,EAAGsC,EAAElF,KAAK+H,IAAK7C,EACtBkF,EAAKA,GAAOpK,KAAK6E,GAAGjC,EAAEsC,KAAOlF,KAAK6E,GAAGK,EAAEtC,GAG/C,OAAOwH,CACX,CAEAxB,OACI,OAAO,IAAIoB,EAAO,IAAIhK,KAAKoF,GAAIpF,KAAK+H,EACxC,CAEAlD,GAAGjC,EAAWsC,GACV,OAAOlF,KAAKoF,EAAGpF,KAAKmB,MAAMyB,EAAEsC,GAChC,CAEAmF,QACI,IAAIC,EAAI,EACR,IAAK,IAAI1H,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EAAG0H,GAAKtK,KAAK6E,GAAGjC,EAAEA,GAC5C,OAAO0H,CACX,CAEApG,IAAItB,EAAWsC,EAAWE,GAEtB,OADApF,KAAKoF,EAAGpF,KAAKmB,MAAMyB,EAAGsC,IAAOE,EACtBpF,IACX,CAEAwJ,IAAI5G,EAAWsC,EAAWE,GAEtB,OADApF,KAAKoF,EAAGpF,KAAKmB,MAAMyB,EAAGsC,KAAQE,EACvBpF,IACX,CAMAwI,MAAMhE,GAEF,OADAxE,KAAKoF,EAAIpF,KAAKoF,EAAEhD,KAAKgD,GAAKA,EAAEZ,IACrBxE,IACX,CAEIsC,aACA,OAAOtC,KAAKoF,EAAE9C,MAClB,CAMIqB,YACA,GAAI3D,KAAKmK,YAAa,CAClB,MAAM7C,EAAI,IAAIpE,MAAOlD,KAAK+H,GAAG/H,KAAK+H,EAAE,GAAG,GAAIzE,KAAK,GAChD,IAAIiH,EAAI,EACR,IAAK,IAAI3H,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EACtB,IAAK,IAAIsC,EAAEtC,EAAGsC,EAAElF,KAAK+H,IAAK7C,EACtBoC,EAAEiD,KAAOvK,KAAK6E,GAAGjC,EAAEsC,GAG3B,OAAOoC,EAEX,MAAO,IAAItH,KAAKoF,EACpB,CAMAoF,YACI,MAAMpF,EAAI,IAAIlC,MAAMlD,KAAKoF,EAAE9C,QAAQgB,KAAK,GACxC,IAAImC,EAAK,EACT,IAAK,IAAIP,EAAE,EAAGA,EAAElF,KAAK+H,IAAK7C,EACtB,IAAK,IAAItC,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EACtBwC,EAAEK,KAAQzF,KAAK6E,GAAGjC,EAAEsC,GAG5B,OAAO,IAAI8E,EAAO5E,EAAGpF,KAAK+H,EAC9B,CAKA0C,QAAQrF,GACJ,GAAIA,EAAE9C,SAAWtC,KAAK+H,EAAG,MAAM,IAAIxF,MAAM,2CACzC,MAAM+H,EAAI,IAAIpH,MAAMkC,EAAE9C,QAAQgB,KAAK,GAE7BgE,EAAKlC,aAAa8D,EAAS9D,EAAEzB,MAAQyB,EAC3C,IAAK,IAAIxC,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EACtB,IAAK,IAAIsC,EAAE,EAAGA,EAAElF,KAAK+H,IAAK7C,EACtBoF,EAAE1H,IAAM5C,KAAK6E,GAAGjC,EAAEsC,GAAKoC,EAAEpC,GAGjC,OAAO,IAAIgE,EAAOoB,EACtB,CAKAI,QAAQ3C,GACJ,GAAIA,EAAEA,IAAM/H,KAAK+H,EAAG,MAAM,IAAIxF,MAAM,2CACpC,MAAM+H,EAAI,IAAIpH,MAAM6E,EAAEzF,QAAQgB,KAAK,GAEnC,IAAK,IAAIV,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EACtB,IAAK,IAAIsC,EAAE,EAAGA,EAAElF,KAAK+H,IAAK7C,EACtB,IAAK,IAAIqF,EAAE,EAAGA,EAAEvK,KAAK+H,IAAKwC,EACtBD,EAAGtK,KAAKmB,MAAMyB,EAAEsC,KAAQlF,KAAK6E,GAAGjC,EAAE2H,GAAKxC,EAAElD,GAAG0F,EAAErF,GAK1D,OAAO,IAAI8E,EAAOM,EAAGtK,KAAK+H,EAC9B,CAMA4C,OAAO5C,GACH,GAAIA,EAAEA,IAAM/H,KAAK+H,EAAG,MAAM,IAAIxF,MAAM,oCAEpC,IAAK,IAAIK,EAAE,EAAGA,EAAE5C,KAAKoF,EAAE9C,SAAUM,EAC7B5C,KAAKoF,EAAExC,IAAMmF,EAAE3C,EAAExC,GAGrB,OAAO5C,IACX,CAEA4J,WACI,IAAIpF,EAAI,GACR,IAAK,IAAI5B,EAAE,EAAGA,EAAE5C,KAAK+H,IAAKnF,EAAG,CACzB,IAAK,IAAIsC,EAAE,EAAGA,EAAElF,KAAK+H,IAAK7C,EACtBV,GAAKxE,KAAK6E,GAAGjC,EAAEsC,GAAK,KAExBV,GAAK,KAET,OAAOA,CACX,ECpMG,MAAM,EAAS8C,GACD,IAAbA,EAAEjD,SACKiD,EAAElF,KAAKgD,GAAK4C,OAAOU,MAAMtD,KAE7BkC,EAAElF,KAAKgD,GAAK,IAAIlC,MAAMoE,EAAEjD,UAAUf,KAAK,GAAGlB,KAAIqH,GAAKzB,OAAOU,MAAMe,OCJ9DmB,EAAQ,CAACtD,EAAUH,IAAiBG,EAAElF,KAAKgD,KAAK+B,EAAG/B,KCWnDyF,EAAM,CAACvD,EAAUsD,EAAiBE,EAAgBC,IAC3DzD,EAAElF,KAAK,CAACpB,EAAM4B,KAAqB,IAAfgI,EAAM5J,GAAgB8J,EAAK9J,EAAO4B,EAAG0E,GAAKyD,EAAM/J,EAAO4B,EAAG0E,KC0B3E,MAAM0D,EA0BT7B,YAA6BpH,EAAekJ,GAAf,KAAAlJ,GAAAA,EAzBrB,KAAAmJ,IAAoB,GACZ,KAAA5G,UAAoB,EAyB5B2G,IAEI/H,MAAMC,QAAQ8H,IACdE,QAAQC,KAAK,+BACbpL,KAAKkL,IAAMD,IAGPA,EAAQI,cAAarL,KAAKkL,IAAMD,EAAQI,aACxCJ,EAAQ3G,YAAWtE,KAAKsE,UAAY2G,EAAQ3G,YAG5D,CAKAkF,IAAI8B,GACAtL,KAAKkL,IAAIrE,KAAKyE,EAClB,CAKAC,QACIvL,KAAKkL,IAAM,EACf,CAOAhJ,MAAMmC,GACF,IAAInC,EAAQ,IAAIsJ,IAgBhB,OAbAnL,OAAO8B,QAAQnC,KAAK+B,GAAGX,QAAQsB,SAAS,EAAET,EAAMD,MAExCA,EAAMqC,WAAaA,GAAYrC,EAAMsC,YAActE,KAAKsE,WAG1C,cAATrC,GAAiC,YAATA,GACzBC,EAAMsH,IAAIvH,GAGlBjC,KAAKkL,IAAIxI,SAAS4I,IACdA,EAAEpJ,MAAMlC,KAAK+B,GAAIsC,EAAUrC,EAAOC,GAAMS,SAAS0F,GAAKlG,EAAMsH,IAAIpB,IAAI,GACtE,IAEClF,MAAMuI,KAAKvJ,EACtB,CAKAY,SAASuB,EAAkBpC,GAEvB,OADUjC,KAAKkC,MAAMmC,GACZqH,SAASzJ,EACtB,CAKAD,MAAMqC,EAAkBpC,GACpB,IAAK,IAAK0J,EAAO3J,KAAU3B,OAAO8B,QAAQnC,KAAK+B,GAAGX,QAC9C,GAAIY,EAAMqC,WAAWA,GAAYpC,IAAO0J,EACpC,OAAO3J,EAAMiB,OAAM,GAG3B,IAAK,IAAIqI,KAAKtL,KAAKkL,IAAK,CACpB,MAAMlJ,EAAQsJ,EAAEtJ,MAAMhC,KAAK+B,GAAIsC,EAAUpC,GACzC,GAAID,EAAO,OAAOA,EAG1B,EC1GG,MAAM4J,EAQTzC,YAA6B9E,EAAmCpC,EAA+B4J,GAAlE,KAAAxH,SAAAA,EAAmC,KAAApC,KAAAA,EAA+B,KAAA4J,IAAAA,CAC/F,CAIA3J,MAAMH,EAAesC,EAAkBrC,EAAcC,GACjD,OAAIoC,IAAarE,KAAKqE,SAAiB,GAE7BrE,KAAK6L,IAAI9J,GAGZ,CAAC/B,KAAKiC,MAFE,EAGnB,CAIAD,MAAMD,EAAesC,EAAkBpC,GACnC,GAAIoC,IAAWrE,KAAKqE,UAAYrE,KAAKiC,OAAOA,EAC5C,OAAOjC,KAAK6L,IAAI9J,EACpB","sources":["webpack://@youwol/dataframe_APIv01/webpack/universalModuleDefinition","webpack://@youwol/dataframe_APIv01/webpack/bootstrap","webpack://@youwol/dataframe_APIv01/webpack/runtime/define property getters","webpack://@youwol/dataframe_APIv01/webpack/runtime/hasOwnProperty shorthand","webpack://@youwol/dataframe_APIv01/webpack/runtime/make namespace object","webpack://@youwol/dataframe_APIv01/./lib/dataframe.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/create.ts","webpack://@youwol/dataframe_APIv01/./lib/serie.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/map.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/filter.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/forEach.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/reduce.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/apply.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/sort.ts","webpack://@youwol/dataframe_APIv01/./lib/algorithms/cut.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/exists.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/info.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/arrayUtils.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/copy.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/duplicate.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/nameOfSerie.ts","webpack://@youwol/dataframe_APIv01/./lib/utils/getNameSeries.ts","webpack://@youwol/dataframe_APIv01/./lib/views/vector.ts","webpack://@youwol/dataframe_APIv01/./lib/views/matrix.ts","webpack://@youwol/dataframe_APIv01/./lib/conditional/isNaN.ts","webpack://@youwol/dataframe_APIv01/./lib/conditional/check.ts","webpack://@youwol/dataframe_APIv01/./lib/conditional/if.ts","webpack://@youwol/dataframe_APIv01/./lib/decompose/manager.ts","webpack://@youwol/dataframe_APIv01/./lib/decompose/functional-decomposer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@youwol/dataframe_APIv01\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@youwol/dataframe_APIv01\"] = factory();\n\telse\n\t\troot[\"@youwol/dataframe_APIv01\"] = factory();\n})((typeof self !== 'undefined' ? self : this), () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Serie } from './serie'\n\n/**\n * Merge two dataframe into one\n * @example\n * ```ts\n * const df1 = DataFrame.create(...)\n * const df2 = DataFrame.create(...)\n * const df3 = DataFrame.create(...)\n * const df = merge( [df1, df2, df3] )\n * ```\n * @category DataFrame\n */\nexport const merge = (dfs: DataFrame[], index?: string): DataFrame => {\n    // What if multiple column with same name\n    // What about userData, metaData\n    let series = dfs.reduce((acc, e) => ({ ...acc, ...e.series }), {})\n    let userData = dfs.reduce((acc, e) => ({ ...acc, ...e.userData }), {})\n    let metaData = dfs.reduce((acc, e) => ({ ...acc, ...e.metaData }), {})\n\n    return DataFrame.create({ series, userData, metaData, index })\n}\n\n/**\n * Merge series in a dataframe and return a new dataframe\n * @example\n * ```ts\n * const df1 = DataFrame.create(...)\n * const df2 = append(df1, {\n *   a: createSerie(...),\n *   b: createSerie(...)\n * })\n * ```\n * @category DataFrame\n */\nexport const append = ({ series, index, metaData, userData }: DataFrame, news: { [key: string]: Serie }): DataFrame => {\n    //! need to check that rows count are compatible\n    return DataFrame.create({ series: { ...series, ...news }, index, metaData, userData })\n}\n\n/**\n * Mutating function which add a new (or an existing) serie into a dataframe\n * @param {df: DataFrame, s: Serie, name: string} param0 The serie s into the dataframe df. If the serie\n * already exist, it is replaced. Serie's count is checked against existing series in the dataframe, so that\n * a dataframe will contain only series with same count.\n * @returns The input dataframe (not a copy!)\n * @category DataFrame\n */\nexport const insertSerie = ({ df, serie, name }: { df: DataFrame, serie: Serie, name: string }): DataFrame => {\n    //! need to check that rows count are compatible\n    const names = Object.entries(df.series).map(([name, serie]) => name)\n    const count = names.length !== 0 ? df.series[names[0]].count : 0\n\n    if (count !== 0 && serie.count !== count) {\n        throw new Error('Provided serie count must be equal to existing series count')\n    }\n\n    df.series[name] = serie\n    return df\n}\n\n/**\n * Remove a serie or a list of series (given by there name) from a dataframe.\n * @param dataframe The dataframe\n * @param serieName The serie of a list of series given by their names\n * @returns A new {@link Dataframe} even if no modification\n * @example\n * ```ts\n * let df = ...\n * \n * df = df.remove(['a', 'toto'])\n * ```\n * @category DataFrame\n */\nexport const remove = (dataframe: DataFrame, series: string | string[]): DataFrame => {\n    return dataframe.remove(series)\n}\n\n/**\n * @category Base\n */\nexport class DataFrame {\n\n    /**\n     * Mapping between column id and serie\n     */\n    public readonly series: { [key: string]: Serie }\n\n    /**\n     * Convenient method to iterate over all series\n     * @example\n     * ```ts\n     * const df = DataFrame.create({\n     *      series: {\n     *          a: ...,\n     *          b: ...,\n     *      }\n     * })\n     * \n     * df.forEach( (name, serie, i) => {\n     *      console.log('serie named', name, \n     *                  'at index', i, \n     *                  ', count=', serie.count, \n     *                  ', itemSize=', serie.itemSize\n     *      )\n     * })\n     * ```\n     */\n    public forEach(cb: Function) {\n        Object.entries(this.series).forEach(([name, serie], i) => cb(name, serie, i))\n    }\n\n    /**\n     * If provided, the column that acts as index\n     */\n    public readonly index: string | undefined = undefined\n\n    /**\n     * \n     * Mutable dictionary to store consumer data (context information of the usage)\n     */\n    public userData: { [key: string]: any } = {}\n\n    /**\n     * \n     * Dictionary to store metadata (context information of the dataframe's creation)\n     */\n    public readonly metaData: { [key: string]: any } = {}\n\n    private constructor(\n        series: { [key: string]: Serie },\n        index: string,\n        userData: { [key: string]: any },\n        metaData: { [key: string]: any }\n    ) {\n        this.series = series\n        this.index = index\n        this.userData = userData\n        this.metaData = metaData\n    }\n\n    /**\n     * Check if the serie named name is in the dataframe\n     * @param name \n     */\n    contains(name: string) {\n        return this.series[name] !== undefined\n    }\n\n    /**\n     * The dataframe class which contains a list of {@link Serie}\n     * @example\n     * ```ts\n     * const df = DataFrame.create({\n     *     series: {\n     *          a: createEmptySerie({\n     *              Type: Float32Array, count:2, itemSize:3, shared: true\n     *          }),\n     *          b: createEmptySerie({\n     *              Type: Float64Array, count:2, itemSize:3, shared: false\n     *          }),\n     *          c: createSerie({data: [0,1,2,3,4,5,6,7,8,9], itemSize: 5}),\n     *          d: createSerie({data: [0,1,2,3,4,5,6,7,8,9], itemSize: 5}),\n     *     }\n     * })\n     * ```\n     * @category DataFrame\n     */\n    static create(\n        { series, userData, metaData, index }: {\n            series: { [key: string]: Serie },\n            index?: string,\n            userData?: { [key: string]: any },\n            metaData?: { [key: string]: any }\n        }): DataFrame {\n        return new DataFrame(series, index, userData || {}, metaData || {})\n    }\n\n    /**\n     * Remove a serie or a list of series (given by their name) from this dataframe.\n     * @param serieName \n     * @returns A new {@link Dataframe} even if no modification\n     * @example\n     * ```ts\n     * let df = ...\n     * \n     * df = df.remove(['a', 'toto'])\n     * ```\n     */\n    remove(serieName: string | string[]): DataFrame {\n        const df = this.clone()\n\n        if (Array.isArray(serieName)) {\n            serieName.forEach(name => {\n                if (df.series.hasOwnProperty(name)) {\n                    delete df.series[name]\n                }\n            })\n        }\n        else {\n            if (df.series.hasOwnProperty(serieName)) {\n                delete df.series[serieName]\n            }\n        }\n        return df\n    }\n\n    clone() {\n        return new DataFrame(this.series, this.index, this.userData, this.metaData)\n    }\n}\n","import { IArray, Serie } from \"../serie\"\n\n/**\n * Create an Array of a given length and with an initial value set\n * for all entries\n * @param length The length of the array\n * @param init A function that has to be called for initialization, a number, or nothing\n * @example\n * ```ts\n * const array1 = create(100, i => i**2)\n * const array2 = create(100, 0)\n * const array3 = create(100)\n * ```\n * @category Creation\n */\nexport function createArray(length: number, init?: Function | number ) {\n    if (init === undefined) return new Array(length).fill(undefined)\n    if (init instanceof Function) {\n        return new Array(length).fill(undefined).map( (_,i) => init(i) )\n    }\n    return new Array(length).fill(init)\n}\n\n/**\n * Create a TypedArray of a given length (number of entries) that can be shared or not.\n * The length is either provided directly, or by an array that will be used to\n * initialize the type array.\n * @param Type The type of the array:\n * <ul>\n * <li>Int8Array\n * <li>Uint8Array\n * <li>Uint8ClampedArray\n * <li>Int16Array\n * <li>Uint16Array\n * <li>Int32Array\n * <li>Uint32Array\n * <li>Float32Array\n * <li>Float64Array\n * <li>BigInt64Array\n * <li>BigUint64Array\n * </ul>\n * @param data The number of entries or an array of number\n * @param shared If the Typed has SharedArrayBuffer or not\n * @example\n * ```ts\n * const sharedArray = createTyped(Float32Array, 100, true)\n * const array       = createTyped(Float32Array, [1,2,3,4,5,6,7,8,9], false)\n * ```\n * @category Creation\n */\nexport function createTyped<T extends IArray = IArray>(Type: any, array: number|number[], shared: boolean\n    ) : T {\n    if (Array.isArray(array)) {\n        const length = array.length*Type.BYTES_PER_ELEMENT\n        let ta = undefined\n\n        let isSharedAvailable = (typeof SharedArrayBuffer !== \"undefined\")\n\n        if (shared && isSharedAvailable) {\n            ta = new Type(new SharedArrayBuffer(length))\n        }\n        else {\n            ta = new Type(new ArrayBuffer(length))\n        }\n        ta.set(array)\n        return ta\n    }\n    else {\n        const l = array*Type.BYTES_PER_ELEMENT\n        if (shared) {\n            return new Type(new SharedArrayBuffer(l))\n        }\n        return new Type(new ArrayBuffer(l))\n    }\n}\n\n/**\n * Create a serie from scratch given a type (Array or TypedArray) and a rowsCount.\n * Passed parameters are:\n * ```ts\n * {\n *      Type, // Can be either an Array or a TypedArray.\n *      count, // The number of elements in the array\n *      itemSize, // The size of each items (length of the array will be rowsCount*itemSize)\n *      shared // If the TypedArray should be a SharedArrayBuffer or an ArrayBuffer\n * }\n * ```\n * @returns The newly created Serie\n * @category Creation\n */\nexport function createEmptySerie(\n    {Type, count, itemSize=1, dimension=3, shared=false, userData}:\n    {Type?:any, count: number, itemSize?: number, dimension?: number, shared?: boolean, userData?:{[key:string]: any}} // ! use dimension\n    ) : Serie\n{\n    if (itemSize<=0)  throw new Error('itemSize must be > 0')\n    if (count<=0) throw new Error('count must be > 0')\n\n    if (Type===undefined || Array.isArray( new Type(1) )) {\n        return Serie.create({\n            array: new Array(count*itemSize).fill(0), \n            itemSize\n        })\n    }\n\n    // Type is either a Int8Array, Uint8Array etc...\n    const length = count*itemSize*Type.BYTES_PER_ELEMENT\n    if (shared) {\n        return Serie.create({\n            array: new Type(new SharedArrayBuffer(length)), itemSize, userData, dimension})\n    }\n    return Serie.create({ array:new Type(new ArrayBuffer(length)), itemSize, userData, dimension})\n}\n","import { createTyped } from \"./utils/create\"\n\n/** Interface for supported array in {@link Serie}:\n * -    Array\n * -    TypedArray with either shared or not buffer\n */\nexport interface IArray {\n    readonly length: number\n    [i: number]: number\n    map(cb: Function): IArray\n    forEach(cb: Function): void\n    slice(start: number, end: number): IArray\n    fill(n: number): IArray\n    reduce<U>(\n        callback: (previousValue: number, currentValue: number, currentIndex: number, array: IArray) => number,\n        firstState?: U\n    ): U\n    filter(cb: Function): IArray\n    sort(fn: Function): IArray\n}\n\n/**\n * T is either an Array, or a TypedArray (Float32Array etc...) supported by an\n * ArrayBuffer or SharedArrayBuffer\n * @category Base\n */\nexport class Serie<T extends IArray = IArray> {\n\n    /**\n     * The underlying array of the serie\n     */\n    public readonly array: T\n\n    /**\n     * The itemSize is the dimension of one 'cell' of the serie\n     */\n    public readonly itemSize: number\n\n    /**\n     * The dimension of the space. As an example, for a numerical code\n     * computing stresses and/or displacement fields, in 3D the dimension\n     * will be 3 and in 2D the dimension will be 2. It is the user\n     * responsability to properly set this value.\n     */\n    public readonly dimension: number = 3\n\n    /**\n     * Whether or not {@link array} is a SharedArrayBuffer\n     */\n    public readonly shared: boolean\n\n    /**\n     * \n     * Mutable dictionary to store consumer data (context information of the usage)\n     */\n    public userData: { [key: string]: any } = {}\n\n    private constructor(\n        array: T,\n        itemSize: number,\n        shared: boolean,\n        userData: { [key: string]: any } = {},\n        dimension: number = 3\n    ) {\n\n        if (array.length % itemSize !== 0)\n            throw new Error(`array length (${array.length}) is not a multiple of itemSize (${itemSize})`)\n        this.array = array\n        this.itemSize = itemSize\n        this.shared = shared\n        this.userData = userData\n        this.dimension = dimension // ! use dimension\n    }\n\n    static isSerie(s: any): boolean {\n        return 'array' in s && 'itemSize' in s\n    }\n\n    /**\n     * \n     * @param array The array of values. Can be either an instance of Array or a TypedArray.\n     * For TypeArray, the underlaying buffer can be either of type ArrayBuffer or\n     * SharedArrayBuffer\n     * @param itemSize The size of each item. {@link count} will be array.length / {@link itemSize}\n     * @param userData user data\n     */\n    static create<T extends IArray = IArray>(\n        {\n            array, itemSize, userData, dimension = 3 // ! use dimension\n        }:\n            {\n                array: T, itemSize: number, userData?: { [key: string]: any }, dimension?: number\n            }\n    ) {\n        // Type is either a Int8Array, Uint8Array etc...\n\n        if (itemSize <= 0) throw new Error('itemSize must be > 0')\n        if (array === undefined) throw new Error('array must be provided')\n\n        // Check that SharedArrayBuffer are supported...\n        if (typeof SharedArrayBuffer === \"undefined\") {\n            return new Serie(array, itemSize, false, userData, dimension) // ! use dimension\n        }\n\n        const shared = (array as any).buffer instanceof SharedArrayBuffer\n        return new Serie(array, itemSize, shared, userData, dimension) // ! use dimension\n    }\n    /**\n     * Get the size of this serie, i.e., being {@link count} * {@link itemSize}\n     */\n    get length() {\n        return this.array.length\n    }\n\n    /**\n     * Get the number of items (an item being of size {@link itemCount})\n     */\n    get count() {\n        return this.array.length / this.itemSize\n    }\n\n    /**\n     * True if this serie is an Array<number\n     */\n    get isArray() {\n        return Array.isArray(this.array)\n    }\n\n    /**\n     * True if this serie is a TypedArray\n     * @see isTypedArray\n     */\n    get isArrayBuffer() {\n        return this.isTypedArray\n    }\n\n    /**\n     * True if this serie is a TypedArray\n     * @see isArrayBuffer\n     */\n    get isTypedArray() {\n        return !this.isArray\n    }\n\n    /**\n     * True if this serie is the buffer of the TypedArray is\n     * a SharedArrayBuffer\n     */\n    get isShared() {\n        if (this.isArray) return false\n        return (this.array as any).buffer instanceof SharedArrayBuffer\n    }\n\n    at(i: number) {\n        return this.array[i]\n    }\n\n    itemAt(i: number): number | number[] {\n        const size = this.itemSize\n        if (size === 1) return this.at(i)\n        const start = i * size\n        const r = new Array(size).fill(0)\n        for (let j = 0; j < size; ++j) r[j] = this.array[start + j]\n        return r\n    }\n\n    setItemAt(i: number, value: number | IArray): void {\n        if (i >= this.count) throw new Error('array index out of bounds')\n\n        const size = this.itemSize\n\n        if (size === 1) {\n            if (Array.isArray(value)) throw new Error('value must be a number')\n            this.array[i] = value as number\n            return\n        }\n\n        const v = value as number[]\n        if (v.length !== size) throw new Error(`array length (${v.length}) must equals itemSize (${size})`)\n        for (let j = 0; j < size; ++j) {\n            this.array[i * size + j] = value[j]\n        }\n    }\n\n    /**\n     * Iterate over all items\n     * @param callback The callback that will called for each item\n     */\n    forEach(callback: Function) {\n        for (let i = 0; i < this.count; ++i) {\n            callback(this.itemAt(i), i, this)\n        }\n    }\n\n    /**\n     * Map the items\n     */\n    map(callback: Function) {\n        const tmp = callback(this.itemAt(0), 0, this)\n\n        const itemSize = (Array.isArray(tmp) ? tmp.length : 1)\n        const R = this.image(this.count, itemSize)\n\n        let id = 0\n        for (let i = 0; i < this.count; ++i) {\n            const r = callback(this.itemAt(i), i, this)\n            if (itemSize === 1) {\n                R.array[id++] = r\n            }\n            else {\n                for (let j = 0; j < itemSize; ++j) {\n                    R.array[id++] = r[j]\n                }\n            }\n        }\n        return R\n    }\n\n    /**\n     * Reduce each item\n     */\n    // reduce(callback: Function, accumulator: number|number[]) {\n    //     if (this.itemSize === 1) {\n    //         return this.array.reduce(callback as any, accumulator)\n    //     }\n    //     // for (let i of iterable) {\n    //     //     accumulator = reduceFn(accumulator, i)\n    //     // }\n    //     // return accumulator\n    //\n    //     const R = this.image(this.count, this.itemSize)\n    //     let id = 0\n    //     for (let i=0; i<this.count; ++i) {\n    //         const r = callback(this.itemAt(i), i, this)\n    //         for (let j=0; j<this.itemSize; ++j) {\n    //             R.array[id++] = r[j]\n    //         }\n    //     }\n    //     return R\n    // }\n\n    /**\n     * Return a new serie similar to this (same type of array and buffer), and with\n     * the same count and itemSize.\n     * @param resetValues True if reset the values to 0, false otherwise (default)\n     * @see newInstance\n     * @see image\n     */\n    clone(resetValues: boolean = false) {\n        const s = new Serie(this.array.slice(0, this.count * this.itemSize), this.itemSize, this.shared, this.userData, this.dimension) // ! use dimension\n        if (resetValues) {\n            s.array.forEach((_, i) => s.array[i] = 0) // reset\n        }\n        return s\n    }\n\n    /**\n     * Same as {@link image}. All values are set to 0 (i.e., 0, [0,0], [0,0,0]...)\n     * @see clone\n     * @see image\n     */\n    newInstance({ count, itemSize, initialize = true }: { count: number, itemSize: number, initialize?: boolean }) {\n        const s = new Serie(createFrom({ array: this.array, count, itemSize }), itemSize, this.shared, this.userData, this.dimension) // ! use dimension\n        if (initialize) {\n            for (let i = 0; i < s.array.length; ++i) s.array[i] = 0\n        }\n        return s\n    }\n\n    /**\n     * Return a new serie similar to this (same type of array and buffer), but with\n     * different count and itemSize. All values are initialized to 0. We keep this\n     * mathod for compatibility reason.\n     * @param count    The number of items \n     * @param itemSize The size of the items\n     * @see clone\n     * @see newInstance\n     */\n    image(count: number, itemSize: number) {\n        return this.newInstance({ count, itemSize })\n    }\n}\n\n// --------------------------------------------------\n\n/**\n * @category Creation\n */\nexport function createFrom<T extends IArray>(\n    { array, count, itemSize }:\n        { array: T, count: number, itemSize: number }): IArray {\n\n    const length = count * itemSize\n\n    if (Array.isArray(array)) {\n        return new Array(length)\n    }\n\n    let isShared = false\n    if (typeof SharedArrayBuffer !== \"undefined\") {\n        isShared = (array as any).buffer instanceof SharedArrayBuffer\n    }\n\n\n    if (array instanceof Int8Array) return createTyped(Int8Array, length, isShared)\n    if (array instanceof Uint8Array) return createTyped(Uint8Array, length, isShared)\n    if (array instanceof Uint8ClampedArray) return createTyped(Uint8ClampedArray, length, isShared)\n    if (array instanceof Int16Array) return createTyped(Int16Array, length, isShared)\n    if (array instanceof Uint16Array) return createTyped(Uint16Array, length, isShared)\n    if (array instanceof Int32Array) return createTyped(Int32Array, length, isShared)\n    if (array instanceof Uint32Array) return createTyped(Uint32Array, length, isShared)\n    if (array instanceof Float32Array) return createTyped(Float32Array, length, isShared)\n    if (array instanceof Float64Array) return createTyped(Float64Array, length, isShared)\n    if (array instanceof BigInt64Array) return createTyped(BigInt64Array, length, isShared)\n    if (array instanceof BigUint64Array) return createTyped(BigUint64Array, length, isShared)\n}\n","import { Serie } from '../serie'\n\n/**\n * map a [[Serie]] onto another one using a map function.\n * @note Operations are done using the items\n * @example\n * ```ts\n * const s1 = createSerie( {data: createArray(12, i => i+1), itemSize: 3} )\n * s1.map( i1 => i1.map(i => i**2 ) )\n * map(s1, i1 => i1.map(i => i**2 ) )\n * \n * const s2 = createSerie( {data: createArray(12, i => i+2), itemSize: 3} )\n * console.log( map([s1, s2], ([i1, i2]) => vector(i1).dot( vector(i2) ) )\n * ```\n * @category Algorithms\n */\nexport const map = (series: Serie | Serie[], cb: Function) => {\n    if (Array.isArray(series)) {\n        let R: Serie = undefined\n        let isArray   = true\n        let id        = 0\n\n        const count   = series[0].count\n        const args    = new Array<number[]|number>(series.length)\n\n        for (let i=0; i<count; ++i) {\n            for (let j=0; j<series.length; ++j) {\n                args[j] = series[j].itemAt(i)\n            }\n\n            const r = cb(args)\n            if (R === undefined) {\n                isArray = Array.isArray(r)\n                R = series[0].image(count, isArray ? r.length : 1 )\n            }\n\n            if (isArray) {\n                r.forEach( v => R.array[id++] = v)\n            }\n            else {\n                R.array[id++] = r\n            }\n        }\n\n        return R\n    }\n\n    return series.map(cb)\n}\n","import { Serie } from '../serie'\n\n/**\n * filter a [[Serie]] using a predicate function.\n * @note Operations are done using the items\n * @example\n * ```js\n * const a = filter( df.series.a, v => v < 10 )\n * ```\n * @category Algorithms\n */\nexport const filter = (s: Serie, predicate: Function) => {\n    if (s===undefined) throw new Error ('serie is undefined')\n\n    const count = s.count\n    const r = []\n\n    for (let i=0; i<count; ++i) {\n        const v = s.itemAt(i)\n        if (predicate( v, i, s )) r.push(v)\n    }\n\n    // const rr = createFrom(s.array, r.length/s.itemSize, s.itemSize)\n    const rr  = s.array.slice(0, r.length)\n    r.forEach( (v,i) => rr[i] = v )\n    \n    return Serie.create({array: rr, itemSize: s.itemSize})\n}\n","import { Serie } from '../serie'\n\n/**\n * @note Operations are done using the items\n * @example\n * ```ts\n * const s1 = createSerie( {data: createArray(12, i => i+1), itemSize: 3} )\n * s1.forEach( i1 => console.log(i1) )\n * forEach(s1, i1 => console.log(i1) )\n * \n * const s2 = createSerie( {data: createArray(12, i => i+2), itemSize: 3} )\n * forEach([s1,s2], ([i1, i2]) => console.log(i1, i2) )\n * ```\n * @category Algorithms\n */\nexport const forEach = (series: Serie | Serie[], callback: Function) => {\n    if (series===undefined) throw new Error ('serie is undefined')\n\n    if ( !Array.isArray(series) ) {\n        for (let i=0; i<series.count; ++i) {\n            callback( series.itemAt(i), i, series )\n        }\n        return\n    }\n\n    let count = series[0].count\n    for (let i=0; i<count; ++i) {\n        callback( series.map( serie => serie.itemAt(i) ), i, series)\n    }\n}\n","import { Serie } from '../serie'\n\n/*\nOur goal is to return a Serie or whatever:\n```js\n// sa and sb are Series with itemSize=3\n//\nconst x = reduce([sa, sb], (cur, [sa, sb]) => cur + sa[0]*sb[0], 0)\nconst y = reduce([sa, sb], (cur, [sa, sb]) => [cur[0]+sa[0]*sb[0], cur[1]+sa[1]*sb[1], cur[2]+sa[2]*sb[2]], [0,0,0])\n```\n*/\n\n/**\n * @returns a new [[Serie]]\n * @example\n * ```ts\n * const A = df.get('A')\n * const y = df.get('y')\n * const reduced = reduce([A,y], ([m,x]) => {\n *     let vec = vector(x)\n *     let mat = smatrix(m, 3, 3) // sym matrix rank 2\n *     return mat.transpose().multVec( vector(vec).normalize() ).array\n * })\n * \n * const c = reduce([sa, sb], (cur, [sa, sb]) => cur + sa[0]*sb[0], 0)\n * const d = reduce([sa, sb], (cur, [sa, sb]) => [cur[0]+sa[0]*sb[0], cur[1]+sa[1]*sb[1], cur[2]+sa[2]*sb[2]], [0,0,0])\n * ```\n * @category Algorithms\n */\nexport const reduce = function(iterable: Serie | Serie[], reduceFn: Function, accumulator: any) {\n    if ( !Array.isArray(iterable) ) {\n        iterable.forEach( i => accumulator = reduceFn(accumulator, i) )\n        return accumulator\n    }\n    else {\n        const count = iterable[0].count\n        for (let i=0; i<count; ++i) {\n            accumulator = reduceFn( accumulator, iterable.map( serie => serie.itemAt(i) ) ) //, i, iterable)\n        }\n\n        // iterable.map( (serie, i) => serie.forEach( j => accumulator[i] = reduceFn(accumulator[i], j) ) )\n\n        return accumulator\n    }\n}\n  \n\n/*\nexport const reduce = (series: Serie | Serie[], callback: Function) => {\n    if (Serie.isSerie(series)) {\n        const S = series as Serie\n        const count = S.count\n        const r = S.image(count, 1)\n        \n        for (let i=0; i<count; ++i) {\n            const v = S.itemAt(i)\n            r.array[i] = callback(S.itemAt(i), i, series)\n        }\n\n        return r\n    }\n\n    // Assert all series have the same nbr of element (count)\n    const n     = series.length\n    const count = series[0].count\n\n    series.forEach( s => {\n        if (s.count !== count) throw new Error('All series must have the same nbr of elements (count)')\n    })\n\n    let R: Serie = undefined\n    const args = new Array<number[]|number>(n)//.fill([])\n    let isArray = true\n    let id = 0\n    for (let i=0; i<count; ++i) {\n        for (let j=0; j<n; ++j) {\n            args[j] = series[j].itemAt(i)\n        }\n\n        const r = callback(args)\n        \n        if (R === undefined) {\n            isArray = Array.isArray(r)\n            // TODO: deal with Float32Array, count and itemSize by default !!!\n            //R = createEmptySerie({Type: Float32Array, count, itemSize: r.length})\n            R = series[0].image( count, (isArray?r.length:1) )\n        }\n        if (isArray) {\n            r.forEach( v => R.array[id++] = v)\n        }\n        else {\n            R.array[id++] = r\n        }\n    }\n\n    return R\n}\n*/","import { Serie } from \"../serie\"\n\n/**\n * Apply a function to a serie. The function signature is\n * `fn(item: number|number[], index: number, serie: Serie)`\n * @note Operations are done using the items\n * @example\n * ```ts\n * const s1 = createSerie( {data: [1, 2, 3, 4, 5, 6]} ) // itemSize=1\n * const s2 = apply(s1, item => item**2 )\n * \n * // s1.array: [1, 2, 3,  4,  5,  6]\n * // s2.array: [1, 4, 9, 16, 25, 36]\n * ```\n * @example\n * ```ts\n * const s1 = createSerie( {data: [1, 2, 3, 4, 5, 6]}, itemSize: 3 )\n * const s2 = apply(s1, item => item.map( v => v**2) )\n * \n * // s1.array: [1, 2, 3,  4,  5,  6]\n * // s2.array: [1, 4, 9, 16, 25, 36]\n * ```\n * @category Algorithms\n */\nexport const apply = (serie: Serie, fn: Function): Serie => {\n    return serie.map( (item, i) => fn(item, i, serie) )\n}\n","import { Serie } from \"../serie\"\n\n/**\n * Sort a [[Serie]] for which itemSize = 1\n * @category Algorithms\n */\nexport const sort = (serie: Serie, fn: Function = (a,b)=>(a-b)): Serie => {\n    if (serie.itemSize !== 1) throw new Error('sort algorithm: itemSize must be 1')\n    const s = serie.clone(false)\n    s.array.sort(fn)\n    return s\n}\n","import { Serie } from '../serie'\nimport { filter } from './filter'\n\n/**\n * Cut a [[Serie]] using a predicate function. It is essentially the same as [[filter]]\n * @see filter\n * @category Algorithms\n */\nexport const cut = (s: Serie, callback: Function) => {\n    if (s===undefined) throw new Error ('serie is undefined')\n    if (s.itemSize !== 1) throw new Error ('serie should have itemSize = 1')\n\n    return filter(s, callback)\n}\n","import { DataFrame } from '../dataframe'\n\n/**\n * Check if a TypedArray exist in the DataFrame\n * @category Utils\n */\nexport const exists = (df: DataFrame, name: string) => df.series[name] !== undefined\n","import { DataFrame } from '../dataframe'\nimport { IArray, Serie } from '../serie'\n\n/**\n * @category Utils\n */\nexport const info = (df: DataFrame | Serie): any => {\n    if (Serie.isSerie(df)) {\n        const s = df as Serie\n        return {\n            isArray: s.isArray,\n            isBuffer: s.isArrayBuffer,\n            isShared: s.shared,\n            length: s.length,\n            count: s.count,\n            itemSize: s.itemSize,\n            dimension: s.dimension,\n            array: s.array\n        }\n    }\n\n    const DF = df as DataFrame\n    \n    return {\n        userData: DF.userData,\n        series: Object.entries(DF.series).map( ([name, serie]) =>  {\n            return {\n                name,\n                userData: serie.userData,\n                isArray: serie.isArray,\n                isBuffer: serie.isArrayBuffer,\n                isShared: serie.shared,\n                length: serie.length,\n                count: serie.count,\n                itemSize: serie.itemSize,\n                dimension: serie.dimension,\n                array: serie.array\n            }\n        })\n    }\n}","import { IArray } from \"../serie\"\n\n/**\n * @hidden\n */\nexport namespace array {\n\n    // export function zip(a1: IArray, a2: IArray): any {\n\n    // }\n\n    /**\n     * @category Array\n     */\n    export function min(array: IArray): number {\n        let m = Number.POSITIVE_INFINITY\n        const n = array.length\n        for (let i=0; i<n; ++i) {\n            const a = array[i]\n            if (a < m) m = a\n        }\n        return m\n    }\n\n    /**\n     * @category Array\n     */\n    export function max(array: IArray): number {\n        let m = Number.NEGATIVE_INFINITY\n        const n = array.length\n        for (let i=0; i<n; ++i) {\n            const a = array[i]\n            if (a > m) m = a\n        }\n        return m\n    }\n\n    /**\n     * @category Array\n     */\n    export function minMax(array: IArray): Array<number> {\n        let m = Number.POSITIVE_INFINITY\n        let M = Number.NEGATIVE_INFINITY\n        const n = array.length\n        for (let i=0; i<n; ++i) {\n            const a = array[i]\n            if (a < m) m = a\n            if (a > M) M = a\n        }\n        return [m, M]\n    }\n\n    /**\n     * @category Array\n     */\n    export function normalize(array: IArray): IArray {\n        const m = minMax(array)\n        return array.map( v => (v-m[0])/(m[1]-m[0]) )\n    }\n\n    /**\n     * @category Array\n     */\n    export function scale(array: IArray, s: number): IArray {\n        return array.map( v => v*s )\n    }\n\n    /**\n     *  Return the indices from array that contain NaN values\n     * @param array The array of number\n     * @category Array\n     */\n    export function dectectNan(array: IArray): IArray {\n        const values = array.map( (value,i) => {return {value, i}})\n        const idx = values.filter( a => Number.isNaN(a.value))\n        return idx.map( v => v.i)\n    }\n\n    /**\n     * @category Array\n     */\n    export function flatten(array: Array<Array<number>>): Array<number> {\n        const r: Array<number> = []\n        array.forEach( a => r.push(...a) )\n        return r\n    }\n}\n","import { IArray, Serie } from \"../serie\";\n\n/**\n * @return the same serie\n * @category Utils\n */\nexport const copy = (array: Serie| IArray, serie: Serie) => {\n    if (Serie.isSerie(array)) {\n        const S = array as Serie\n        if (serie.array.length !== S.array.length) throw new Error('length mismatch for both series')\n        S.array.forEach( (v,i) => serie.array[i] = v )\n    }\n    else {\n        if (serie.array.length !== array.length) throw new Error('Array and Serie length mismatch')\n        array.forEach( (v,i) => serie.array[i] = v )\n    }\n    return serie\n}\n","import { Serie } from \"../serie\";\n\n/**\n * Return a duplicate of the passed serie (same type, same count, same itemSize and same values)\n * @category Utils\n */\nexport const duplicate = (serie: Serie): Serie => {\n    return serie.clone(false)\n}\n","import { DataFrame } from '../dataframe'\nimport { Serie } from '../serie'\n\n/**\n * Get the name of a [[Serie]] in a [[Dataframe]]. Returns undefined if the serie in not present\n * in the passed [[Dataframe]]\n * @category Utils\n */\nexport const nameOfSerie = (df: DataFrame, s: Serie) => {\n    return Object.entries(df.series).reduce( (acc, [name, serie]) => s === serie ? name : acc, undefined)\n}\n","import { DataFrame } from '../dataframe'\n\n/**\n * Get name of all series in the passed [[DataFrame]]\n * @category Utils\n */\nexport const getNameSeries = (df: DataFrame) => {\n    return Object.entries(df.series).map(([name, serie]) => name)\n}\n","\n/**\n * @brief Create a new [[Vector]]\n * @category Views\n */\nexport const vector = (v: number[]) => new Vector(v)\n\n/**\n * @category Views\n */\nexport class Vector {\n    constructor(private v: number[]) {\n    }\n\n    at(i: number) {\n        return this.v[i]\n    }\n\n    get length() {\n        return this.v.length\n    }\n\n    get array() {\n        return this.v\n    }\n\n    /**\n     * Normalize this vector\n     * @returns this\n     */\n    normalize() {\n        const n = this.norm()\n        this.v = this.v.map( v => v/n )\n        return this\n    }\n\n    norm() {\n        return Math.sqrt(this.v.reduce( (acc, v) => acc + v**2, 0))\n    }\n\n    /**\n     * \n     * @param s scaling parameter\n     * @returns this vector\n     */\n    mult(s: number) {\n        this.v = this.v.map( v => v*s )\n        return this\n    }\n\n    add(s: Vector) {\n        this.v = s.v.map( (w,i) => this.v[i] += w )\n        return this\n    }\n\n    sub(s: Vector) {\n        this.v = s.v.map( (w,i) => this.v[i] -= w )\n        return this\n    }\n\n    dot(v: Vector) {\n        return this.array.reduce( (acc, a, i) => acc + a*v.array[i], 0 )\n    }\n\n    toString() {\n        let s = ''\n        for (let i=0; i<this.length; ++i) {\n            s += this.at(i) + '\\t'\n        }\n        return s\n    }\n}\n","import { Vector } from \"./vector\"\n\n/**\n * It can be demonstrated that n(n+1)/2 = n^2 for n in N*, if and only if n=1.\n * That is to say, they's no ambiguity about the length of the passed flatten array\n * to determine if it is a bad, a symmetric or a full matrix\n * ```ts\n * const m = array.length\n * const m1 = Math.sqrt(m)\n * const m2 = (Math.sqrt(8*v.length+1)-1)/2\n * ```\n */\n\n/**\n * Equivalent to [[squaredMatrix]]\n * @param v \n * @category Views\n */\nexport const matrix = (v: number[]) => squaredMatrix(v)\n\n/**\n * @brief Create a new squared [[Matrix]]\n * @category Views\n */\nexport const squaredMatrix = (v: number[]) => {\n    const m = Math.sqrt(v.length)\n    if (!Number.isInteger(m)) throw new Error(`squared matrix requires m*m coefficients (got m=${v.length})`)\n    return new Matrix(v, m)\n}\n\n/**\n * @brief Create a new squared symmetric [[Matrix]]\n * @category Views\n */\n export const symSquaredMatrix = (v: number[]) => {\n    const m = (Math.sqrt(8*v.length+1)-1)/2\n    if (!Number.isInteger(m)) throw new Error(`symmetric squared matrix of dim m requires (m*(m+1)/2) coefficients (got ${v.length}`)\n\n    const index = (i:number,j:number) => i * m + j\n    const indexS = (i:number,j:number) => j<i ? 0.5 * j * (2 * m - 1 - j) + i : 0.5 * i * (2 * m - 1 - i) + j\n    \n    const w = new Array(m*m).fill(0)\n    for (let i=0; i<m; ++i) {\n        for (let j=0; j<m; ++j) {\n            w[ index(j,i) ] = v[ indexS(i,j) ]\n        }\n    }\n    const M = new Matrix(w, m)\n    return M\n}\n\n/**\n * Full matrix of dim (m x m)\n * @category Views\n */\nexport class Matrix {\n\n    constructor(protected v: number[], readonly m: number) {\n    }\n\n    index(i: number, j: number) {\n        return i * this.m + j\n    }\n\n    get isSymmetric() {\n        let ok = true\n        for (let i=0; i<this.m; ++i) {\n            for (let j=i; j<this.m; ++j) {\n                ok = ok && (this.at(i,j) === this.at(j,i))\n            }\n        }\n        return ok\n    }\n\n    copy() {\n        return new Matrix([...this.v], this.m)\n    }\n\n    at(i: number, j: number) {\n        return this.v[ this.index(i,j) ]\n    }\n\n    trace() {\n        let t = 0\n        for (let i=0; i<this.m; ++i) t += this.at(i,i)\n        return t\n    }\n    \n    set(i: number, j: number, v: number) {\n        this.v[ this.index(i, j) ] = v\n        return this\n    }\n\n    add(i: number, j: number, v: number) {\n        this.v[ this.index(i, j) ] += v\n        return this\n    }\n\n    /**\n     * Scale this matrix\n     * @returns this\n     */\n    scale(s: number) {\n        this.v = this.v.map( v => v*s )\n        return this\n    }\n\n    get length() {\n        return this.v.length\n    }\n\n    /**\n     * Return a copy of the underlaying array (flatten components). If the matrix\n     * is symmetric, a compressed array is returned.\n     */\n    get array() {\n        if (this.isSymmetric) {\n            const a = new Array( this.m*(this.m+1)/2 ).fill(0)\n            let k = 0\n            for (let i=0; i<this.m; ++i) {\n                for (let j=i; j<this.m; ++j) {\n                    a[k++] = this.at(i,j)\n                }\n            }\n            return a\n        }\n        return [...this.v]\n    }\n\n    /**\n     * Transpose this matrix and return a new one\n     * @returns a new [[Matrix]]\n     */\n    transpose() {\n        const v = new Array(this.v.length).fill(0)\n        let id = 0\n        for (let j=0; j<this.m; ++j) {\n            for (let i=0; i<this.m; ++i) {\n                v[id++] = this.at(i,j)\n            }\n        }\n        return new Matrix(v, this.m)\n    }\n\n    /**\n     * @returns a new [[Vector]]\n     */\n    multVec(v: Vector | number[]): Vector {\n        if (v.length !== this.m) throw new Error('size mismatch for product matrix vector')\n        const t = new Array(v.length).fill(0)\n\n        const a = (v instanceof Vector ? v.array : v)\n        for (let i=0; i<this.m; ++i) {\n            for (let j=0; j<this.m; ++j) {\n                t[i] += this.at(i,j) * a[j]\n            }\n        }\n        return new Vector(t)\n    }\n\n    /**\n     * @returns a new [[Matrix]]\n     */\n    multMat(m: Matrix): Matrix {\n        if (m.m !== this.m) throw new Error('size mismatch for product matrix matrix')\n        const t = new Array(m.length).fill(0)\n\n        for (let i=0; i<this.m; ++i) {\n            for (let j=0; j<this.m; ++j) {\n                for (let k=0; k<this.m; ++k) {\n                    t[ this.index(i,j) ] += this.at(i,k) * m.at(k,j)\n                }\n            }\n        }\n\n        return new Matrix(t, this.m)\n    }\n\n    /**\n     * Add a new matrix to this (element-wise)\n     * @returns this\n     */\n    addMat(m: Matrix) {\n        if (m.m !== this.m) throw new Error('sizes mismatch for adding matrix')\n\n        for (let i=0; i<this.v.length; ++i) {\n            this.v[i] += m.v[i]\n        }\n\n        return this\n    }\n\n    toString() {\n        let s = ''\n        for (let i=0; i<this.m; ++i) {\n            for (let j=0; j<this.m; ++j) {\n                s += this.at(i,j) + '\\t'\n            }\n            s += '\\n'\n        }\n        return s\n    }\n}\n","import { Serie } from \"../serie\"\n\n/**\n * @category Conditional\n */\nexport const isNaN = (a: Serie) => {\n    if (a.itemSize===1) {\n        return a.map( v => Number.isNaN(v) )\n    }\n    return a.map( v => new Array(a.itemSize).fill(0).map(w => Number.isNaN(w) ) )\n}\n","import { Serie } from \"../serie\"\n\n/**\n * @category Conditional\n */\nexport const check = (a: Serie, fn: Function) => a.map( v => fn(v) ? true : false )\n","\nimport { Serie } from \"../serie\"\n\n/**\n * \n * @param a The input serie\n * @param check The check function\n * @param True The function called when check returns true for a given item\n * @param False The function called when check returns false for a given item\n * @returns The new serie\n * @example\n * ```ts\n * _if( serie, item => item[0]<0, item => item[2]=1, item => item[2]=-1 )\n * ```\n * @category Conditional\n */\nexport const _if = (a: Serie, check: Function, True: Function, False: Function) => \n    a.map( (value,i) => check(value)===true ? True(value, i, a) : False(value, i, a) )\n","import { DataFrame, Serie } from '..'\nimport { Decomposer } from './decomposer'\n\n/**\n * Manager of (virtual or not) series.\n * \n * Allows to decompose series in other user-defined series.\n * Let say that you have a serie `W` with `itemSize=6`, meaning that items\n * are potentially components of symmetric rank 2 tensors of dimension 3.\n * Then, using this library, it is possible to get names and underlaying\n * series of decompositions. For instance, it is possible to get the components (`itemSize=1`),\n * eigen values (`itemSize=1`), eigen vectors(`itemSize=3`)... from this original `W` serie.\n * @example\n * ```ts\n * const df = DataFrame.create({\n *     series: {\n *         positions: Serie.create( {array: [1,2,3, 4,5,6], itemSize: 3} ),\n *         scalar   : Serie.create( {array: [4,9], itemSize: 1}),\n *         U        : Serie.create( {array: [6,5,4, 3,2,1], itemSize: 3} ),\n *         S        : Serie.create( {array: [10,11,12,13,14,15, 16,17,18,19,20,21], itemSize: 6} )\n *     }\n * })\n * \n * const manager = new Manager(df, {\n *      decomposers: [\n *          new PositionDecomposer,\n *          new ComponentDecomposer,\n *          new EigenValuesDecomposer,\n *          new EigenVectorsDecomposer\n *      ],\n *      dimension: 3\n * })\n * \n * const x   = manager.serie(1, 'x')   // x coordinate\n * const S1  = manager.serie(1, 'S1')  // first eigen value\n * const vS1 = manager.serie(3, 'S1')  // first eigen vector\n * const Sxx = manager.serie(1, 'Sxx') // xx component of the stress tensor\n * \n * console.log( manager.names(1) ) // display all names for itemSize = 1 // scalars\n * console.log( manager.names(3) ) // display all names for itemSize = 3 // vectors\n * ```\n * @category Decomposition\n */\nexport class Manager {\n    private ds_: Decomposer[] = []\n    public readonly dimension: number = 3\n\n    /**\n     * Two usages of the constructor for compatibility reason:\n     * \n     * - Old fashioned. By default the dimension is set to 3 and cannot be changed:\n     * ```ts\n     * const mng = new Manager(df, [\n     *     new PositionDecomposer, \n     *     new ComponentDecomposer\n     * ])\n     * ```\n     * \n     * - New way. You have to provide the dimension (no default value):\n     * ```ts\n     * const mng = new Manager(df, {\n     *     decomposers: [\n     *         new PositionDecomposer, \n     *         new ComponentDecomposer\n     *     ],\n     *     dimension: 2\n     * })\n     * ```\n     */\n    constructor(private readonly df: DataFrame, options: Decomposer[] | {decomposers: Decomposer[], dimension: number}) {\n        if (options) {\n            // For compatibility reason\n            if (Array.isArray(options)) {\n                console.warn('Deprecated ctor for Manager')\n                this.ds_ = options\n            }\n            else {\n                if (options.decomposers) this.ds_ = options.decomposers\n                if (options.dimension) this.dimension = options.dimension\n            }\n        }\n    }\n\n    /**\n     * Add a new Decomposer in this [[Manager]]\n     */\n    add(d: Decomposer) {\n        this.ds_.push(d)\n    }\n\n    /**\n     * Remove all registered decomposers from this manager\n     */\n    clear() {\n        this.ds_ = []\n    }\n\n    /**\n     * Get all possible decomposed names for a given itemSize\n     * @param itemSize \n     * @returns \n     */\n    names(itemSize: number): string[] {\n        let names = new Set<string>()\n\n        // add series with same itemSize\n        Object.entries(this.df.series).forEach( ([name, serie]) => {\n            // ! use dimension\n            if (serie.itemSize === itemSize && serie.dimension === this.dimension) {\n                // Avoid exposing directly 'positions' and 'indices'\n                // if ( !(itemSize===3 && (name==='positions'||name==='indices')) ) {\n                if ( name !== 'positions' && name !== 'indices' ) {\n                    names.add(name)\n                }\n            }\n            this.ds_.forEach( d => {\n                d.names(this.df, itemSize, serie, name).forEach( n => names.add(n) )\n            })\n        })\n        return Array.from(names)\n    }\n\n    /**\n     * Check if the attribute named name with itemSize exists in the manager\n     */\n    contains(itemSize: number, name: string): boolean {\n        const n = this.names(itemSize)\n        return n.includes(name)\n    }\n\n    /**\n     * For a given itemSize and a decomposed's name, get the corresponding serie\n     */\n    serie(itemSize: number, name: string): Serie {\n        for (let [mname, serie] of Object.entries(this.df.series)) {\n            if (serie.itemSize===itemSize && name===mname) {\n                return serie.clone(false)\n            }\n        }\n        for (let d of this.ds_) {\n            const serie = d.serie(this.df, itemSize, name)\n            if (serie) return serie\n        }\n        return undefined\n    }\n}\n","import { Serie, DataFrame } from '..'\nimport { Decomposer } from \"./decomposer\"\n\n/**\n * @category Decomposition\n */\nexport type Functional = {\n    (df: DataFrame): Serie\n}\n\n/**\n * User defined attribute based on a DataFrame\n * @example\n * ```ts\n * const mng = new Manager(df, {\n *      decomposers: [\n *          new FunctionalDecomposer(1, 'MyAttr', (df: DataFrame) => {\n *              const fct = p => p[0]**2 - p[1]***3 + Math.abs(p[2])\n *              df.get('positions').map( p => fct(p) )\n *          })\n *      ],\n *      dimension: 3\n * })\n * ```\n * @example\n * ```ts\n * const mng = new Manager(df, {\n *      decomposers: [\n *          new FunctionalDecomposer(3, 'zscaled', (df: DataFrame) => {\n *              const scale = 10\n *              df.get('positions').map( (p,i) => [p[0], p[1], p[2]*scale] )\n *          })\n *      ],\n *      dimension: 3\n * })\n * ```\n * @category Decomposition\n */\nexport class FunctionalDecomposer implements Decomposer {\n    /**\n     * \n     * @param itemSize The item size of the attribute\n     * @param name The name of the atribute\n     * @param fct The fonctional\n     * @see [[Functional]]\n     */\n    constructor(private readonly itemSize: number, private readonly name: string, private readonly fct: Functional) {\n    }\n    /**\n     * @hidden \n     */\n    names(df: DataFrame, itemSize: number, serie: Serie, name: string) {\n        if (itemSize !== this.itemSize) return []\n        \n        const s = this.fct(df)\n        if (!s) return []\n\n        return [this.name]\n    }\n    /**\n     * @hidden \n     */\n    serie(df: DataFrame, itemSize: number, name: string): Serie {\n        if (itemSize!==this.itemSize || this.name!==name) return undefined\n        return this.fct(df)//.setName(this.name)\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","merge","dfs","index","series","reduce","acc","e","userData","metaData","DataFrame","create","append","news","insertSerie","df","serie","name","names","entries","map","count","length","Error","remove","dataframe","forEach","cb","i","undefined","contains","static","serieName","clone","Array","isArray","createArray","init","fill","Function","_","createTyped","Type","array","shared","BYTES_PER_ELEMENT","ta","isSharedAvailable","SharedArrayBuffer","ArrayBuffer","set","l","createEmptySerie","itemSize","dimension","Serie","s","buffer","isArrayBuffer","isTypedArray","isShared","at","itemAt","size","start","r","j","setItemAt","v","callback","tmp","R","image","id","resetValues","slice","newInstance","initialize","createFrom","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","args","filter","predicate","push","rr","iterable","reduceFn","accumulator","apply","fn","item","sort","a","b","cut","exists","info","isSerie","isBuffer","DF","minMax","m","Number","POSITIVE_INFINITY","M","NEGATIVE_INFINITY","n","min","max","normalize","scale","dectectNan","isNaN","flatten","copy","S","duplicate","nameOfSerie","getNameSeries","vector","Vector","constructor","norm","Math","sqrt","mult","add","w","sub","dot","toString","matrix","squaredMatrix","isInteger","Matrix","symSquaredMatrix","indexS","isSymmetric","ok","trace","t","k","transpose","multVec","multMat","addMat","check","_if","True","False","Manager","options","ds_","console","warn","decomposers","d","clear","Set","from","includes","mname","FunctionalDecomposer","fct"],"sourceRoot":""}