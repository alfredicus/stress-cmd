/*! For license information please see dataframe.js.LICENSE.txt */
!function(r,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("@youwol/dataframe_APIv01",[],e):"object"==typeof exports?exports["@youwol/dataframe_APIv01"]=e():r["@youwol/dataframe_APIv01"]=e()}("undefined"!=typeof self?self:this,(()=>(()=>{"use strict";var r={d:(e,t)=>{for(var i in t)r.o(t,i)&&!r.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},o:(r,e)=>Object.prototype.hasOwnProperty.call(r,e),r:r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})}},e={};r.r(e),r.d(e,{DataFrame:()=>a,FunctionalDecomposer:()=>F,Manager:()=>j,Matrix:()=>T,Serie:()=>c,Vector:()=>x,_if:()=>P,append:()=>i,apply:()=>A,array:()=>v,check:()=>M,copy:()=>E,createArray:()=>o,createEmptySerie:()=>u,createFrom:()=>f,createTyped:()=>h,cut:()=>g,duplicate:()=>z,exists:()=>S,filter:()=>l,forEach:()=>y,getNameSeries:()=>I,info:()=>p,insertSerie:()=>n,isNaN:()=>O,map:()=>m,matrix:()=>D,merge:()=>t,nameOfSerie:()=>b,reduce:()=>d,remove:()=>s,sort:()=>w,squaredMatrix:()=>B,symSquaredMatrix:()=>_,vector:()=>N});const t=(r,e)=>{let t=r.reduce(((r,e)=>({...r,...e.series})),{}),i=r.reduce(((r,e)=>({...r,...e.userData})),{}),n=r.reduce(((r,e)=>({...r,...e.metaData})),{});return a.create({series:t,userData:i,metaData:n,index:e})},i=({series:r,index:e,metaData:t,userData:i},n)=>a.create({series:{...r,...n},index:e,metaData:t,userData:i}),n=({df:r,serie:e,name:t})=>{const i=Object.entries(r.series).map((([r,e])=>r)),n=0!==i.length?r.series[i[0]].count:0;if(0!==n&&e.count!==n)throw new Error("Provided serie count must be equal to existing series count");return r.series[t]=e,r},s=(r,e)=>r.remove(e);class a{forEach(r){Object.entries(this.series).forEach((([e,t],i)=>r(e,t,i)))}constructor(r,e,t,i){this.index=void 0,this.userData={},this.metaData={},this.series=r,this.index=e,this.userData=t,this.metaData=i}contains(r){return void 0!==this.series[r]}static create({series:r,userData:e,metaData:t,index:i}){return new a(r,i,e||{},t||{})}remove(r){const e=this.clone();return Array.isArray(r)?r.forEach((r=>{e.series.hasOwnProperty(r)&&delete e.series[r]})):e.series.hasOwnProperty(r)&&delete e.series[r],e}clone(){return new a(this.series,this.index,this.userData,this.metaData)}}function o(r,e){return void 0===e?new Array(r).fill(void 0):e instanceof Function?new Array(r).fill(void 0).map(((r,t)=>e(t))):new Array(r).fill(e)}function h(r,e,t){if(Array.isArray(e)){const i=e.length*r.BYTES_PER_ELEMENT;let n,s="undefined"!=typeof SharedArrayBuffer;return n=new r(t&&s?new SharedArrayBuffer(i):new ArrayBuffer(i)),n.set(e),n}{const i=e*r.BYTES_PER_ELEMENT;return new r(t?new SharedArrayBuffer(i):new ArrayBuffer(i))}}function u({Type:r,count:e,itemSize:t=1,dimension:i=3,shared:n=!1,userData:s}){if(t<=0)throw new Error("itemSize must be > 0");if(e<=0)throw new Error("count must be > 0");if(void 0===r||Array.isArray(new r(1)))return c.create({array:new Array(e*t).fill(0),itemSize:t});const a=e*t*r.BYTES_PER_ELEMENT;return n?c.create({array:new r(new SharedArrayBuffer(a)),itemSize:t,userData:s,dimension:i}):c.create({array:new r(new ArrayBuffer(a)),itemSize:t,userData:s,dimension:i})}class c{constructor(r,e,t,i={},n=3){if(this.dimension=3,this.userData={},r.length%e!=0)throw new Error(`array length (${r.length}) is not a multiple of itemSize (${e})`);this.array=r,this.itemSize=e,this.shared=t,this.userData=i,this.dimension=n}static isSerie(r){return"array"in r&&"itemSize"in r}static create({array:r,itemSize:e,userData:t,dimension:i=3}){if(e<=0)throw new Error("itemSize must be > 0");if(void 0===r)throw new Error("array must be provided");if("undefined"==typeof SharedArrayBuffer)return new c(r,e,!1,t,i);const n=r.buffer instanceof SharedArrayBuffer;return new c(r,e,n,t,i)}get length(){return this.array.length}get count(){return this.array.length/this.itemSize}get isArray(){return Array.isArray(this.array)}get isArrayBuffer(){return this.isTypedArray}get isTypedArray(){return!this.isArray}get isShared(){return!this.isArray&&this.array.buffer instanceof SharedArrayBuffer}at(r){return this.array[r]}itemAt(r){const e=this.itemSize;if(1===e)return this.at(r);const t=r*e,i=new Array(e).fill(0);for(let r=0;r<e;++r)i[r]=this.array[t+r];return i}setItemAt(r,e){if(r>=this.count)throw new Error("array index out of bounds");const t=this.itemSize;if(1===t){if(Array.isArray(e))throw new Error("value must be a number");return void(this.array[r]=e)}const i=e;if(i.length!==t)throw new Error(`array length (${i.length}) must equals itemSize (${t})`);for(let i=0;i<t;++i)this.array[r*t+i]=e[i]}forEach(r){for(let e=0;e<this.count;++e)r(this.itemAt(e),e,this)}map(r){const e=r(this.itemAt(0),0,this),t=Array.isArray(e)?e.length:1,i=this.image(this.count,t);let n=0;for(let e=0;e<this.count;++e){const s=r(this.itemAt(e),e,this);if(1===t)i.array[n++]=s;else for(let r=0;r<t;++r)i.array[n++]=s[r]}return i}clone(r=!1){const e=new c(this.array.slice(0,this.count*this.itemSize),this.itemSize,this.shared,this.userData,this.dimension);return r&&e.array.forEach(((r,t)=>e.array[t]=0)),e}newInstance({count:r,itemSize:e,initialize:t=!0}){const i=new c(f({array:this.array,count:r,itemSize:e}),e,this.shared,this.userData,this.dimension);if(t)for(let r=0;r<i.array.length;++r)i.array[r]=0;return i}image(r,e){return this.newInstance({count:r,itemSize:e})}}function f({array:r,count:e,itemSize:t}){const i=e*t;if(Array.isArray(r))return new Array(i);let n=!1;return"undefined"!=typeof SharedArrayBuffer&&(n=r.buffer instanceof SharedArrayBuffer),r instanceof Int8Array?h(Int8Array,i,n):r instanceof Uint8Array?h(Uint8Array,i,n):r instanceof Uint8ClampedArray?h(Uint8ClampedArray,i,n):r instanceof Int16Array?h(Int16Array,i,n):r instanceof Uint16Array?h(Uint16Array,i,n):r instanceof Int32Array?h(Int32Array,i,n):r instanceof Uint32Array?h(Uint32Array,i,n):r instanceof Float32Array?h(Float32Array,i,n):r instanceof Float64Array?h(Float64Array,i,n):r instanceof BigInt64Array?h(BigInt64Array,i,n):r instanceof BigUint64Array?h(BigUint64Array,i,n):void 0}const m=(r,e)=>{if(Array.isArray(r)){let t,i=!0,n=0;const s=r[0].count,a=new Array(r.length);for(let o=0;o<s;++o){for(let e=0;e<r.length;++e)a[e]=r[e].itemAt(o);const h=e(a);void 0===t&&(i=Array.isArray(h),t=r[0].image(s,i?h.length:1)),i?h.forEach((r=>t.array[n++]=r)):t.array[n++]=h}return t}return r.map(e)},l=(r,e)=>{if(void 0===r)throw new Error("serie is undefined");const t=r.count,i=[];for(let n=0;n<t;++n){const t=r.itemAt(n);e(t,n,r)&&i.push(t)}const n=r.array.slice(0,i.length);return i.forEach(((r,e)=>n[e]=r)),c.create({array:n,itemSize:r.itemSize})},y=(r,e)=>{if(void 0===r)throw new Error("serie is undefined");if(!Array.isArray(r)){for(let t=0;t<r.count;++t)e(r.itemAt(t),t,r);return}let t=r[0].count;for(let i=0;i<t;++i)e(r.map((r=>r.itemAt(i))),i,r)},d=function(r,e,t){if(Array.isArray(r)){const i=r[0].count;for(let n=0;n<i;++n)t=e(t,r.map((r=>r.itemAt(n))));return t}return r.forEach((r=>t=e(t,r))),t},A=(r,e)=>r.map(((t,i)=>e(t,i,r))),w=(r,e=((r,e)=>r-e))=>{if(1!==r.itemSize)throw new Error("sort algorithm: itemSize must be 1");const t=r.clone(!1);return t.array.sort(e),t},g=(r,e)=>{if(void 0===r)throw new Error("serie is undefined");if(1!==r.itemSize)throw new Error("serie should have itemSize = 1");return l(r,e)},S=(r,e)=>void 0!==r.series[e],p=r=>{if(c.isSerie(r)){const e=r;return{isArray:e.isArray,isBuffer:e.isArrayBuffer,isShared:e.shared,length:e.length,count:e.count,itemSize:e.itemSize,dimension:e.dimension,array:e.array}}const e=r;return{userData:e.userData,series:Object.entries(e.series).map((([r,e])=>({name:r,userData:e.userData,isArray:e.isArray,isBuffer:e.isArrayBuffer,isShared:e.shared,length:e.length,count:e.count,itemSize:e.itemSize,dimension:e.dimension,array:e.array})))}};var v;!function(r){function e(r){let e=Number.POSITIVE_INFINITY,t=Number.NEGATIVE_INFINITY;const i=r.length;for(let n=0;n<i;++n){const i=r[n];i<e&&(e=i),i>t&&(t=i)}return[e,t]}r.min=function(r){let e=Number.POSITIVE_INFINITY;const t=r.length;for(let i=0;i<t;++i){const t=r[i];t<e&&(e=t)}return e},r.max=function(r){let e=Number.NEGATIVE_INFINITY;const t=r.length;for(let i=0;i<t;++i){const t=r[i];t>e&&(e=t)}return e},r.minMax=e,r.normalize=function(r){const t=e(r);return r.map((r=>(r-t[0])/(t[1]-t[0])))},r.scale=function(r,e){return r.map((r=>r*e))},r.dectectNan=function(r){return r.map(((r,e)=>({value:r,i:e}))).filter((r=>Number.isNaN(r.value))).map((r=>r.i))},r.flatten=function(r){const e=[];return r.forEach((r=>e.push(...r))),e}}(v||(v={}));const E=(r,e)=>{if(c.isSerie(r)){const t=r;if(e.array.length!==t.array.length)throw new Error("length mismatch for both series");t.array.forEach(((r,t)=>e.array[t]=r))}else{if(e.array.length!==r.length)throw new Error("Array and Serie length mismatch");r.forEach(((r,t)=>e.array[t]=r))}return e},z=r=>r.clone(!1),b=(r,e)=>Object.entries(r.series).reduce(((r,[t,i])=>e===i?t:r),void 0),I=r=>Object.entries(r.series).map((([r,e])=>r)),N=r=>new x(r);class x{constructor(r){this.v=r}at(r){return this.v[r]}get length(){return this.v.length}get array(){return this.v}normalize(){const r=this.norm();return this.v=this.v.map((e=>e/r)),this}norm(){return Math.sqrt(this.v.reduce(((r,e)=>r+e**2),0))}mult(r){return this.v=this.v.map((e=>e*r)),this}add(r){return this.v=r.v.map(((r,e)=>this.v[e]+=r)),this}sub(r){return this.v=r.v.map(((r,e)=>this.v[e]-=r)),this}dot(r){return this.array.reduce(((e,t,i)=>e+t*r.array[i]),0)}toString(){let r="";for(let e=0;e<this.length;++e)r+=this.at(e)+"\t";return r}}const D=r=>B(r),B=r=>{const e=Math.sqrt(r.length);if(!Number.isInteger(e))throw new Error(`squared matrix requires m*m coefficients (got m=${r.length})`);return new T(r,e)},_=r=>{const e=(Math.sqrt(8*r.length+1)-1)/2;if(!Number.isInteger(e))throw new Error(`symmetric squared matrix of dim m requires (m*(m+1)/2) coefficients (got ${r.length}`);const t=(r,t)=>r*e+t,i=(r,t)=>t<r?.5*t*(2*e-1-t)+r:.5*r*(2*e-1-r)+t,n=new Array(e*e).fill(0);for(let s=0;s<e;++s)for(let a=0;a<e;++a)n[t(a,s)]=r[i(s,a)];return new T(n,e)};class T{constructor(r,e){this.v=r,this.m=e}index(r,e){return r*this.m+e}get isSymmetric(){let r=!0;for(let e=0;e<this.m;++e)for(let t=e;t<this.m;++t)r=r&&this.at(e,t)===this.at(t,e);return r}copy(){return new T([...this.v],this.m)}at(r,e){return this.v[this.index(r,e)]}trace(){let r=0;for(let e=0;e<this.m;++e)r+=this.at(e,e);return r}set(r,e,t){return this.v[this.index(r,e)]=t,this}add(r,e,t){return this.v[this.index(r,e)]+=t,this}scale(r){return this.v=this.v.map((e=>e*r)),this}get length(){return this.v.length}get array(){if(this.isSymmetric){const r=new Array(this.m*(this.m+1)/2).fill(0);let e=0;for(let t=0;t<this.m;++t)for(let i=t;i<this.m;++i)r[e++]=this.at(t,i);return r}return[...this.v]}transpose(){const r=new Array(this.v.length).fill(0);let e=0;for(let t=0;t<this.m;++t)for(let i=0;i<this.m;++i)r[e++]=this.at(i,t);return new T(r,this.m)}multVec(r){if(r.length!==this.m)throw new Error("size mismatch for product matrix vector");const e=new Array(r.length).fill(0),t=r instanceof x?r.array:r;for(let r=0;r<this.m;++r)for(let i=0;i<this.m;++i)e[r]+=this.at(r,i)*t[i];return new x(e)}multMat(r){if(r.m!==this.m)throw new Error("size mismatch for product matrix matrix");const e=new Array(r.length).fill(0);for(let t=0;t<this.m;++t)for(let i=0;i<this.m;++i)for(let n=0;n<this.m;++n)e[this.index(t,i)]+=this.at(t,n)*r.at(n,i);return new T(e,this.m)}addMat(r){if(r.m!==this.m)throw new Error("sizes mismatch for adding matrix");for(let e=0;e<this.v.length;++e)this.v[e]+=r.v[e];return this}toString(){let r="";for(let e=0;e<this.m;++e){for(let t=0;t<this.m;++t)r+=this.at(e,t)+"\t";r+="\n"}return r}}const O=r=>1===r.itemSize?r.map((r=>Number.isNaN(r))):r.map((e=>new Array(r.itemSize).fill(0).map((r=>Number.isNaN(r))))),M=(r,e)=>r.map((r=>!!e(r))),P=(r,e,t,i)=>r.map(((n,s)=>!0===e(n)?t(n,s,r):i(n,s,r)));class j{constructor(r,e){this.df=r,this.ds_=[],this.dimension=3,e&&(Array.isArray(e)?(console.warn("Deprecated ctor for Manager"),this.ds_=e):(e.decomposers&&(this.ds_=e.decomposers),e.dimension&&(this.dimension=e.dimension)))}add(r){this.ds_.push(r)}clear(){this.ds_=[]}names(r){let e=new Set;return Object.entries(this.df.series).forEach((([t,i])=>{i.itemSize===r&&i.dimension===this.dimension&&"positions"!==t&&"indices"!==t&&e.add(t),this.ds_.forEach((n=>{n.names(this.df,r,i,t).forEach((r=>e.add(r)))}))})),Array.from(e)}contains(r,e){return this.names(r).includes(e)}serie(r,e){for(let[t,i]of Object.entries(this.df.series))if(i.itemSize===r&&e===t)return i.clone(!1);for(let t of this.ds_){const i=t.serie(this.df,r,e);if(i)return i}}}class F{constructor(r,e,t){this.itemSize=r,this.name=e,this.fct=t}names(r,e,t,i){return e!==this.itemSize?[]:this.fct(r)?[this.name]:[]}serie(r,e,t){if(e===this.itemSize&&this.name===t)return this.fct(r)}}return e})()));
//# sourceMappingURL=dataframe.js.map