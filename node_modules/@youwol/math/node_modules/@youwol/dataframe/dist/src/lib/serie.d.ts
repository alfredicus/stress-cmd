/** Interface for supported array in {@link Serie}:
 * -    Array
 * -    TypedArray with either shared or not buffer
 */
export interface IArray {
    readonly length: number;
    [i: number]: number;
    map(cb: Function): IArray;
    forEach(cb: Function): void;
    slice(start: number, end: number): IArray;
    fill(n: number): IArray;
    reduce<U>(callback: (previousValue: number, currentValue: number, currentIndex: number, array: IArray) => number, firstState?: U): U;
    filter(cb: Function): IArray;
    sort(fn: Function): IArray;
}
/**
 * T is either an Array, or a TypedArray (Float32Array etc...) supported by an
 * ArrayBuffer or SharedArrayBuffer
 * @category Base
 */
export declare class Serie<T extends IArray = IArray> {
    /**
     * The underlying array of the serie
     */
    readonly array: T;
    /**
     * The itemSize is the dimension of one 'cell' of the serie
     */
    readonly itemSize: number;
    /**
     * The dimension of the space. As an example, for a numerical code
     * computing stresses and/or displacement fields, in 3D the dimension
     * will be 3 and in 2D the dimension will be 2. It is the user
     * responsability to properly set this value.
     */
    readonly dimension: number;
    /**
     * Whether or not {@link array} is a SharedArrayBuffer
     */
    readonly shared: boolean;
    /**
     *
     * Mutable dictionary to store consumer data (context information of the usage)
     */
    userData: {
        [key: string]: any;
    };
    private constructor();
    static isSerie(s: any): boolean;
    /**
     *
     * @param array The array of values. Can be either an instance of Array or a TypedArray.
     * For TypeArray, the underlaying buffer can be either of type ArrayBuffer or
     * SharedArrayBuffer
     * @param itemSize The size of each item. {@link count} will be array.length / {@link itemSize}
     * @param userData user data
     */
    static create<T extends IArray = IArray>({ array, itemSize, userData, dimension }: {
        array: T;
        itemSize: number;
        userData?: {
            [key: string]: any;
        };
        dimension?: number;
    }): Serie<T>;
    /**
     * Get the size of this serie, i.e., being {@link count} * {@link itemSize}
     */
    get length(): number;
    /**
     * Get the number of items (an item being of size {@link itemCount})
     */
    get count(): number;
    /**
     * True if this serie is an Array<number
     */
    get isArray(): boolean;
    /**
     * True if this serie is a TypedArray
     * @see isTypedArray
     */
    get isArrayBuffer(): boolean;
    /**
     * True if this serie is a TypedArray
     * @see isArrayBuffer
     */
    get isTypedArray(): boolean;
    /**
     * True if this serie is the buffer of the TypedArray is
     * a SharedArrayBuffer
     */
    get isShared(): boolean;
    at(i: number): number;
    itemAt(i: number): number | number[];
    setItemAt(i: number, value: number | IArray): void;
    /**
     * Iterate over all items
     * @param callback The callback that will called for each item
     */
    forEach(callback: Function): void;
    /**
     * Map the items
     */
    map(callback: Function): Serie<IArray>;
    /**
     * Reduce each item
     */
    /**
     * Return a new serie similar to this (same type of array and buffer), and with
     * the same count and itemSize.
     * @param resetValues True if reset the values to 0, false otherwise (default)
     * @see newInstance
     * @see image
     */
    clone(resetValues?: boolean): Serie<IArray>;
    /**
     * Same as {@link image}. All values are set to 0 (i.e., 0, [0,0], [0,0,0]...)
     * @see clone
     * @see image
     */
    newInstance({ count, itemSize, initialize }: {
        count: number;
        itemSize: number;
        initialize?: boolean;
    }): Serie<IArray>;
    /**
     * Return a new serie similar to this (same type of array and buffer), but with
     * different count and itemSize. All values are initialized to 0. We keep this
     * mathod for compatibility reason.
     * @param count    The number of items
     * @param itemSize The size of the items
     * @see clone
     * @see newInstance
     */
    image(count: number, itemSize: number): Serie<IArray>;
}
/**
 * @category Creation
 */
export declare function createFrom<T extends IArray>({ array, count, itemSize }: {
    array: T;
    count: number;
    itemSize: number;
}): IArray;
