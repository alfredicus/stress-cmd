import { Vector } from "./vector";
/**
 * It can be demonstrated that n(n+1)/2 = n^2 for n in N*, if and only if n=1.
 * That is to say, they's no ambiguity about the length of the passed flatten array
 * to determine if it is a bad, a symmetric or a full matrix
 * ```ts
 * const m = array.length
 * const m1 = Math.sqrt(m)
 * const m2 = (Math.sqrt(8*v.length+1)-1)/2
 * ```
 */
/**
 * Equivalent to [[squaredMatrix]]
 * @param v
 * @category Views
 */
export declare const matrix: (v: number[]) => Matrix;
/**
 * @brief Create a new squared [[Matrix]]
 * @category Views
 */
export declare const squaredMatrix: (v: number[]) => Matrix;
/**
 * @brief Create a new squared symmetric [[Matrix]]
 * @category Views
 */
export declare const symSquaredMatrix: (v: number[]) => Matrix;
/**
 * Full matrix of dim (m x m)
 * @category Views
 */
export declare class Matrix {
    protected v: number[];
    readonly m: number;
    constructor(v: number[], m: number);
    index(i: number, j: number): number;
    get isSymmetric(): boolean;
    copy(): Matrix;
    at(i: number, j: number): number;
    trace(): number;
    set(i: number, j: number, v: number): this;
    add(i: number, j: number, v: number): this;
    /**
     * Scale this matrix
     * @returns this
     */
    scale(s: number): this;
    get length(): number;
    /**
     * Return a copy of the underlaying array (flatten components). If the matrix
     * is symmetric, a compressed array is returned.
     */
    get array(): any[];
    /**
     * Transpose this matrix and return a new one
     * @returns a new [[Matrix]]
     */
    transpose(): Matrix;
    /**
     * @returns a new [[Vector]]
     */
    multVec(v: Vector | number[]): Vector;
    /**
     * @returns a new [[Matrix]]
     */
    multMat(m: Matrix): Matrix;
    /**
     * Add a new matrix to this (element-wise)
     * @returns this
     */
    addMat(m: Matrix): this;
    toString(): string;
}
