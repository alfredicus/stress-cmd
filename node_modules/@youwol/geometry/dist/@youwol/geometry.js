/*! For license information please see geometry.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@youwol/math"),require("@youwol/dataframe")):"function"==typeof define&&define.amd?define("@youwol/geometry",["@youwol/math","@youwol/dataframe"],t):"object"==typeof exports?exports["@youwol/geometry"]=t(require("@youwol/math"),require("@youwol/dataframe")):e["@youwol/geometry"]=t(e["@youwol/math"],e["@youwol/dataframe"])}("undefined"!=typeof self?self:this,(function(e,t){return(()=>{"use strict";var s={595:e=>{e.exports=t},470:t=>{t.exports=e}},i={};function r(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return s[e](n,n.exports,r),n.exports}r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.r(n),r.d(n,{Action:()=>ne,ActionPool:()=>ae,BBox:()=>t,BackgroundGrid2D:()=>P,CurvatureDecomposer:()=>Ke,Facet:()=>J,FillHoleAction:()=>le,FunctionAction:()=>oe,Grid2DHelper:()=>T,Grid3DHelper:()=>O,Halfedge:()=>Y,HarmonicDiffusion:()=>xe,InterpolateInGrid2D:()=>me,InterpolateSerieFromCsysOnSurface:()=>ue,MacroAction:()=>he,MarchingCubes:()=>K,MoveNodeAction:()=>de,Node:()=>W,Normalizer:()=>Ee,NormalsToNodeDecomposer:()=>De,Surface:()=>ee,SurfaceBuilder:()=>Z,SurfaceEditor:()=>re,TriangleCSys:()=>o,TriangleToNodeDecomposer:()=>Le,Vector:()=>Ae,createBackgroundGrid2D:()=>H,distanceFromPointToPlane:()=>a,extractSurfaceBorders:()=>ge,extrude:()=>ye,facetArea:()=>$,facetNormal:()=>V,facetsAroundNode:()=>ie,fittingPlane:()=>h,fromNodeToTriangle:()=>Ce,fromTriangleToNode:()=>je,generateEllipse:()=>F,generatePointInPolygon:()=>_e,generateRectangle:()=>z,generateSphere:()=>B,generateStreamLinesFromUnstructured:()=>Pe,getDimsGrid2D:()=>be,inflateBBox:()=>s,mapToMnt:()=>Se,nodesAroundHalfedge:()=>se,nodesAroundNode:()=>te,pointInPolygon:()=>pe,project:()=>c,relaxMesh:()=>L,reverseNormals:()=>fe,simplify:()=>k,streamLinesExtractor:()=>He,triangleArea:()=>q,triangleNormal:()=>G,triangulate:()=>E,vectorFromPointsToPlane:()=>d});var e=r(470);class t{constructor(t,s){if(this.min_=[0,0,0],this.max_=[0,0,0],this.empty_=!1,this.reset(),t&&s)for(let i=0;i<3;++i){const r=Math.min(t[i],s[i]),n=Math.max(t[i],s[i]);Math.abs(n-r)>=1e-12?(e.vec.setCoord(this.min_,i,r),e.vec.setCoord(this.max_,i,n)):(e.vec.setCoord(this.min_,i,n),e.vec.setCoord(this.max_,i,n)),n<r&&(this.empty_=!0)}}reset(){this.empty_=!0,e.vec.set(this.min_,[1e32,1e32,1e32]),e.vec.set(this.max_,[-1e32,-1e32,-1e32])}get empty(){return this.empty_}get min(){return[...this.min_]}get max(){return[...this.max_]}get xLength(){return this.max_[0]-this.min_[0]}get yLength(){return this.max_[1]-this.min_[1]}get zLength(){return this.max_[2]-this.min_[2]}get sizes(){return[this.xLength,this.yLength,this.zLength]}get center(){let t=[...this.min_];return t=e.vec.scale(e.vec.add(t,this.max_),.5),t}get radius(){return e.vec.norm(e.vec.create(this.min_,this.max_))/2}scale(t){let s=e.vec.add(e.vec.scale(e.vec.create(this.center,this.min),t),this.center),i=e.vec.add(e.vec.scale(e.vec.create(this.center,this.max),t),this.center);e.vec.set(this.min_,s),e.vec.set(this.max_,i)}grow(e){this.empty_=!1;for(let t=0;t<3;++t)e[t]<this.min_[t]&&(this.min_[t]=e[t]),e[t]>this.max_[t]&&(this.max_[t]=e[t])}randPoint(){return[this.min_[0]+Math.random()*this.xLength,this.min_[1]+Math.random()*this.yLength,this.min_[2]+Math.random()*this.zLength]}contains(e,s=0){if(e instanceof t)return!0===this.contains(e.min,s)&&!0===this.contains(e.max,s);const i=e;for(let e=0;e<3;++e)if(i[e]<this.min_[e]-s||i[e]>this.max_[e]+s)return!1;return!0}inside(e,t=0){return this.contains(e,t)}getIntersection(e){if(!1===this.intersect(e))return new t;const s=[0,0,0],i=[0,0,0];for(let t=0;t<3;++t)this.min_[t]>=e.min_[t]?s[t]=this.min_[t]:s[t]=e.min_[t],this.max_[t]<=e.max_[t]?i[t]=this.max_[t]:i[t]=e.max_[t];return new t(s,i)}intersect(e){let t=!0;for(let s=0;s<3;++s)t=t&&this.min_[s]<=e.max_[s]&&e.min_[s]<=this.max_[s];return t}}function s(e,t=.01){let s=!1;const i=e.min,r=e.max;{const n=e.radius,o=e.max[0]-e.min[0],h=e.max[1]-e.min[1],a=e.max[2]-e.min[2],d=n*t,c=d/2;if(o<d){const t=(e.max[0]+e.min[0])/2;i[0]=t-c,r[0]=t+c,s=!0}if(h<d){const t=(e.max[1]+e.min[1])/2;i[1]=t-c,r[1]=t+c,s=!0}if(a<d){const t=(e.max[2]+e.min[2])/2;i[2]=t-c,r[2]=t+c,s=!0}}!0===s&&(e.reset(),e.grow(i),e.grow(r))}var i=r(595);class o{constructor(e){this.mat_=[1,0,0,0,1,0,0,0,1],e&&this.setNormal(e)}setBase(t,s,i){let r=f(s,t,!0),n=f(i,t,!0);return this.setNormal(e.vec.cross(r,n))}setNormal(t){let s=e.vec.clone(t);if(e.vec.norm(s)<1e-7)throw new Error("Cannot calculate element normal. Elt must have a very odd shape.");s=e.vec.normalize(s);let i=e.vec.cross([0,0,1],s);e.vec.norm(i)<1e-7&&(i=[0,1,0]),i=e.vec.normalize(i);let r=e.vec.cross(i,s);r=e.vec.normalize(r),this.mat_[0]=r[0],this.mat_[1]=i[0],this.mat_[2]=s[0],this.mat_[3]=r[1],this.mat_[4]=i[1],this.mat_[5]=s[1],this.mat_[6]=r[2],this.mat_[7]=i[2],this.mat_[8]=s[2]}get matrix(){return this.mat_}get dip(){return[this.mat_[0][0],this.mat_[1][0],this.mat_[2][0]]}get strike(){return[this.mat_[0][1],this.mat_[1][1],this.mat_[2][1]]}get normal(){return[this.mat_[0][2],this.mat_[1][2],this.mat_[2][2]]}toLocal(e){return function(e,t){const s=t[0],i=t[1],r=t[2];return[e[0]*s+e[3]*i+e[6]*r,e[1]*s+e[4]*i+e[7]*r,e[2]*s+e[5]*i+e[8]*r]}(this.mat_,e)}toGlobal(e){return function(e,t){const s=t[0],i=t[1],r=t[2];return[e[0]*s+e[1]*i+e[2]*r,e[3]*s+e[4]*i+e[5]*r,e[6]*s+e[7]*i+e[8]*r]}(this.mat_,e)}shearComponent(t){return e.vec.scale(e.vec.sub(t,this.normalComponent(t)),-1)}normalComponent(t){return e.vec.scale(this.normal,-e.vec.dot(t,this.normal))}}function h(t){if(t.length<3)throw new Error("Not enough points to fit a plane");const s=[0,0,0];for(let e=0;e<t.array.length;e+=3)s[0]+=t.array[e],s[1]+=t.array[e+1],s[2]+=t.array[e+2];let i=e.vec.scale(s,1/t.length),r=0,n=0,o=0,h=0,a=0,d=0;for(let e=0;e<t.length;e+=3){let s=[t.array[e]-i[0],t.array[e+1]-i[1],t.array[e+2]-i[2]];r+=s[0]**2,n+=s[0]*s[1],o+=s[0]*s[2],h+=s[1]**2,a+=s[1]*s[2],d+=s[2]**2}let c=h*d-a*a,l=r*d-o*o,u=r*h-n*n,f=Math.max(c,l,u);if(f<=0)throw new Error("determlinant is <0");let g=[0,0,0];return g=f==c?[c,o*a-n*d,n*a-o*h]:f==l?[o*a-n*d,l,n*o-a*r]:[n*a-o*h,n*o-a*r,u],{point:i,normal:e.vec.normalize(g)}}function a(e,t){if(i.Serie.isSerie(e)){const s=e;if(3!==s.itemSize)throw new Error("points must have itemSize = 3 (coordinates)");return s.map((e=>l(e,t)))}return l(e,t)}function d(e,t){if(i.Serie.isSerie(e)){const s=e;if(3!==s.itemSize)throw new Error("points must have itemSize = 3 (coordinates)");return s.map((e=>u(e,t)))}return u(e,t)}function c(t,s){const r=(t,s)=>{const i=e.vec.dot(t,s);return[t[0]-i*s[0],t[1]-i*s[1]]};return i.Serie.isSerie(t)?t.map((e=>r(e,s.normal))):r(t,s.normal)}function l(t,s){const i=-e.vec.dot(s.normal,f(s.point,t,!0))/e.vec.dot(s.normal,s.normal),r=e.vec.add(t,e.vec.scale(s.normal,i));return e.vec.norm(f(t,r))}function u(t,s){const i=-e.vec.dot(s.normal,f(s.point,t,!0))/e.vec.dot(s.normal,s.normal);return f(t,e.vec.add(t,e.vec.scale(s.normal,i)))}function f(e,t,s=!1){if(s){const s=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2],n=Math.sqrt(s**2+i**2+r**2);return[s/n,i/n,r/n]}return[t[0]-e[0],t[1]-e[1],t[2]-e[2]]}const g=Math.pow(2,-52),p=new Uint32Array(512);class _{constructor(e){this.trianglesLen=0;const t=e.length>>1;if(t>0&&"number"!=typeof e[0])throw new Error("Expected coords to contain numbers.");this.coords=e;const s=Math.max(2*t-5,0);this._triangles=new Uint32Array(3*s),this._halfedges=new Int32Array(3*s),this._hashSize=Math.ceil(Math.sqrt(t)),this._hullPrev=new Uint32Array(t),this._hullNext=new Uint32Array(t),this._hullTri=new Uint32Array(t),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(t),this._dists=new Float64Array(t),this.update()}static from(e,t=b,s=A){const i=e.length,r=new Float64Array(2*i);for(let n=0;n<i;n++){const i=e[n];r[2*n]=t(i),r[2*n+1]=s(i)}return new _(r)}update(){const{coords:e,_hullPrev:t,_hullNext:s,_hullTri:i,_hullHash:r}=this,n=e.length>>1;let o=1/0,h=1/0,a=-1/0,d=-1/0;for(let t=0;t<n;t++){const s=e[2*t],i=e[2*t+1];s<o&&(o=s),i<h&&(h=i),s>a&&(a=s),i>d&&(d=i),this._ids[t]=t}const c=(o+a)/2,l=(h+d)/2;let u=1/0,f=0,p=0,_=0;for(let t=0;t<n;t++){const s=m(c,l,e[2*t],e[2*t+1]);s<u&&(f=t,u=s)}const x=e[2*f],y=e[2*f+1];u=1/0;for(let t=0;t<n;t++){if(t===f)continue;const s=m(x,y,e[2*t],e[2*t+1]);s<u&&s>0&&(p=t,u=s)}let N=e[2*p],b=e[2*p+1],A=1/0;for(let t=0;t<n;t++){if(t===f||t===p)continue;const s=w(x,y,N,b,e[2*t],e[2*t+1]);s<A&&(_=t,A=s)}let E=e[2*_],F=e[2*_+1];if(A===1/0){for(let t=0;t<n;t++)this._dists[t]=e[2*t]-e[0]||e[2*t+1]-e[1];S(this._ids,this._dists,0,n-1);const t=new Uint32Array(n);let s=0;for(let e=0,i=-1/0;e<n;e++){const r=this._ids[e];this._dists[r]>i&&(t[s++]=r,i=this._dists[r])}return this.hull=t.subarray(0,s),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(v(x,y,N,b,E,F)){const e=p,t=N,s=b;p=_,N=E,b=F,_=e,E=t,F=s}const z=function(e,t,s,i,r,n){const o=s-e,h=i-t,a=r-e,d=n-t,c=o*o+h*h,l=a*a+d*d,u=.5/(o*d-h*a);return{x:e+(d*c-h*l)*u,y:t+(o*l-a*c)*u}}(x,y,N,b,E,F);this._cx=z.x,this._cy=z.y;for(let t=0;t<n;t++)this._dists[t]=m(e[2*t],e[2*t+1],z.x,z.y);S(this._ids,this._dists,0,n-1),this._hullStart=f;let k=3;s[f]=t[_]=p,s[p]=t[f]=_,s[_]=t[p]=f,i[f]=0,i[p]=1,i[_]=2,r.fill(-1),r[this._hashKey(x,y)]=f,r[this._hashKey(N,b)]=p,r[this._hashKey(E,F)]=_,this.trianglesLen=0,this._addTriangle(f,p,_,-1,-1,-1);for(let n,o,h=0;h<this._ids.length;h++){const a=this._ids[h],d=e[2*a],c=e[2*a+1];if(h>0&&Math.abs(d-n)<=g&&Math.abs(c-o)<=g)continue;if(n=d,o=c,a===f||a===p||a===_)continue;let l=0;for(let e=0,t=this._hashKey(d,c);e<this._hashSize&&(l=r[(t+e)%this._hashSize],-1===l||l===s[l]);e++);l=t[l];let u,m=l;for(;u=s[m],!v(d,c,e[2*m],e[2*m+1],e[2*u],e[2*u+1]);)if(m=u,m===l){m=-1;break}if(-1===m)continue;let x=this._addTriangle(m,a,s[m],-1,-1,i[m]);i[a]=this._legalize(x+2),i[m]=x,k++;let y=s[m];for(;u=s[y],v(d,c,e[2*y],e[2*y+1],e[2*u],e[2*u+1]);)x=this._addTriangle(y,a,u,i[a],-1,i[y]),i[a]=this._legalize(x+2),s[y]=y,k--,y=u;if(m===l)for(;u=t[m],v(d,c,e[2*u],e[2*u+1],e[2*m],e[2*m+1]);)x=this._addTriangle(u,a,m,-1,i[m],i[u]),this._legalize(x+2),i[u]=x,s[m]=m,k--,m=u;this._hullStart=t[a]=m,s[m]=t[y]=a,s[a]=y,r[this._hashKey(d,c)]=a,r[this._hashKey(e[2*m],e[2*m+1])]=m}this.hull=new Uint32Array(k);for(let e=0,t=this._hullStart;e<k;e++)this.hull[e]=t,t=s[t];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,t){return Math.floor(function(e,t){const s=e/(Math.abs(e)+Math.abs(t));return(t>0?3-s:1+s)/4}(e-this._cx,t-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:t,_halfedges:s,coords:i}=this;let r=0,n=0;for(;;){const o=s[e],h=e-e%3;if(n=h+(e+2)%3,-1===o){if(0===r)break;e=p[--r];continue}const a=o-o%3,d=h+(e+1)%3,c=a+(o+2)%3,l=t[n],u=t[e],f=t[d],g=t[c];if(y(i[2*l],i[2*l+1],i[2*u],i[2*u+1],i[2*f],i[2*f+1],i[2*g],i[2*g+1])){t[e]=g,t[o]=l;const i=s[c];if(-1===i){let t=this._hullStart;do{if(this._hullTri[t]===c){this._hullTri[t]=e;break}t=this._hullPrev[t]}while(t!==this._hullStart)}this._link(e,i),this._link(o,s[n]),this._link(n,c);const h=a+(o+1)%3;r<p.length&&(p[r++]=h)}else{if(0===r)break;e=p[--r]}}return n}_link(e,t){this._halfedges[e]=t,-1!==t&&(this._halfedges[t]=e)}_addTriangle(e,t,s,i,r,n){const o=this.trianglesLen;return this._triangles[o]=e,this._triangles[o+1]=t,this._triangles[o+2]=s,this._link(o,i),this._link(o+1,r),this._link(o+2,n),this.trianglesLen+=3,o}}function m(e,t,s,i){const r=e-s,n=t-i;return r*r+n*n}function x(e,t,s,i,r,n){const o=(i-t)*(r-e),h=(s-e)*(n-t);return Math.abs(o-h)>=33306690738754716e-32*Math.abs(o+h)?o-h:0}function v(e,t,s,i,r,n){return(x(r,n,e,t,s,i)||x(e,t,s,i,r,n)||x(s,i,r,n,e,t))<0}function y(e,t,s,i,r,n,o,h){const a=e-o,d=t-h,c=s-o,l=i-h,u=r-o,f=n-h,g=c*c+l*l,p=u*u+f*f;return a*(l*p-g*f)-d*(c*p-g*u)+(a*a+d*d)*(c*f-l*u)<0}function w(e,t,s,i,r,n){const o=s-e,h=i-t,a=r-e,d=n-t,c=o*o+h*h,l=a*a+d*d,u=.5/(o*d-h*a),f=(d*c-h*l)*u,g=(o*l-a*c)*u;return f*f+g*g}function S(e,t,s,i){if(i-s<=20)for(let r=s+1;r<=i;r++){const i=e[r],n=t[i];let o=r-1;for(;o>=s&&t[e[o]]>n;)e[o+1]=e[o--];e[o+1]=i}else{let r=s+1,n=i;N(e,s+i>>1,r),t[e[s]]>t[e[i]]&&N(e,s,i),t[e[r]]>t[e[i]]&&N(e,r,i),t[e[s]]>t[e[r]]&&N(e,s,r);const o=e[r],h=t[o];for(;;){do{r++}while(t[e[r]]<h);do{n--}while(t[e[n]]>h);if(n<r)break;N(e,r,n)}e[s+1]=e[n],e[n]=o,i-r+1>=n-s?(S(e,t,r,i),S(e,t,s,n-1)):(S(e,t,s,n-1),S(e,t,r,i))}}function N(e,t,s){const i=e[t];e[t]=e[s],e[s]=i}function b(e){return e[0]}function A(e){return e[1]}function E(e,t=[0,0,1]){let s;if(2===e.itemSize)s=new _(e.array);else{const i=e.map((e=>c(e,{normal:t,point:[0,0,0]})));s=new _(i.array)}i.array.max(s.triangles);const r=i.Serie.create({array:s.triangles,itemSize:3});return i.DataFrame.create({series:{indices:r,positions:e}})}function F({a:e,b:t,nbRings:s=4,density:r=8,center:n=[0,0,0]}){const o=(e,t)=>a.push(e+n[0],t+n[1],n[2]),h=(e,t,s)=>{for(let i=0;i<s;++i){const r=2*Math.PI*i/(s-1),n=e*Math.cos(r)/2,h=t*Math.sin(r)/2;o(n,h)}},a=[],d=e/s,c=t/s;for(let e=1;e<=s;++e)h(d*e,c*e,r*e);return o(0,0),E(i.Serie.create({array:a,itemSize:3}))}function z({a:e,b:t,na:s,nb:r,center:n=[0,0,0]}){const o=[],h=1/(s-1),a=1/(r-1);for(let i=0;i<s;++i)for(let s=0;s<r;++s)d=e*i*h,c=t*s*a,o.push(d+n[0]-e/2,c+n[1]-t/2,n[2]);var d,c;return E(i.Serie.create({array:o,itemSize:3}))}function k(e,t=1,s=!1){const r=void 0!==t?t*t:1;return function(e,t){let s,r,n,o,h=e.length,a=new("undefined"!=typeof Uint8Array?Uint8Array:Array)(h),d=0,c=h-1,l=[],u=[];for(a[d]=a[c]=1;c;){for(r=0,s=d+1;s<c;s++)n=M(e.itemAt(s),e.itemAt(d),e.itemAt(c)),n>r&&(o=s,r=n);r>t&&(a[o]=1,l.push(d,o,o,c)),c=l.pop(),d=l.pop()}for(s=0;s<h;s++)a[s]&&u.push(e[s]);const f=e.itemSize,g=e.image(e.length/f,f);return(0,i.copy)(u,g)}(s?e:function(e,t){let s=e.itemAt(0);const r=[...s];let n;const o=e.itemSize;for(let i=1,o=e.count;i<o;++i)n=e.itemAt(i),I(n,s)>t&&(r.push(...n),s=n);s!==n&&r.push(...n);const h=e.image(e.length/o,o);return(0,i.copy)(r,h)}(e,r),r)}const I=(t,s)=>e.vec.norm2(e.vec.sub(t,s));function M(e,t,s){if(2===e.length){let r=t[0],n=t[1],o=s[0]-r,h=s[1]-n;if(0!==o||0!==h){var i=((e[0]-r)*o+(e[1]-n)*h)/(o*o+h*h);i>1?(r=s[0],n=s[1]):i>0&&(r+=o*i,n+=h*i)}return o=e[0]-r,h=e[1]-n,o*o+h*h}let r=t[0],n=t[1],o=t[2],h=s[0]-r,a=s[1]-n,d=s[2]-o;if(0!==h||0!==a||0!==d){const t=((e[0]-r)*h+(e[1]-n)*a+(e[2]-o)*d)/(h*h+a*a+d*d);t>1?(r=s[0],n=s[1],o=s[2]):t>0&&(r+=h*t,n+=a*t,o+=d*t)}return h=e[0]-r,a=e[1]-n,d=e[2]-o,h*h+a*a+d*d}function B(e){if(e<1)throw new Error("Subdivision must be > 0");const t=(1+Math.sqrt(5))/2,s=new Array,r=new Array;let n=0;const o=[[1,t,0],[-1,t,0],[1,-t,0],[-1,-t,0],[0,1,t],[0,-1,t],[0,1,-t],[0,-1,-t],[t,0,1],[-t,0,1],[t,0,-1],[-t,0,-1]],h=[[0,1,4],[1,9,4],[4,9,5],[5,9,3],[2,3,7],[3,2,5],[7,10,2],[0,8,10],[0,4,8],[8,2,10],[8,4,5],[8,5,2],[1,0,6],[11,1,6],[3,9,11],[6,10,7],[3,11,7],[11,6,7],[6,0,10],[9,1,11]].map((e=>e.map((e=>o[e])))),a=([e,t,s])=>{const i=3/Math.sqrt(e**2+t**2+s**2);return[i*e,i*t,i*s]},d=([e,t,s],[i,r,n],o)=>[e+o*(i-e),t+o*(r-t),s+o*(n-s)],c=(...e)=>e.forEach((e=>{s.push(e[0],e[1],e[2]),r.push(n++)}));for(const[t,s,i]of h){let r,n,o=d(t,s,1/e),h=d(t,i,1/e);c(a(t),a(o),a(h));for(let l=1;l<e;++l){r=o,o=d(t,s,(l+1)/e),n=h,h=d(t,i,(l+1)/e);for(let e=0;e<=l;++e)c(a(d(r,n,e/l)),a(d(o,h,e/(l+1))),a(d(o,h,(e+1)/(l+1))));for(let e=0;e<l;++e)c(a(d(r,n,e/l)),a(d(o,h,(e+1)/(l+1))),a(d(r,n,(e+1)/l)))}}return{positions:(0,i.createTyped)(Float32Array,s,!0),indices:(0,i.createTyped)(Int16Array,r,!0)}}class T{constructor(e,t,s,i,r=1e-7){this._origin=[0,0],this._n=[0,0],this._dx=0,this._dy=0,this._n=[s,i],this._dx=(t[0]-e[0]+2*r)/(s-1),this._dy=(t[1]-e[1]+2*r)/(i-1),this._origin=[e[0]-r,e[1]-r]}get count(){return this._n[0]*this._n[1]}get nx(){return this._n[0]}get ny(){return this._n[1]}get dx(){return this._dx}get dy(){return this._dy}get origin(){return this._origin}get xLength(){return this._n[0]*this._dx}get yLength(){return this._n[1]*this._dy}getIJ(e){const t=e[0]-this._origin[0],s=t/this._dx;if(t<0||s>this._n[0])return{ok:!1};const i=Math.trunc(s),r=e[1]-this._origin[1],n=r/this._dy;return r<0||n>this._n[1]?{ok:!1}:{ok:!0,ij:[i,Math.trunc(n)]}}flatIndex(e,t){return e+t*this._n[0]}flatIndices(e){const t=this.candidate(e);if(void 0===t)return;const s=this.flatIndex(t[0],t[1]),i=this.flatIndex(t[0],t[1]+1);return[s,i,s+1,i+1]}positionAt(e,t){return[this._origin[0]+e*this._dx,this._origin[1]+t*this._dy]}candidate(e){const{ok:t,ij:s}=this.getIJ(e);if(t)return s}interpolate(t,s){const i=this.getIJ(t);if(i.ok){const r=i.ij[0],n=i.ij[1],o=this.positionAt(r,n),h=this.positionAt(r+1,n+1),a=this.flatIndices(t).map((e=>s.itemAt(e)));return Array.isArray(a[0])?a[0].map(((s,i)=>(0,e.biLerp)(t,o,h,s,a[1][i],a[2][i],a[3][i]))):(0,e.biLerp)(t,o,h,a[0],a[1],a[2],a[3])}}forEach(e){let t=0;for(let s=0;s<this._n[0];++s)for(let i=0;i<this._n[1];++i){const r=this.positionAt(s,i);e(r[0],r[1],s,i,t++)}}map(e){const t=new Array(this.count);let s=0;for(let i=0;i<this._n[0];++i)for(let r=0;r<this._n[1];++r){const n=this.positionAt(i,r);t[s]=e(n[0],n[1],i,r,s++)}return t}}class O{constructor(e,t,s,i,r,n=1e-7){this._origin=[0,0,0],this._n=[0,0,0],this._dx=0,this._dy=0,this._dz=0,this._n=[s,i,r],this._dx=(t[0]-e[0]+2*n)/(s-1),this._dy=(t[1]-e[1]+2*n)/(i-1),this._dz=(t[2]-e[2]+2*n)/(r-1),this._origin=[e[0]-n,e[1]-n,e[2]-n]}get count(){return this._n[0]*this._n[1]*this._n[2]}get nx(){return this._n[0]}get ny(){return this._n[1]}get nz(){return this._n[2]}get dx(){return this._dx}get dy(){return this._dy}get dz(){return this._dz}get origin(){return this._origin}get xLength(){return this._n[0]*this._dx}get yLength(){return this._n[1]*this._dy}get zLength(){return this._n[2]*this._dz}getIJK(e){const t=e[0]-this._origin[0];if(t<0)return{ok:!1};const s=e[1]-this._origin[1];if(s<0)return{ok:!1};const i=e[2]-this._origin[2];if(i<0)return{ok:!1};const r=t/this._dx;if(r>this._n[0])return{ok:!1};const n=s/this._dy;return n>this._n[1]||i/this._dz>this._n[2]?{ok:!1}:{ok:!0,ijk:[Math.trunc(r),Math.trunc(n),Math.trunc(n)]}}flatIndex(e,t,s){return e+this._n[0]*t+this._n[0]*this._n[1]*s}flatIndices(e){const t=this.candidate(e);if(void 0===t)return;const s=this.flatIndex(t[0],t[1],t[2]),i=this.flatIndex(t[0],t[1]+1,t[2]),r=this.flatIndex(t[0],t[1],t[2]+1),n=this.flatIndex(t[0],t[1]+1,t[2]+1);return[s,s+1,i,i+1,r,r+1,n,n+1]}positionAt(e,t,s){return[this._origin[0]+e*this._dx,this._origin[1]+t*this._dy,this._origin[2]+s*this._dz]}candidate(e){const{ok:t,ij:s}=this.getIJK(e);if(t)return s}interpolate(t,s){const i=this.getIJK(t);if(i.ok){const r=i.ijk[0],n=i.ijk[1],o=i.ijk[2],h=this.positionAt(r,n,o),a=this.positionAt(r+1,n+1,o+1),d=new Array(8);d[0]=this.flatIndex(r,n,o),d[1]=this.flatIndex(r,n,o+1),d[2]=this.flatIndex(r,n+1,o),d[3]=this.flatIndex(r,n+1,o+1),d[4]=this.flatIndex(r+1,n,o),d[5]=this.flatIndex(r+1,n,o+1),d[6]=this.flatIndex(r+1,n+1,o),d[7]=this.flatIndex(r+1,n+1,o+1);const c=d.map((e=>s.itemAt(e)));return Array.isArray(c[0])?c[0].map(((s,i)=>(0,e.triLerp)(t,h,a,s,c[1][i],c[2][i],c[3][i],c[4][i],c[5][i],c[6][i],c[7][i]))):(0,e.triLerp)(t,h,a,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7])}}forEach(e){let t=0;for(let s=0;s<this._n[0];++s)for(let i=0;i<this._n[1];++i)for(let r=0;r<this._n[2];++r){const n=this.positionAt(s,i,r);e(n[0],n[1],n[2],s,i,r,t++)}}map(e){const t=new Array(this.count);let s=0;for(let i=0;i<this._n[0];++i)for(let r=0;r<this._n[1];++r)for(let n=0;n<this._n[2];++n){const o=this.positionAt(i,r,n);t[s]=e(o[0],o[1],o[2],i,r,n,s++)}return t}}function H({positions:t,indices:s,dims:i=[20,20],eps:r=.01}){t.count,s.count;const n=(0,e.minMax)(t),o=[];o.push((n[3]-n[0]+2*r)/i[0]),o.push((n[4]-n[1]+2*r)/i[1]);let h=[n[0]-r,n[1]-r];const a=new P;return a.set(h,o[0],o[1],i[0],i[1]),s.forEach(((e,s)=>{const i=[],r=[];e.forEach((e=>{const s=t.itemAt(e);i.push(s[0]),r.push(s[1])})),a.insert(new C([Math.min(...i),Math.max(...i)],[Math.min(...r),Math.max(...r)],s))})),a}class P{constructor(){this.origin_=[0,0],this.dx_=0,this.dy_=0,this.nx_=0,this.ny_=0}set(e,t,s,i,r){this.origin_=[...e],this.dx_=t,this.dy_=s,this.nx_=i,this.ny_=r,this.cells_=Array(this.nx_*this.ny_).fill(void 0).map((e=>new D))}get nx(){return this.nx_}get ny(){return this.ny_}get dx(){return this.dx_}get dy(){return this.dy_}get origin(){return this.origin_}get bbox(){return{x:this.origin_[0],y:this.origin_[1],width:this.dx_*this.nx_,height:this.dy_*this.ny_}}forAllPoints(e){for(let t=0;t<this.nx_;++t)for(let s=0;s<this.ny_;++s){const i=this.getFlatIndex(t,s);e(this.cells_[i].objects,t,s,this.getCoordinates(t,s))}}insert(e){const t=this.getIJ(e.min);if(!t.ok)return!1;const s=t.ij,i=this.getIJ(e.max);if(!i.ok)return!1;const r=i.ij,n=Math.min(s[0],r[0]),o=Math.max(s[0],r[0]),h=Math.min(s[1],r[1]),a=Math.max(s[1],r[1]);for(let t=n;t<=o;++t)for(let s=h;s<=a;++s){const i=this.getFlatIndex(t,s);this.cells_[i].objects.push(e)}return!0}candidatesFromIJ(e,t){const s=this.getFlatIndex(e,t);return this.cells_[s].objects}candidates(e){const{ok:t,ij:s}=this.getIJ(e);if(!t)return[];const i=this.getFlatIndex(s[0],s[1]);return this.cells_[i].objects}getIJ(e){const t=e[0]-this.origin_[0];if(t<0)return j;const s=e[1]-this.origin_[1];if(s<0)return j;const i=t/this.dx_;if(i>this.nx_)return j;const r=s/this.dy_;return r>this.ny_?j:{ok:!0,ij:[Math.floor(i),Math.floor(r)]}}getCoordinates(e,t){return[this.origin_[0]+e*this.dx_,this.origin_[1]+t*this.dy_]}getFlatIndex(e,t){return this.nx_*t+e}}const j={ok:!1};class C{constructor(e,t,s){this.min=[0,0],this.max=[0,0],this.min=[e[0],t[0]],this.max=[e[1],t[1]],this.obj=s}contains(e,t){return e>=this.min[0]&&e<=this.max[0]&&t>=this.min[1]&&t<=this.max[1]}}class D{constructor(){this.objects=[]}}function L(t,s,i=100,r=.1){const n=ee.create(t,s);let o=0;n.forEachFace((e=>o+=e.area)),o/=n.nbFacets;const h=Math.sqrt(4*o/Math.sqrt(3));for(let t=0;t<i;++t)n.forEachNode(((t,s)=>{if(!1===t.isOnBorder){let s=[0,0,0];te(t,(i=>{let r=e.vec.create(t.pos,i.pos);const n=e.vec.norm(r);r[0]/=n,r[1]/=n,s=e.vec.add(s,e.vec.scale(r,n-h))})),t.setPos(t.pos[0]+s[0]*r,t.pos[1]+s[1]*r,s[2])}}));return n.nodesAsSerie}class K{constructor(e,t){if(this.grid=e,this.values=t,this.XYZ_=!0,this.bounds_=[],3!==this.grid.sizes.length)throw new Error("sizes must be an array of length 3");const s=e.sizes.reduce(((e,t)=>e*t),1);if(s!==t.length)throw new Error(`number of points (${s}) must equal the number of values (${t.length})`)}get valid(){return void 0!==this.grid&&void 0!==this.values}set xyzOrder(e){this.XYZ_=e}get xyzOrder(){return this.XYZ_}run(e,t){if(!this.valid)return{positions:[],indices:[]};this.bounds_=void 0===t?[Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY]:t;const s=new Array(12),i=[],r=[];let n,o,h;this.grid.sizes[0],this.grid.sizes[1],this.grid.sizes[2],!1===this.XYZ_?(n=this.grid.sizes[0],o=this.grid.sizes[1],h=this.grid.sizes[2]):(n=this.grid.sizes[2],o=this.grid.sizes[1],h=this.grid.sizes[0]);const a=o*h;let d=0;for(let t=0;t<n-1;t++)for(let n=0;n<o-1;n++)for(let o=0;o<h-1;o++){let c,l,u,f,g,p,_,m,x,v,y;!1===this.XYZ_?(c=t,l=n,u=o,f=u+h*l+a*c,g=f+a,p=f+h,_=p+a,m=f+1,x=g+1,v=p+1,y=_+1):(c=o,l=n,u=t,f=c+h*l+a*u,g=f+1,p=f+h,_=p+1,m=f+a,x=g+a,v=p+a,y=_+a);const w=this.values[f],S=this.values[g],N=this.values[p],b=this.values[_],A=this.values[m],E=this.values[x],F=this.values[v],z=this.values[y],k=[w,S,N,b,A,E,F,z];if(!1===this._ok(k))continue;let I=0;w<e&&(I|=1),S<e&&(I|=2),N<e&&(I|=8),b<e&&(I|=4),A<e&&(I|=16),E<e&&(I|=32),F<e&&(I|=128),z<e&&(I|=64);const M=R[I];if(0===M)continue;let B=.5;1&M&&(B=(e-w)/(S-w),s[0]=this.lerp(f,g,B)),2&M&&(B=(e-S)/(b-S),s[1]=this.lerp(g,_,B)),4&M&&(B=(e-N)/(b-N),s[2]=this.lerp(p,_,B)),8&M&&(B=(e-w)/(N-w),s[3]=this.lerp(f,p,B)),16&M&&(B=(e-A)/(E-A),s[4]=this.lerp(m,x,B)),32&M&&(B=(e-E)/(z-E),s[5]=this.lerp(x,y,B)),64&M&&(B=(e-F)/(z-F),s[6]=this.lerp(v,y,B)),128&M&&(B=(e-A)/(F-A),s[7]=this.lerp(m,v,B)),256&M&&(B=(e-w)/(A-w),s[8]=this.lerp(f,m,B)),512&M&&(B=(e-S)/(E-S),s[9]=this.lerp(g,x,B)),1024&M&&(B=(e-b)/(z-b),s[10]=this.lerp(_,y,B)),2048&M&&(B=(e-N)/(F-N),s[11]=this.lerp(p,v,B));let T=0;for(I<<=4;-1!==U[I+T];){const e=U[I+T],t=U[I+T+1],n=U[I+T+2];i.push(...s[e],...s[t],...s[n]),r.push(d,d+1,d+2),d+=3,T+=3}}return{positions:i,indices:r}}_in(e){return e>=this.bounds_[0]&&e<=this.bounds_[1]}_ok(e){let t=!0;return e.forEach((e=>{t=t&&this._in(e)})),t}unflat(e){const t=this.grid.sizes[1],s=this.grid.sizes[2],i=e/t/s,r=Math.trunc(i);let n=t*s*(i-r)/s,o=Math.trunc(n),h=s*(n-o);return[Math.round(r),Math.round(o),Math.round(h)]}lerp(e,t,s){const i=this.unflat(e),r=this.grid.pos(i[0],i[1],i[2]),n=this.unflat(t),o=this.grid.pos(n[0],n[1],n[2]);return r[0]+=(o[0]-r[0])*s,r[1]+=(o[1]-r[1])*s,r[2]+=(o[2]-r[2])*s,r}}const R=new Int32Array([0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0]),U=new Int32Array([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,9,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,2,10,0,2,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,8,3,2,10,8,10,9,8,-1,-1,-1,-1,-1,-1,-1,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,8,11,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,11,2,1,9,11,9,8,11,-1,-1,-1,-1,-1,-1,-1,3,10,1,11,10,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,10,1,0,8,10,8,11,10,-1,-1,-1,-1,-1,-1,-1,3,9,0,3,11,9,11,10,9,-1,-1,-1,-1,-1,-1,-1,9,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,7,3,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,1,9,4,7,1,7,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,4,7,3,0,4,1,2,10,-1,-1,-1,-1,-1,-1,-1,9,2,10,9,0,2,8,4,7,-1,-1,-1,-1,-1,-1,-1,2,10,9,2,9,7,2,7,3,7,9,4,-1,-1,-1,-1,8,4,7,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,4,7,11,2,4,2,0,4,-1,-1,-1,-1,-1,-1,-1,9,0,1,8,4,7,2,3,11,-1,-1,-1,-1,-1,-1,-1,4,7,11,9,4,11,9,11,2,9,2,1,-1,-1,-1,-1,3,10,1,3,11,10,7,8,4,-1,-1,-1,-1,-1,-1,-1,1,11,10,1,4,11,1,0,4,7,11,4,-1,-1,-1,-1,4,7,8,9,0,11,9,11,10,11,0,3,-1,-1,-1,-1,4,7,11,4,11,9,9,11,10,-1,-1,-1,-1,-1,-1,-1,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,4,1,5,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,5,4,8,3,5,3,1,5,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,10,4,9,5,-1,-1,-1,-1,-1,-1,-1,5,2,10,5,4,2,4,0,2,-1,-1,-1,-1,-1,-1,-1,2,10,5,3,2,5,3,5,4,3,4,8,-1,-1,-1,-1,9,5,4,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,0,8,11,4,9,5,-1,-1,-1,-1,-1,-1,-1,0,5,4,0,1,5,2,3,11,-1,-1,-1,-1,-1,-1,-1,2,1,5,2,5,8,2,8,11,4,8,5,-1,-1,-1,-1,10,3,11,10,1,3,9,5,4,-1,-1,-1,-1,-1,-1,-1,4,9,5,0,8,1,8,10,1,8,11,10,-1,-1,-1,-1,5,4,0,5,0,11,5,11,10,11,0,3,-1,-1,-1,-1,5,4,8,5,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,9,7,8,5,7,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,3,0,9,5,3,5,7,3,-1,-1,-1,-1,-1,-1,-1,0,7,8,0,1,7,1,5,7,-1,-1,-1,-1,-1,-1,-1,1,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,7,8,9,5,7,10,1,2,-1,-1,-1,-1,-1,-1,-1,10,1,2,9,5,0,5,3,0,5,7,3,-1,-1,-1,-1,8,0,2,8,2,5,8,5,7,10,5,2,-1,-1,-1,-1,2,10,5,2,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,7,9,5,7,8,9,3,11,2,-1,-1,-1,-1,-1,-1,-1,9,5,7,9,7,2,9,2,0,2,7,11,-1,-1,-1,-1,2,3,11,0,1,8,1,7,8,1,5,7,-1,-1,-1,-1,11,2,1,11,1,7,7,1,5,-1,-1,-1,-1,-1,-1,-1,9,5,8,8,5,7,10,1,3,10,3,11,-1,-1,-1,-1,5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,-1,11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,-1,11,10,5,7,11,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,0,1,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,1,9,8,5,10,6,-1,-1,-1,-1,-1,-1,-1,1,6,5,2,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,6,5,1,2,6,3,0,8,-1,-1,-1,-1,-1,-1,-1,9,6,5,9,0,6,0,2,6,-1,-1,-1,-1,-1,-1,-1,5,9,8,5,8,2,5,2,6,3,2,8,-1,-1,-1,-1,2,3,11,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,0,8,11,2,0,10,6,5,-1,-1,-1,-1,-1,-1,-1,0,1,9,2,3,11,5,10,6,-1,-1,-1,-1,-1,-1,-1,5,10,6,1,9,2,9,11,2,9,8,11,-1,-1,-1,-1,6,3,11,6,5,3,5,1,3,-1,-1,-1,-1,-1,-1,-1,0,8,11,0,11,5,0,5,1,5,11,6,-1,-1,-1,-1,3,11,6,0,3,6,0,6,5,0,5,9,-1,-1,-1,-1,6,5,9,6,9,11,11,9,8,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,4,7,3,6,5,10,-1,-1,-1,-1,-1,-1,-1,1,9,0,5,10,6,8,4,7,-1,-1,-1,-1,-1,-1,-1,10,6,5,1,9,7,1,7,3,7,9,4,-1,-1,-1,-1,6,1,2,6,5,1,4,7,8,-1,-1,-1,-1,-1,-1,-1,1,2,5,5,2,6,3,0,4,3,4,7,-1,-1,-1,-1,8,4,7,9,0,5,0,6,5,0,2,6,-1,-1,-1,-1,7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,-1,3,11,2,7,8,4,10,6,5,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,2,4,2,0,2,7,11,-1,-1,-1,-1,0,1,9,4,7,8,2,3,11,5,10,6,-1,-1,-1,-1,9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,-1,8,4,7,3,11,5,3,5,1,5,11,6,-1,-1,-1,-1,5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,-1,0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,-1,6,5,9,6,9,11,4,7,9,7,11,9,-1,-1,-1,-1,10,4,9,6,4,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,10,6,4,9,10,0,8,3,-1,-1,-1,-1,-1,-1,-1,10,0,1,10,6,0,6,4,0,-1,-1,-1,-1,-1,-1,-1,8,3,1,8,1,6,8,6,4,6,1,10,-1,-1,-1,-1,1,4,9,1,2,4,2,6,4,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,9,2,4,9,2,6,4,-1,-1,-1,-1,0,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,3,2,8,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,10,4,9,10,6,4,11,2,3,-1,-1,-1,-1,-1,-1,-1,0,8,2,2,8,11,4,9,10,4,10,6,-1,-1,-1,-1,3,11,2,0,1,6,0,6,4,6,1,10,-1,-1,-1,-1,6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,-1,9,6,4,9,3,6,9,1,3,11,6,3,-1,-1,-1,-1,8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,-1,3,11,6,3,6,0,0,6,4,-1,-1,-1,-1,-1,-1,-1,6,4,8,11,6,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,10,6,7,8,10,8,9,10,-1,-1,-1,-1,-1,-1,-1,0,7,3,0,10,7,0,9,10,6,7,10,-1,-1,-1,-1,10,6,7,1,10,7,1,7,8,1,8,0,-1,-1,-1,-1,10,6,7,10,7,1,1,7,3,-1,-1,-1,-1,-1,-1,-1,1,2,6,1,6,8,1,8,9,8,6,7,-1,-1,-1,-1,2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,-1,7,8,0,7,0,6,6,0,2,-1,-1,-1,-1,-1,-1,-1,7,3,2,6,7,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,11,10,6,8,10,8,9,8,6,7,-1,-1,-1,-1,2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,-1,1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,-1,11,2,1,11,1,7,10,6,1,6,7,1,-1,-1,-1,-1,8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,-1,0,9,1,11,6,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,8,0,7,0,6,3,11,0,11,6,0,-1,-1,-1,-1,7,11,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,1,9,8,3,1,11,7,6,-1,-1,-1,-1,-1,-1,-1,10,1,2,6,11,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,8,6,11,7,-1,-1,-1,-1,-1,-1,-1,2,9,0,2,10,9,6,11,7,-1,-1,-1,-1,-1,-1,-1,6,11,7,2,10,3,10,8,3,10,9,8,-1,-1,-1,-1,7,2,3,6,2,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,0,8,7,6,0,6,2,0,-1,-1,-1,-1,-1,-1,-1,2,7,6,2,3,7,0,1,9,-1,-1,-1,-1,-1,-1,-1,1,6,2,1,8,6,1,9,8,8,7,6,-1,-1,-1,-1,10,7,6,10,1,7,1,3,7,-1,-1,-1,-1,-1,-1,-1,10,7,6,1,7,10,1,8,7,1,0,8,-1,-1,-1,-1,0,3,7,0,7,10,0,10,9,6,10,7,-1,-1,-1,-1,7,6,10,7,10,8,8,10,9,-1,-1,-1,-1,-1,-1,-1,6,8,4,11,8,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,6,11,3,0,6,0,4,6,-1,-1,-1,-1,-1,-1,-1,8,6,11,8,4,6,9,0,1,-1,-1,-1,-1,-1,-1,-1,9,4,6,9,6,3,9,3,1,11,3,6,-1,-1,-1,-1,6,8,4,6,11,8,2,10,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,11,0,6,11,0,4,6,-1,-1,-1,-1,4,11,8,4,6,11,0,2,9,2,10,9,-1,-1,-1,-1,10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,-1,8,2,3,8,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,0,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,4,2,4,6,4,3,8,-1,-1,-1,-1,1,9,4,1,4,2,2,4,6,-1,-1,-1,-1,-1,-1,-1,8,1,3,8,6,1,8,4,6,6,10,1,-1,-1,-1,-1,10,1,0,10,0,6,6,0,4,-1,-1,-1,-1,-1,-1,-1,4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,-1,10,9,4,6,10,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,5,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,5,11,7,6,-1,-1,-1,-1,-1,-1,-1,5,0,1,5,4,0,7,6,11,-1,-1,-1,-1,-1,-1,-1,11,7,6,8,3,4,3,5,4,3,1,5,-1,-1,-1,-1,9,5,4,10,1,2,7,6,11,-1,-1,-1,-1,-1,-1,-1,6,11,7,1,2,10,0,8,3,4,9,5,-1,-1,-1,-1,7,6,11,5,4,10,4,2,10,4,0,2,-1,-1,-1,-1,3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,-1,7,2,3,7,6,2,5,4,9,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,6,0,6,2,6,8,7,-1,-1,-1,-1,3,6,2,3,7,6,1,5,0,5,4,0,-1,-1,-1,-1,6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,-1,9,5,4,10,1,6,1,7,6,1,3,7,-1,-1,-1,-1,1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,-1,4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,-1,7,6,10,7,10,8,5,4,10,4,8,10,-1,-1,-1,-1,6,9,5,6,11,9,11,8,9,-1,-1,-1,-1,-1,-1,-1,3,6,11,0,6,3,0,5,6,0,9,5,-1,-1,-1,-1,0,11,8,0,5,11,0,1,5,5,6,11,-1,-1,-1,-1,6,11,3,6,3,5,5,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,11,9,11,8,11,5,6,-1,-1,-1,-1,0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,-1,11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,-1,6,11,3,6,3,5,2,10,3,10,5,3,-1,-1,-1,-1,5,8,9,5,2,8,5,6,2,3,8,2,-1,-1,-1,-1,9,5,6,9,6,0,0,6,2,-1,-1,-1,-1,-1,-1,-1,1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,-1,1,5,6,2,1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,-1,10,1,0,10,0,6,9,5,0,5,6,0,-1,-1,-1,-1,0,3,8,5,6,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,5,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,7,5,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,11,7,5,8,3,0,-1,-1,-1,-1,-1,-1,-1,5,11,7,5,10,11,1,9,0,-1,-1,-1,-1,-1,-1,-1,10,7,5,10,11,7,9,8,1,8,3,1,-1,-1,-1,-1,11,1,2,11,7,1,7,5,1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,7,1,7,5,7,2,11,-1,-1,-1,-1,9,7,5,9,2,7,9,0,2,2,11,7,-1,-1,-1,-1,7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,-1,2,5,10,2,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,8,2,0,8,5,2,8,7,5,10,2,5,-1,-1,-1,-1,9,0,1,5,10,3,5,3,7,3,10,2,-1,-1,-1,-1,9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,-1,1,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,7,0,7,1,1,7,5,-1,-1,-1,-1,-1,-1,-1,9,0,3,9,3,5,5,3,7,-1,-1,-1,-1,-1,-1,-1,9,8,7,5,9,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,8,4,5,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,5,0,4,5,11,0,5,10,11,11,3,0,-1,-1,-1,-1,0,1,9,8,4,10,8,10,11,10,4,5,-1,-1,-1,-1,10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,-1,2,5,1,2,8,5,2,11,8,4,5,8,-1,-1,-1,-1,0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,-1,0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,-1,9,4,5,2,11,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,5,10,3,5,2,3,4,5,3,8,4,-1,-1,-1,-1,5,10,2,5,2,4,4,2,0,-1,-1,-1,-1,-1,-1,-1,3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,-1,5,10,2,5,2,4,1,9,2,9,4,2,-1,-1,-1,-1,8,4,5,8,5,3,3,5,1,-1,-1,-1,-1,-1,-1,-1,0,4,5,1,0,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,4,5,8,5,3,9,0,5,0,3,5,-1,-1,-1,-1,9,4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,11,7,4,9,11,9,10,11,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,7,9,11,7,9,10,11,-1,-1,-1,-1,1,10,11,1,11,4,1,4,0,7,4,11,-1,-1,-1,-1,3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,-1,4,11,7,9,11,4,9,2,11,9,1,2,-1,-1,-1,-1,9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,-1,11,7,4,11,4,2,2,4,0,-1,-1,-1,-1,-1,-1,-1,11,7,4,11,4,2,8,3,4,3,2,4,-1,-1,-1,-1,2,9,10,2,7,9,2,3,7,7,4,9,-1,-1,-1,-1,9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,-1,3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,-1,1,10,2,8,7,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,7,1,3,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,0,8,1,8,7,1,-1,-1,-1,-1,4,0,3,7,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,11,9,10,-1,-1,-1,-1,-1,-1,-1,0,1,10,0,10,8,8,10,11,-1,-1,-1,-1,-1,-1,-1,3,1,10,11,3,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,11,1,11,9,9,11,8,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,1,2,9,2,11,9,-1,-1,-1,-1,0,2,11,8,0,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,10,8,9,-1,-1,-1,-1,-1,-1,-1,9,10,2,0,9,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,0,1,8,1,10,8,-1,-1,-1,-1,1,10,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,8,9,1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,3,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);function q(t,s,i){return.5*e.vec.norm(e.vec.cross(e.vec.create(t,s),e.vec.create(t,i)))}function G(t,s,i){const r=e.vec.create(i,s),n=e.vec.create(t,s);return e.vec.normalize(e.vec.cross(r,n))}function $(e){let t=0,s=e.halfedge;const i=s.node.pos;s=s.next;do{t+=q(i,s.node.pos,s.next.node.pos),s=s.next}while(s!==e.halfedge);return t}function V(t){let s=[0,0,0],i=t.halfedge;const r=i.node.pos;i=i.next;do{const t=G(r,i.node.pos,i.next.node.pos);Number.isNaN(t[0])||(s=e.vec.add(s,t)),i=i.next}while(i!==t.halfedge);return e.vec.normalize(s)}class W{constructor(){this.pos_=[0,0,0],this.id_=-1,this.he_=void 0}setPos(e,t,s){Array.isArray(e)?(this.pos_[0]=e[0],this.pos_[1]=e[1],this.pos_[2]=e[2]):(this.pos_[0]=e,this.pos_[1]=t,this.pos_[2]=void 0!==s?s:0)}setId(e){this.id_=e}get posVec3(){return this.pos_}get pos(){return this.pos_}get id(){return this.id_}get halfedge(){return this.he_}get isOnBorder(){let e=this.he_;if(void 0===e)return!0;do{if(e.isBorder)return!0;e=e.nextAroundNode}while(e!==this.he_);return!1}get degree(){let e=this.he_;if(void 0===e)return 0;let t=0;do{t++,e=e.nextAroundNode}while(e!==this.he_);return t}setHalfedge(e){this.he_=e}}class J{constructor(){this.halfedge_=void 0,this.id_=-1}get halfedge(){return this.halfedge_}get degree(){let e=0,t=this.halfedge_;do{e++,t=t.next}while(t!==this.halfedge_);return e}get nbEdges(){return this.degree}get nbNodes(){return this.degree}get isOnBorder(){let e=this.halfedge_;do{if(e.opposite.isBorder)return!0;e=e.next}while(e!==this.halfedge_);return!1}get barycenter(){let e=[0,0,0],t=this.halfedge_,s=0;do{const i=t.node.pos;e=e.map(((e,t)=>e+i[t])),t=t.next,++s}while(t!==this.halfedge_);return e=e.map((e=>e/s)),e}get isTriangle(){return this.halfedge_.next.next.next===this.halfedge_}get id(){return this.id_}get opposite(){return this.halfedge_.opposite.facet}setId(e){this.id_=e}setHalfedge(e){this.halfedge_=e}get nodes(){const e=[];let t=this.halfedge_;do{e.push(t.node),t=t.next}while(t!==this.halfedge_);return e}get nodeIds(){const e=[];let t=this.halfedge_;do{e.push(t.node.id),t=t.next}while(t!==this.halfedge_);return e}get area(){return $(this)}get normal(){return V(this)}}class Y{constructor(){this.node_=void 0,this.opposite_=void 0,this.next_=void 0,this.prev_=void 0,this.facet_=void 0}get opposite(){return this.opposite_}get next(){return this.next_}get prev(){return this.prev_}get facet(){return this.facet_}get node(){return this.node_}get length(){const e=this.node.pos,t=this.prev.node.pos,s=[0,0,0];for(let i=0;i<3;++i)s[i]=e[i]-t[i];return Math.sqrt(s[0]**2+s[1]**2+s[2]**2)}get nextAroundNode(){return this.opposite.prev}get prevAroundNode(){return this.next.opposite}get isBorder(){return void 0===this.facet_}get isBorderEdge(){return this.isBorder||this.opposite.isBorder}setOpposite(e){this.opposite_=e}setNext(e){this.next_=e}setPrev(e){this.prev_=e}setFacet(e){this.facet_=e}setNode(e){this.node_=e}}class Q{constructor(){this.items=[]}push(e){this.items.push(e)}pop(){if(0!==this.items.length)return this.items.pop()}shift(){if(0!==this.items.length)return this.items.shift()}clear(){this.items=[]}get first(){return 0===this.items.length?void 0:this.items[0]}get top(){return 0===this.items.length?void 0:this.items[this.items.length-1]}get last(){return this.top}get isEmpty(){return 0===this.items.length}get count(){return this.items.length}toString(){let e="";for(var t=0;t<this.items.length;t++)e+=this.items[t]+" ";return e}forEach(e){return this.items.forEach(e,this)}map(e){return this.items.map(e,this)}}class X{constructor(){this.list_=[]}registerObserver(e){this.list_.push(e)}unregisterObserver(e){const t=this.list_.indexOf(e);t>-1&&this.list_.splice(t,1)}notifyRemove(e){this.list_.forEach((t=>t.notifiedRemove(e)))}}class Z{constructor(){this.node_observable_=new X,this.facet_observable_=new X,this.halfedge_observable_=new X,this.surface_=void 0,this.facet_node_=new Array,this.nodes_=new Array,this.current_facet_=void 0,this.current_node_=void 0,this.current_halfedge_=void 0,this.first_node_in_facet_=void 0,this.first_halfedge_in_facet_=void 0,this.star_=new Map}beginSurface(e){this.surface_=e}endSurface(){this.terminateSurface(),this.nodes_=[]}reset(){}addNode(e){return this.addNodeInternal(e[0],e[1],e[2])}beginFacet(){this.facet_node_=[]}endFacet(){const e=this.facet_node_.length;if(e<3)throw new Error("SurfaceBuilder: Facet with less than 3 vertices");for(let t=0;t<e;t++){const s=(t+1)%e;void 0!==this.findHalfedgeBetween(this.facet_node_[t],this.facet_node_[s])&&(this.facet_node_[t]=this.copyNode(this.facet_node_[t]),this.facet_node_[s]=this.copyNode(this.facet_node_[s]))}this.beginFacetInternal();for(let t=0;t<e;t++)this.addNodeToFacetInternal(this.facet_node_[t]);return this.endFacetInternal(),this.currentFacet()}addNodeToFacet(e){e<0||e>=this.nodes_.length||this.facet_node_.push(this.nodes_[e])}surface(){return this.surface_}insertInStar(e){this.star_.set(e,[])}getOrCreateFromStar(e){return!1===this.star_.has(e)?(this.star_.set(e,[]),this.star_.get(e)):this.star_.get(e)}deleteFromStarIfEmpty(e){const t=this.star_.get(e);void 0!==t&&0===t.length&&this.star_.delete(e)}currentFacet(){return this.current_facet_}notifyRemoveNode(e){this.node_observable_.notifyRemove(e)}registerFacetObserser(e){this.facet_observable_.registerObserver(e)}unregisterFacetObserser(e){this.facet_observable_.unregisterObserver(e)}notifyRemoveFacet(e){this.facet_observable_.notifyRemove(e)}notifyRemoveHalfedge(e){this.halfedge_observable_.notifyRemove(e)}reindexNodes(){let e=0;this.nodes_.forEach((t=>t.setId(e++)))}reindexFacets(){let e=0;this.surface_.facets.forEach((t=>t.setId(e++)))}setSurface(e){this.surface_=e}addNodeInternal(e,t,s){const i=this.newNode();return Array.isArray(e)?i.setPos(e[0],e[1],e[2]):i.setPos(e,t,void 0!==s?s:0),this.nodes_.push(i),this.insertInStar(i),i}beginFacetInternal(){this.current_facet_=this.newFacet(),this.first_node_in_facet_=void 0,this.current_node_=void 0,this.first_halfedge_in_facet_=void 0,this.current_halfedge_=void 0}endFacetInternal(){const e=this.newHalfedgeBetween(this.current_node_,this.first_node_in_facet_);this.link(this.current_halfedge_,e,1),this.link(e,this.first_halfedge_in_facet_,1)}addNodeToFacetInternal(e){if(void 0===this.first_node_in_facet_)this.first_node_in_facet_=e;else{const t=this.newHalfedgeBetween(this.current_node_,e);void 0===this.first_halfedge_in_facet_?(this.first_halfedge_in_facet_=t,this.makeFacetKey(this.first_halfedge_in_facet_)):this.link(this.current_halfedge_,t,1),this.current_halfedge_=t}this.current_node_=e}copyNode(e){const t=this.newNode();return t.setPos(e.pos[0],e.pos[1],e.pos[2]),t}link(e,t,s){switch(s){case 1:e.setNext(t),t.setPrev(e);break;case 2:e.setOpposite(t),t.setOpposite(e)}}setNodeOnOrbit(e,t){let s=e;do{s.setNode(t),s=s.nextAroundNode}while(s!==e)}setFacetOnOrbit(e,t){let s=e;do{s.setFacet(t),s=s.next}while(s!==e)}makeNodeKey(e,t){void 0===t?e.node.setHalfedge(e):(t.setHalfedge(e),e.setNode(t))}makeFacetKey(e,t){void 0===t?e.facet.setHalfedge(e):(t.setHalfedge(e),e.setFacet(t))}newEdge(){return this.surface_.newEdge()}newNode(e){return this.surface_.newNode(e)}newHalfedge(e){return this.surface_.newHalfedge(e)}newFacet(e){return this.surface_.newFacet(e)}deleteEdge(e){this.notifyRemoveHalfedge(e),this.notifyRemoveHalfedge(e.opposite),this.surface_.deleteEdge(e)}deleteNode(e){this.notifyRemoveNode(e),this.surface_.deleteNode(e)}deleteHalfedge(e){this.notifyRemoveHalfedge(e),this.surface_.deleteHalfedge(e)}deleteFacet(e){void 0!==e&&(this.notifyRemoveFacet(e),this.surface_.deleteFacet(e))}setNodeHalfedge(e,t){e.setHalfedge(t)}setHalfedgeOpposite(e,t){e.setOpposite(t)}setHalfedgeNext(e,t){e.setNext(t)}setHalfedgePrev(e,t){e.setPrev(t)}setHalfedgeFacet(e,t){e.setFacet(t)}setHalfedgeNode(e,t){e.setNode(t)}setFacetHalfedge(e,t){e.setHalfedge(t)}newHalfedgeBetween(e,t){console.assert(void 0===this.findHalfedgeBetween(e,t));const s=this.newHalfedge();this.setHalfedgeFacet(s,this.current_facet_),this.setHalfedgeNode(s,t);const i=this.findHalfedgeBetween(t,e);return void 0!==i&&this.link(s,i,2),this.getOrCreateFromStar(e).push(s),this.setNodeHalfedge(t,s),s}findHalfedgeBetween(e,t){let s;return this.getOrCreateFromStar(e).forEach((e=>{e.node==t&&(s=e)})),s}nodeIsManifold(e){return void 0===e.halfedge?(console.warn(`SurfaceBuilder: Warning, isolated vertex (${e.pos})`),!0):this.getOrCreateFromStar(e).length===e.degree}splitNonManifoldNode(e){if(this.nodeIsManifold(e))return!1;const t=new Set;for(this.getOrCreateFromStar(e).forEach((e=>t.add(e))),this.disconnectNode(e.halfedge.opposite,e,t),console.assert(0!==t.size);0!==t.size;){const s=this.copyNode(e),i=t[0];this.disconnectNode(i,s,t)}return!0}disconnectNode(e,t,s){let i=e;for(this.insertInStar(t),console.assert(s.has(i));!i.isBorder&&(i=i.prev.opposite,i!==e););this.setNodeHalfedge(t,i.opposite);let r=i;for(this.setHalfedgeNode(r.opposite,t),this.getOrCreateFromStar(t).push(r),s.delete(r);!r.opposite.isBorder&&(r=r.opposite.next,r!==i);)this.setHalfedgeNode(r.opposite,t),s.delete(r),this.getOrCreateFromStar(t).push(r);i.isBorder&&this.link(r.opposite,i,1)}terminateSurface(){this.updateBorder(this.star_),this.nodes_.forEach((e=>{this.splitNonManifoldNode(e)})),this.nodes_.forEach((e=>{this.deleteFromStarIfEmpty(e)})),this.reindexNodes(),this.reindexFacets()}updateBorder(e){const t=[];this.surface_.halfedges.forEach((e=>{void 0===e.opposite&&t.push(e)})),0!==t.length&&t.forEach((t=>{const s=this.newHalfedge();this.link(s,t,2),this.setHalfedgeNode(s,t.prev.node),e.get(t.node).push(s)})),this.surface_.halfedges.forEach((e=>{if(void 0===e.facet){let t=e.opposite;for(;void 0!==t.facet;)t=t.prev.opposite;this.setHalfedgeNext(e,t);let s=e.opposite;for(;void 0!==s.facet;)s=s.next.opposite;this.setHalfedgePrev(e,s)}}))}}class ee{constructor(){this.list_n_=[],this.list_e_=[],this.list_f_=[],this.bbox_=void 0}beginDescription(){this.list_n_=[],this.list_e_=[],this.list_f_=[]}endDescription(){}static create(e,t){let s,r;s=i.Serie.isSerie(e)?e:i.Serie.create({array:e,itemSize:3}),r=i.Serie.isSerie(t)?t:i.Serie.create({array:t,itemSize:3});let n=new ee;return n.build(s,r),n}get nodesAsSerie(){const e=new Array(3*this.list_n_.length).fill(0);for(let t=0;t<this.list_n_.length;++t){const s=this.list_n_[t],i=3*t;e[i]=s.pos[0],e[i+1]=s.pos[1],e[i+2]=s.pos[2]}return i.Serie.create({array:e,itemSize:3})}get trianglesAsSerie(){const e=new Array(3*this.list_f_.length).fill(0);for(let t=0;t<this.list_f_.length;++t){const s=this.list_f_[t].nodeIds,i=3*t;e[i]=s[0],e[i+1]=s[1],e[i+2]=s[2]}return i.Serie.create({array:e,itemSize:3})}build(e,s){const i=s.itemSize,r=new Z;r.beginSurface(this);let n=new t;e.forEach((e=>{r.addNode(e),n.grow(e)})),this.bbox_=n,s.forEach((e=>{r.beginFacet();for(let t=0;t<i;++t)r.addNodeToFacet(e[t]);r.endFacet()})),r.endSurface()}get bbox(){return this.bbox_}get nbNodes(){return this.list_n_.length}get nodes(){return this.list_n_}node(e){return this.list_n_[e]}forEachNode(e){const t=this.list_n_;for(let s=0;s<t.length;++s)e(t[s],s)}get halfedges(){return this.list_e_}get nbHalfedges(){return this.list_e_.length}halfedge(e){return this.list_e_[e]}forEachHalfedge(e){const t=this.list_e_;for(let s=0;s<t.length;++s)e(t[s],s)}get facets(){return this.list_f_}get nbFacets(){return this.list_f_.length}facet(e){return this.list_f_[e]}forEachFace(e){const t=this.list_f_;for(let s=0;s<t.length;++s)e(t[s],s)}get borderEdges(){const e=[];return this.halfedges.forEach((t=>{void 0===t.facet&&e.push(t)})),e}get bordersAsSerie(){const e=[];return this.halfedges.forEach((t=>{if(void 0===t.facet){const s=t.node,i=t.opposite.node;e.push(s.pos[0],s.pos[1],s.pos[2]),e.push(i.pos[0],i.pos[1],i.pos[2])}})),i.Serie.create({array:e,itemSize:3})}get borderIdsAsSerie(){const e=[];return this.halfedges.forEach((t=>{if(void 0===t.facet){const s=t.node,i=t.opposite.node;e.push(s.id,i.id)}})),i.Serie.create({array:e,itemSize:1})}get borderNodes(){const e=[];return this.halfedges.forEach((t=>{void 0===t.facet&&e.push(t.node,t.opposite.node)})),e}deleteEdge(e){this.deleteHalfedge(e.opposite),this.deleteHalfedge(e)}deleteHalfedge(e){this.list_e_=this.list_e_.filter((t=>t===e))}deleteFacet(e){this.list_f_=this.list_f_.filter((t=>t===e))}newHalfedge(e){const t=new Y;return this.addNewHalfedge(t),t}newNode(e){const t=new W;return void 0!==e&&t.setPos(e.pos[0],e.pos[1],e.pos[2]),this.addNewNode(t),t}deleteNode(e){this.list_n_=this.list_n_.filter((t=>t===e))}addNewNode(e){this.list_n_.push(e)}newFacet(e){const t=new J;return this.addNewFacet(t),t}newEdge(){const e=this.newHalfedge(),t=this.newHalfedge();return e.setOpposite(t),t.setOpposite(e),e.setNext(t),t.setNext(e),e.setPrev(t),t.setPrev(e),e}getConnectedComponent(e,t){const s=new Map;this.nodes.forEach((e=>s.set(e,!1)));const i=new Q;for(i.push(e);!i.isEmpty;){const e=i.top;if(i.pop(),!s.get(e)){s.set(e,!0),t.push(e);let r=e.halfedge;do{const e=r.opposite.node;s.get(e)||i.push(e),r=r.nextAroundNode}while(r!==e.halfedge)}}}addNewHalfedge(e){this.list_e_.push(e)}addNewFacet(e){this.list_f_.push(e)}}function te(e,t){let s=e.halfedge,i=0;do{t(s.opposite.node,i++),s=s.nextAroundNode}while(s!==e.halfedge)}function se(e,t){let s=e,i=0;do{t(s.opposite.node,i++),s=s.nextAroundNode}while(s!==e)}function ie(e,t){let s=e.halfedge,i=0;do{t(s.facet,i++),s=s.nextAroundNode}while(s!==e.halfedge)}class re extends Z{constructor(e){super(),this.is_modified_=!1,this.setSurface(e)}beginModif(){this.is_modified_=!0}endModif(){this.is_modified_=!1,this.reindexNodes(),this.reindexFacets()}eraseFacet(e){console.assert(this.is_modified_),console.assert(void 0!==e);let t=e.halfedge;console.assert(!t.isBorder);const s=[];this.deleteFacet(t.facet);let i=t;do{this.setHalfedgeFacet(t,void 0);const e=t.next,i=t.opposite.isBorder,r=e.opposite.isBorder;if(i)r&&(e.opposite.next==t.opposite?this.deleteNode(t.node):(this.makeNodeKey(t.opposite.prev),this.link(t.opposite.prev,e.opposite.next,1))),s.push(t);else if(t.next.opposite.isBorder&&(this.link(t,t.next.opposite.next,1),this.makeNodeKey(t)),t.prev.opposite.isBorder){const e=t.prev.opposite.prev;this.link(e,t,1),this.makeNodeKey(e)}t=e}while(t!==i);s.forEach((e=>this.deleteEdge(e)))}eraseNode(e){console.assert(this.is_modified_),console.assert(e),console.assert(e.halfedge);const t=[];let s=e.halfedge;do{s.facet&&t.push(s.facet),s=s.nextAroundNode}while(s!==e.halfedge);return t.forEach((e=>this.eraseFacet(e))),!0}collapse_node(e,t=!0){if(console.assert(this.is_modified_),e.halfedge.opposite.isBorder&&e.halfedge.next.opposite.isBorder)return;{let t,s=e.halfedge;do{if(s.isBorder){t=s;break}s=s.nextAroundNode}while(s!==e.halfedge);if(void 0!==t){if(t.prev==t.next)return;this.addFacetToBorder(t.prev,t.next)}}let s=e.halfedge.prev,i=s;do{let t=i.next;t.node===e&&(t=t.opposite.next,this.deleteEdge(i.next),this.deleteFacet(i.facet),this.link(i,t,1),this.makeNodeKey(i)),i=t}while(i!==s);return this.setFacetOnOrbit(s,this.newFacet()),this.makeFacetKey(s),this.deleteNode(e),t&&this.triangulateFacet(s),s}addFacetToBorder(e,t){console.assert(this.is_modified_),console.assert(e.isBorder),console.assert(t.isBorder),console.assert(e!==t),console.assert(this.halfedgesOnSameFacet(e,t));let s=e.next,i=t.next,r=this.newEdge();return this.link(r,s,1),this.setHalfedgeNode(r,e.node),this.link(t,r,1),this.setHalfedgeNode(r.opposite,t.node),this.link(e,r.opposite,1),this.link(r.opposite,i,1),this.setFacetOnOrbit(r,this.newFacet()),this.makeFacetKey(r),r}halfedgesOnSameFacet(e,t){let s=e;do{if(s==t)return!0;s=s.next}while(s!==e);return!1}canSplitFacet(e,t){return e!==t&&!!this.halfedgesOnSameFacet(e,t)&&e.next!==t&&t.next!==e}splitFacet(e,t){if(console.assert(this.is_modified_),!this.canSplitFacet(e,t))return!1;let s=this.newEdge();return this.link(s.opposite,t.next,1),this.link(s,e.next,1),this.link(t,s,1),this.link(e,s.opposite,1),this.setHalfedgeNode(s,e.node),this.setHalfedgeNode(s.opposite,t.node),this.makeFacetKey(s.opposite,e.facet),this.setFacetOnOrbit(s,this.newFacet()),this.makeFacetKey(s),!0}triangulateFacet(e){console.assert(this.is_modified_);let t=e.next.next;for(;t.next!=e;)this.splitFacet(e,t),t=t.next.opposite.next}createCenterNode(e){console.assert(this.is_modified_);let t=e.halfedge,s=this.newNode();const i=e.barycenter;this.deleteFacet(e);let r=!0,n=t;do{let e=n.next,t=this.newEdge();this.link(n,t,1),this.link(t.opposite,e,1),this.setHalfedgeNode(t,s),this.setHalfedgeNode(t.opposite,n.node),r?(r=!1,this.makeNodeKey(t)):(this.link(t,n.prev,1),this.setFacetOnOrbit(n,this.newFacet()),this.makeFacetKey(n)),n=e}while(n!==t);return this.link(t.next,t.prev,1),this.setFacetOnOrbit(t,this.newFacet()),this.makeFacetKey(t),s.setPos(i),s}canSwitchEdge(e){return!(e.isBorder||e.opposite.isBorder||!e.facet||!e.opposite.facet||!e.facet.isTriangle||!e.opposite.facet.isTriangle)}switchEdge(e){if(console.assert(this.is_modified_),!this.canSwitchEdge(e))return!1;let t=e.next,s=e.next.next,i=e.opposite,r=i.next,n=i.next.next;return this.deleteFacet(e.facet),this.deleteFacet(i.facet),this.deleteEdge(e),e=this.newHalfedge(),i=this.newHalfedge(),this.link(e,i,2),this.setHalfedgeNode(e,t.node),this.setHalfedgeNode(i,r.node),this.link(e,s,1),this.link(s,r,1),this.link(r,e,1),this.makeNodeKey(e),this.makeNodeKey(s),this.makeNodeKey(r),this.setFacetOnOrbit(e,this.newFacet()),this.makeFacetKey(e),this.link(i,n,1),this.link(n,t,1),this.link(t,i,1),this.makeNodeKey(n),this.setFacetOnOrbit(i,this.newFacet()),this.makeFacetKey(i),!0}fillHole(e,t){if(console.assert(this.is_modified_),!e.isBorder)return;let s=this.newFacet();return this.setFacetOnOrbit(e,s),this.makeFacetKey(e),t&&this.triangulateFacet(e),e}makePolygon(e){let t,s;console.assert(this.is_modified_);for(let i=0;i<e;i++)void 0===t?(t=this.newEdge(),s=t,this.makeFacetKey(s,this.newFacet())):(this.link(s,this.newEdge(),1),this.link(s.next.opposite,s.opposite,1),this.setHalfedgeFacet(s.next,s.facet),this.setHalfedgeNode(s.next.opposite,s.node),s=s?s.next:void 0),this.makeNodeKey(s,this.newNode());return this.link(s,t,1),this.link(t.opposite,s.opposite,1),this.setHalfedgeNode(t.opposite,s.node),t}makeTriangle(e,t,s){if(console.assert(this.is_modified_),void 0===e)return this.makePolygon(3);if(console.assert(void 0!==t),console.assert(void 0!==s),Array.isArray(e)){let i=this.makeTriangle();return i.node.setPos(e),i.next.node.setPos(t),i.next.next.node.setPos(s),i}let i,r;const n=Array(3).fill(void 0);n[0]=e,n[1]=t,n[2]=s;for(let e=0;e<3;e++){if(void 0===i)i=this.newEdge(),r=i,this.makeFacetKey(r,this.newFacet());else{if(this.link(r,this.newEdge(),1),this.link(r.next.opposite,r.opposite,1),this.setHalfedgeFacet(r.next,r.facet),this.setHalfedgeNode(r.next.opposite,r.node),!r)throw new Error("cur is undefined");r=r.next}this.makeNodeKey(r,n[e])}return this.link(r,i,1),this.link(i.opposite,r.opposite,1),this.setHalfedgeNode(i.opposite,r.node),i}halfedgeBetween(e,t){let s=t.halfedge;do{if(s.opposite.node==e)return s;s=s.nextAroundNode}while(s!==t.halfedge)}swapNode(e,t){let s=e;e=t,t=s}createFacet(e,t,s){console.assert(this.is_modified_);let i=this.halfedgeBetween(e,t),r=this.halfedgeBetween(t,s),n=this.halfedgeBetween(s,e);void 0!==i&&i.node===t&&this.swapNode(e,t),void 0!==r&&r.node===s&&this.swapNode(t,s),void 0!==n&&n.node===e&&this.swapNode(s,e);let o=this.makeTriangle(e,t,s);return i&&this.glue(i.isBorder?i:i.opposite,o.next.isBorder?o.next:o.next.opposite),r&&this.glue(r.isBorder?r:r.opposite,o.next.next.isBorder?o.next.next:o.next.next.opposite),n&&this.glue(n.isBorder?n:n.opposite,o.isBorder?o:o.opposite),!0}canGlue(e,t){return!(!e.isBorder||!t.isBorder||e.opposite.facet==t.opposite.facet||this.halfedgeExistsBetweenNodes(e.node,t.opposite.node)||this.halfedgeExistsBetweenNodes(t.node,e.opposite.node)||!this.canMergeNodes(e,t.opposite)||!this.canMergeNodes(t,e.opposite))}barycenter(e,t){return[(e[0]+t[0])/2,(e[1]+t[1])/2,(e[2]+t[2])/2]}glue(e,t){if(console.assert(this.is_modified_),!this.canGlue(e,t))return!1;const s=this.barycenter(e.node.pos,t.opposite.node.pos),i=this.barycenter(t.node.pos,e.opposite.node.pos),r=e.node,n=t.node,o=e.opposite.node,h=t.opposite.node;return o!=n&&(this.setNodeOnOrbit(t,o),this.deleteNode(n)),h!=r&&(this.setNodeOnOrbit(e,h),this.deleteNode(r)),this.link(t.prev,e.next,1),this.link(e.prev,t.next,1),this.link(e.opposite,t.opposite,2),this.makeNodeKey(e.opposite),this.makeNodeKey(t.opposite),h.setPos(s),o.setPos(i),this.deleteHalfedge(e),this.deleteHalfedge(t),!0}canMergeNodes(e,t){return e.node===t.node||this.orbitsAreCompatible(e,t)&&this.orbitsAreCompatible(t,e)}halfedgeExistsBetweenNodes(e,t){let s=e.halfedge;do{if(s.opposite.node==t)return!0;s=s.nextAroundNode}while(s!==e.halfedge);return!1}orbitsAreCompatible(e,t){let s=e;do{let i=0,r=s.opposite,n=t;do{let s=n.opposite;if(r.node===s.node||r.node===e.opposite.node&&s.node===t.opposite.node||r.node===t.opposite.node&&s.node===e.opposite.node){if(!(r.opposite.isBorder&&s.isBorder||r.isBorder&&s.opposite.isBorder))return!1;i++}n=n.nextAroundNode}while(n!==t);if(i>1)return!1;s=s.nextAroundNode}while(s!==e);return!0}canUnglue(e){return!e.isBorderEdge&&(e.node.isOnBorder||e.opposite.node.isOnBorder)}unglue(e,t){if(console.assert(this.is_modified_),t&&!this.canUnglue(e))return!1;if(e.isBorderEdge)return!1;let s=e.opposite,i=e.node,r=s.node,n=i.isOnBorder,o=r.isOnBorder;console.assert(!t||n||o);let h=this.newEdge(),a=h.opposite;if(this.link(e,h,2),this.link(s,a,2),o){let t=e.prev.opposite;for(;!t.isBorder;)t=t.prev.opposite;console.assert(t!=e);let i=s.next.opposite;for(;!i.isBorder;)i=i.next.opposite;console.assert(i!=s),console.assert(i.node==r),console.assert(i.next==t),this.link(h,t,1),this.link(i,a,1),this.setNodeOnOrbit(h,this.newNode(r)),this.makeNodeKey(h),this.makeNodeKey(s)}else this.setHalfedgeNode(h,r);if(n){let t=e.next.opposite;for(;!t.isBorder;)t=t.next.opposite;console.assert(t!=e);let r=s.prev.opposite;for(;!r.isBorder;)r=r.prev.opposite;console.assert(r!=s),console.assert(t.next==r),this.link(t,h,1),this.link(a,r,1),this.setNodeOnOrbit(a,this.newNode(i)),this.makeNodeKey(a),this.makeNodeKey(e)}else this.setHalfedgeNode(a,i);return!0}flipNormals(){console.assert(this.is_modified_),this.surface_.facets.forEach((e=>{this.flipNormal(e.halfedge)})),this.surface_.halfedges.forEach((e=>{e.isBorder&&e.node===e.opposite.node&&this.flipNormal(e)}))}flipNormal(e){if(console.assert(this.is_modified_),void 0===e)return;let t=e,s=e,i=e;e=e.next;let r=i.node;for(;e!==t;){let t=e.node;this.setHalfedgeNode(e,r),this.setNodeHalfedge(e.node,e),r=t;let i=e.next;this.setHalfedgeNext(e,s),this.setHalfedgePrev(e,i),s=e,e=i}this.setHalfedgeNode(i,r),this.setNodeHalfedge(i.node,i);let n=i.next;this.setHalfedgeNext(i,s),this.setHalfedgePrev(i,n)}zipEdge(e){let t,s;console.assert(this.is_modified_);let i=e.halfedge;do{i.isBorder&&(void 0===t?t=i:s=i),i.opposite.isBorder&&(void 0===t?t=i.opposite:s=i.opposite),i=i.nextAroundNode}while(i!==e.halfedge);return void 0!==t&&void 0!==s&&this.glue(t,s),!0}}class ne{constructor(e){this._valid=!0,this._name=e}get name(){return this._name}get valid(){return this._valid}set name(e){this._name=e}set valid(e){this._valid=e}}class oe extends ne{constructor(e,t,s="function-action"){super(s),this._do=void 0,this._undo=void 0,this._do=e,this._undo=t}do(){this._do()}undo(){this._undo()}}class he extends ne{constructor(e="macro-action"){super(e),this._actions=[]}register(e,t){e instanceof ne?!0===e.valid&&this._actions.push(e):(console.assert(void 0!==t),this._actions.push(new oe(e,t)))}do(){this._actions.forEach((e=>e.do()))}undo(){this._actions.reverse().forEach((e=>e.undo())),this._actions.reverse()}}class ae{constructor(e=10){this._undo=new Q,this._do=new Q,this._size=10,this._size=e}execute(e,t,s){let i;if(e instanceof ne){if(!1===e.valid)return!1;i=e}else console.assert(void 0!==t),i=new oe(e,t,s);return this._do.push(i),i.do(),this._do.count>this._size&&this._do.shift(),0!==this._undo.count&&this._undo.clear(),!0}undo(e=1){for(let t=0;t<e;++t)this.__undo()}redo(e=1){for(let t=0;t<e;++t)this.__redo()}clear(){this._do.clear(),this._undo.clear()}get maxSize(){return this._size}set maxSize(e){this._size=e}get undoActionNames(){return this._do.map((e=>e.name)).reverse()}get redoActionNames(){return this._undo.map((e=>e.name)).reverse()}__undo(){if(0===this._do.count)return;const e=this._do.last;return this._do.pop(),e.undo(),this._undo.push(e),this._undo.count>this._size&&this._undo.shift(),e}__redo(){if(0===this._undo.count)return;const e=this._undo.last;return this._undo.pop(),e.do(),this._do.push(e),this._do.count>this._size&&this._do.shift(),e}}class de extends ne{constructor(e,t){super("Move node"),this.n=e,this.translation=t,this.node=void 0,void 0===e&&(this.valid=!1),this.node=e}do(){const e=this.node.pos.map(((e,t)=>e+this.translation[t]));this.node.setPos(e)}undo(){const e=this.node.pos.map(((e,t)=>e-this.translation[t]));this.node.setPos(e)}}class ce extends class{notifiedRemove(e){}}{constructor(){super(...arguments),this.facets=[]}notifiedRemove(e){this.facets.push(e)}clear(){this.facets=[]}}class le extends ne{constructor(e,t){super("Fill hole"),this.surface=e,this.h=t,this.edt=void 0,this.observer=new ce,this.edt=new re(e),void 0!==t&&!1!==t.isBorder||(this.valid=!1)}do(){this.observer.clear(),this.edt.registerFacetObserser(this.observer),this.edt.beginModif(),this.edt.fillHole(this.h,!0),this.edt.endModif(),this.edt.unregisterFacetObserser(this.observer)}undo(){this.edt.beginModif(),this.observer.facets.forEach((e=>this.edt.deleteFacet(e))),this.edt.endModif()}}class ue{constructor(e,t){this.surface=void 0,this.surface=ee.create(e,t)}interpolate({serie:e,atTriangles:t=!1,localCsys:s=!0}){if(3!==e.itemSize)throw new Error("For the moment, only series with itemSize = 3 is allowed");if(e.count!==this.surface.nbFacets)throw new Error(`serie must be either defined at triangles (count=${this.surface.nbFacets}). Got count=${e.itemSize}`);if(1==t){const t=e.image(e.count,3),i=t.array;let r=0;return this.surface.forEachFace(((t,n)=>{let h=e.itemAt(n);!1===s&&(h=new o(t.normal).toGlobal(h)),i[r++]=h[0],i[r++]=h[1],i[r++]=h[2]})),t}{const t=e.image(this.surface.nbNodes,3),i=t.array,r=new Array(this.surface.nbNodes).fill([0,0,0]),n=new Array(this.surface.nbNodes).fill(0);this.surface.forEachFace(((t,i)=>{const h=t.nodeIds;let a=e.itemAt(i);!1===s&&(a=new o(t.normal).toGlobal(a));for(let e=0;e<3;++e){for(let t=0;t<3;++t)r[h[e]][t]+=a[t];n[h[e]]++}for(let e=0;e<this.surface.nbNodes;++e){const t=n[e];for(let s=0;s<3;++s)r[e][s]/=t}}));let h=0;return r.forEach((e=>{i[h++]=e[0],i[h++]=e[1],i[h++]=e[2]})),t}}}function fe(e){if(3!==e.itemSize)throw new Error("Only triangles are allowed");return e.map((e=>[e[0],e[2],e[1]]))}function ge(e,t){return ee.create(e,t).bordersAsSerie}function pe(e,t,s){let i=!1;if(2!==s.itemSize&&3!==s.itemSize)throw new Error("bad Serie for polyline. Should be coords in 2D or 3D");const r=s.itemSize,n=s.count,o=s.array;for(let s=0,h=n-1;s<n;h=s++){const n=o[r*s],a=o[r*s+1],d=o[r*h+1];a>t!=d>t&&e<(o[r*h]-n)*(t-a)/(d-a)+n&&(i=!i)}return i}function _e(s,i=100){const r=(0,e.minMax)(s),n=new t([r[0],r[1],3===s.itemSize?r[2]:0],[r[3],r[4],3===s.itemSize?r[5]:0]);let o=0;for(;;){const e=n.randPoint();if(pe(e[0],e[1],s))return[e[0],e[1]];if(o>i)return;o++}}class me{constructor({positions:e,indices:t,attribute:s,nx:i,ny:r,flatten:n=!0,scaling:o=1}){this.positions=void 0,this.indices=void 0,this.attribute=void 0,this.bg=void 0,this.eps=1e-7,this.indices=t,this.attribute=s,this.positions=e.map((e=>[e[0]*o,e[1]*o,n?0:e[2]])),this.bg=H({positions:this.positions,indices:this.indices,dims:[i,r]}),this.eps=1e-4*Math.max(this.bg.bbox.width,this.bg.bbox.height)}get backgroundGrid(){return this.bg}interpolate(t){const s=(t,s,i,r)=>{const n=e=>e>=-this.eps&&e<=1+this.eps,o=(0,e.barycentric2)(t,s,i,r);return n(o[0])&&n(o[1])&&n(o[2])},i=this.bg.candidates(t);if(i&&i.length)for(let r=0;r<i.length;++r){const n=i[r].obj,o=this.indices.itemAt(n),h=this.positions.itemAt(o[0]),a=this.positions.itemAt(o[1]),d=this.positions.itemAt(o[2]);if(s(t,h,a,d)){const s=this.attribute.itemAt(o[0]),i=this.attribute.itemAt(o[1]),r=this.attribute.itemAt(o[2]);return(0,e.triangleLerp2D)([t[0],t[1]],[h[0],h[1]],[a[0],a[1]],[d[0],d[1]],s,i,r)}}}}class xe{constructor(e,t,s=0){this.positions=e,this.indices=t,this.surface_=void 0,this.map=new Map,this.constrainedNodes=[],this.maxIter_=618,this.eps_=382e-8,this.epsilon_=.5,this.dataSize=1,this.surface_=ee.create(e,t),Array.isArray(s)?(this.surface_.forEachNode((e=>this.map.set(e,[...s]))),this.dataSize=s.length):(this.surface_.forEachNode((e=>this.map.set(e,new Array(1).fill(s)))),this.dataSize=1)}get surface(){return this.surface_}set maxIter(e){this.maxIter_=e}set eps(e){this.eps_=e}set epsilon(e){this.epsilon_=e}constrainsBorders(e){this.surface_.borderNodes.forEach((t=>this.addConstraint(t,e)))}addConstraint(e,t){if(Array.isArray(t)){if(t.length!==this.dataSize)throw new Error(`array length problem. Should be ${this.dataSize}`)}else if(1!==this.dataSize)throw new Error(`value problem. Should be an array of size ${this.dataSize}`);if(Array.isArray(e)){let s=this.findNode(e);s&&!1===this.constrainedNodes.includes(s)&&this.pushNode(s,t)}else!1===this.constrainedNodes.includes(e)&&this.pushNode(e,t)}solve({name:e="property",record:t=!1}){let s=1,r=0;const n=new Map(this.map),o=i.DataFrame.create({series:{positions:this.positions,indices:this.indices}});for(;s>this.eps_&&(s=0,this.surface_.forEachNode((e=>{if(!1===this.constrainedNodes.includes(e)){let t=new Array(this.dataSize).fill(0),i=0;te(e,(e=>{i++,this.add(this.map.get(e),t)})),this.scale(t,1/i);let r=this.map.get(e);this.scale(t,this.epsilon_),this.add(this.scale(r,1-this.epsilon_),t),this.map.set(e,t),s+=this.norm2(t,this.scale(r,1/(1-this.epsilon_)))}})),s=Math.sqrt(s),r++,!(r>this.maxIter_)););console.log("HarmonicDiffusion nb iter:",r),console.log("HarmonicDiffusion conv   :",s),r=0;const h=new Array(this.map.size*this.dataSize).fill(0);if(this.map.forEach((e=>e.forEach((e=>h[r++]=e)))),o.series[e]=i.Serie.create({array:h,itemSize:this.dataSize}),t){r=0;const e=[];n.forEach((t=>{t.forEach((t=>{e.push(h[r]-t),console.log(h[r]-t),r++}))})),o.series.record=i.Serie.create({array:e,itemSize:this.dataSize})}return o}add(e,t){return e.forEach(((e,s)=>t[s]+=e)),t}norm2(e,t){return e.reduce(((e,s,i)=>e+(s-t[i])**2),0)}scale(e,t){for(let s=0;s<e.length;++s)e[s]*=t;return e}pushNode(e,t){Array.isArray(t)?this.map.set(e,t):this.map.set(e,[t]),this.constrainedNodes.push(e)}findNode(e){let t,s=Number.POSITIVE_INFINITY;return this.surface_.forEachNode((i=>{const r=(i.pos[0]-e[0])**2+(i.pos[1]-e[1])**2+(i.pos[2]-e[2])**2;r<s&&(s=r,t=i)})),t}}function ve(e){return e*Math.PI/180}function ye(e){const t=new we(e);return{positions:t.positions,indices:t.indices}}class we{constructor(e){if(void 0===e)throw new Error("data for trace is undefned");if(2!==e.points.itemSize&&3!==e.points.itemSize)throw new Error("points must be a Serie with itemSize equals to 2 or 3");this.info=e,void 0===this.info.depth&&(this.info.depth=.1),void 0===this.info.dip&&(this.info.dip=30),void 0===this.info.dipDirection&&(this.info.dipDirection=90),void 0===this.info.rows&&(this.info.rows=5),void 0===this.info.id&&(this.info.id="no-name"),this.perform()}pt(e){return this.info.points.itemAt(e)}perform(){const e=this.info.rows,t=this.info.points.count,s=ve(this.info.dip),r=ve(this.info.dipDirection),n=this.info.depth/(e-1),o=[n*Math.sin(r)*Math.cos(s),n*Math.cos(r)*Math.cos(s),n*Math.sin(s)],h=[],a=[];for(let s=0;s<e;++s)for(let e=0;e<t;++e){const t=this.pt(e);3===t.length?h.push(t[0]+s*o[0],t[1]+s*o[1],t[2]-s*o[2]):h.push(t[0]+s*o[0],t[1]+s*o[1],-s*o[2])}for(let s=0;s<e-1;++s){const e=s*t;for(let s=0;s<t-1;++s){const i=e+s;a.push(i,1+i,t+i,1+i,t+1+i,t+i)}}this.positions=i.Serie.create({array:h,itemSize:3}),this.indices=i.Serie.create({array:a,itemSize:3})}}function Se(e,t){const s=new Ne;return s.setMnt(e),s.setTraces(t),s.run()}class Ne{constructor(){this.mnt=void 0,this.active=!0,this.mnt=void 0,this.traces=void 0}setMnt(e){this.mnt=e}setTraces(e){this.traces=e}run(){if(!this.mnt||0===this.traces.length)return;const e=new t;this.mnt.positions.forEach((t=>{e.grow(t)})),e.min[2],e.max[2];const s=[];return this.traces.forEach((e=>{e.points.length;const t=[];e.points.forEach((e=>{if(this.active){let s=!1;for(let i=0;i<this.mnt.indices.length;i+=3){const r=this.mnt.indices.array[i],n=this.mnt.indices.array[i+1],o=this.mnt.indices.array[i+2],h=this.mnt.positions.itemAt(r),a=this.mnt.positions.itemAt(n),d=this.mnt.positions.itemAt(o),c=(h[2]+a[2]+d[2])/3;if(this.pointInTriangle(e,h,a,d)){t.push(e[0],e[1],c),s=!0;break}}console.assert(s)}else t.push(e[0],e[1],0)})),s.push(i.Serie.create({array:t,itemSize:3}))})),s}pointInTriangle(e,t,s,i){function r(e,t,s){return(e[0]-s[0])*(t[1]-s[1])-(t[0]-s[0])*(e[1]-s[1])}const n=r(e,t,s),o=r(e,s,i),h=r(e,i,t);return!((n<0||o<0||h<0)&&(n>0||o>0||h>0))}}const be=(e,t=1e-7)=>{const s=e.itemAt(0)[0];let i=0;if(e.forEach((e=>{Math.abs(e[0]-s)<t&&i++})),i<2)return void console.warn("Seems that the grid is not regular");const r=e.count/i;if(!1!==Number.isInteger(r))return[i,r];console.warn("Seems that the grid is not regular")};class Ae{constructor(e,t){this.x=e,this.y=t}equals(e){return this.x===e.x&&this.y===e.y}add(e){return new Ae(this.x+e.x,this.y+e.y)}mulScalar(e){return new Ae(this.x*e,this.y*e)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){var e=this.length();this.x/=e,this.y/=e}distanceTo(e){var t=e.x-this.x,s=e.y-this.y;return Math.sqrt(t*t+s*s)}}class Ee{constructor(e,t=1){if(this.bounds=[0,0,0,0,0,0],this.width=0,this.height=0,this.length=0,this.center=[0,0],6!==e.length)throw new Error("bounds is an array of length 6 ([xmin,ymin,zmin, xmax,ymax,zmax])");this.bounds=e,this.width=(e[3]-e[0])*t,this.height=(e[4]-e[1])*t,this.length=Math.max(this.width,this.height),this.center=[(e[3]+e[0])/2,(e[4]+e[1])/2]}normalize(e){if(i.Serie.isSerie(e))return e.map((e=>this.normalize(e)));const t=(e[0]-this.center[0])/this.length,s=(e[1]-this.center[1])/this.length;return 2===e.length?[t,s]:[t,s,e[2]]}denormalize(e){if(e instanceof i.Serie)return e.map((e=>this.denormalize(e)));const t=e[0]*this.length+this.center[0],s=e[1]*this.length+this.center[1];return 2===e.length?[t,s]:[t,s,e[2]]}}class Fe{constructor(){this.children=void 0}occupy(e){void 0===this.children&&(this.children=[]),this.children.push(e)}isTaken(e,t,s){if(void 0===this.children)return!1;for(let o=0;o<this.children.length;++o){var i=this.children[o],r=i.x-e,n=i.y-t;if(s(Math.sqrt(r*r+n*n),i))return!0}return!1}}function ze(e,t,s){const i=Math.max(e.width,e.height),r=Math.ceil(i/t),n=new Map;return{occupyCoordinates:function(t){(function(t,s){!function(t,s){if(e.left>t||e.left+i<t)throw new Error(`x (${t}) is out of bounds (${e.left}, ${e.left+i})`);if(e.top>s||e.top+i<s)throw new Error(`y (${s}) is out of bounds (${e.top}, ${e.top+i})`)}(t,s);const r=o(t);let a=n.get(r);a||(a=new Map,n.set(r,a));const d=h(s);let c=a.get(d);return c||(c=new Fe,a.set(d,c)),c})(t.x,t.y).occupy(t)},isTaken:function(e,t,s){if(!n)return!1;const i=o(e),a=h(t);for(let o=-1;o<2;++o){const h=i+o;if(h<0||h>=r)continue;const d=n.get(h);if(d)for(let i=-1;i<2;++i){const n=a+i;if(n<0||n>=r)continue;const o=d.get(n);if(o&&o.isTaken(e,t,s))return!0}}return!1},isOutside:function(t,i){return void 0!==s?!s(t,i):t<e.left||t>e.left+e.width||i<e.top||i>e.top+e.height}};function o(t){return Math.floor(r*(t-e.left)/i)}function h(t){return Math.floor(r*(t-e.top)/i)}}function ke(e,t,s){const i=s(e);if(!i)return;const r=s(e.add(i.mulScalar(.5*t)));if(!r)return;const n=s(e.add(r.mulScalar(.5*t)));if(!n)return;const o=s(e.add(n.mulScalar(t)));return o?i.mulScalar(t/6).add(r.mulScalar(t/3)).add(n.mulScalar(t/3)).add(o.mulScalar(t/6)):void 0}var Ie,Me;function Be(e,t,s){const i=[e];let r=e,n=Ie.FORWARD,o=null,h=-1;const a=ze(s.boundingBox,.9*s.timeStep,s.isOutsideFct);return{start:e,next:function(){for(;;){if(o=null,s.maximumPointsPerLine&&i.length>s.maximumPointsPerLine&&(n=Ie.DONE),n===Ie.FORWARD){const t=u();if(t){if(i.push(t),a.occupyCoordinates(t),r=t,Number.isNaN(t.x)||Number.isNaN(t.y))return n=Ie.DONE,s.onPointAdded(void 0,void 0,void 0),!0;if(_(t))return}else s.forwardOnly?n=Ie.DONE:(r=e,n=Ie.BACKWARD,s.onPointAdded(void 0,void 0,void 0))}if(n===Ie.BACKWARD){const e=f();if(e){if(i.unshift(e),r=e,a.occupyCoordinates(e),Number.isNaN(e.x)||Number.isNaN(e.y))return n=Ie.DONE,s.onPointAdded(void 0,void 0,void 0),!0;if(_(e))return}else n=Ie.DONE}if(n===Ie.DONE)return i.forEach(l),s.onPointAdded(void 0,void 0,void 0),!0}},getStreamline:()=>i,getNextValidSeed:function(){for(;h<i.length-1;){h+=1;let e=i[h],r=m(e);if(!r)continue;let n=e.x-r.y*s.dSep,o=e.y+r.x*s.dSep;if(Array.isArray(s.seedArray)&&s.seedArray.length>0){const e=s.seedArray.shift();n=e.x,o=e.y}if(!t.isOutside(n,o)&&!t.isTaken(n,o,c))return h-=1,new Ae(n,o);const a=e.x+r.y*s.dSep,d=e.y-r.x*s.dSep;if(!t.isOutside(a,d)&&!t.isTaken(a,d,c))return new Ae(a,d)}}};function d(e){return!Te(e,s.dTest)&&e<s.dTest}function c(e){return!Te(e,s.dSep)&&e<s.dSep}function l(e){t.occupyCoordinates(e)}function u(){const e=ke(r,s.timeStep,m);if(e)return g(r,e)}function f(){let e=ke(r,s.timeStep,m);if(e)return e=e.mulScalar(-1),g(r,e)}function g(e,s){if(o=e.add(s),!t.isOutside(o.x,o.y)&&!t.isTaken(o.x,o.y,d)&&!a.isTaken(o.x,o.y,p))return o}function p(e){return e<.9*s.timeStep}function _(e){let t=!1;if(s.onPointAdded){const r=i[n===Ie.FORWARD?i.length-2:1];t=s.onPointAdded(e,r,s)}return t}function m(e){let t=s.vectorField(e);if(!t)return;if(Number.isNaN(t.x)||Number.isNaN(t.y))return;let i=t.x**2+t.y**2;return 0!==i?(i=Math.sqrt(i),new Ae(t.x/i,t.y/i)):void 0}}function Te(e,t){return Math.abs(e-t)<1e-4}function Oe(e,t){if("number"!=typeof e||Number.isNaN(e))throw new Error(t)}function He({vectorField:e,isOutsideFct:t,bounds:s,seed:r,seedArray:n,maximumPointsPerLine:o,maxTimePerIteration:h=1e3,stepsPerIteration:a=50,timeStep:d=.05,dSep:c=.2,dTest:l=.08,forwardOnly:u=!1}){let f=[],g=[];return function(e){const t=e;if(!e)throw new Error("Configuration is required to compute streamlines");if(!e.boundingBox)throw new Error("No bounding box passed to streamline. Creating default one");!function(e){const t="Bounding box {left, top, width, height} is required";if(!e)throw new Error(t);if(Oe(e.left,t),Oe(e.top,t),"number"==typeof e.size&&(e.width=e.size,e.height=e.size),Oe(e.width,t),Oe(e.height,t),e.width<=0||e.height<=0)throw new Error("Bounding box cannot be empty")}(t.boundingBox);const s=t.boundingBox;if(void 0!==e.seedArray&&Array.isArray(e.seedArray)){const s=e.seedArray.shift();t.seed=new Ae(s.x,s.y),t.seedArray=e.seedArray}else void 0!==e.seed?t.seed=e.seed:t.seed=new Ae(Math.random()*s.width+s.left,Math.random()*s.height+s.top);t.dSep=e.dSep>0?e.dSep:1/Math.max(s.width,s.height),t.dTest=e.dTest>0?e.dTest:.5*t.dSep;const i=ze(s,t.dSep,t.isOutsideFct);t.timeStep=e.timeStep>0?e.timeStep:.01,t.stepsPerIteration=e.stepsPerIteration>0?e.stepsPerIteration:10,t.maxTimePerIteration=e.maxTimePerIteration>0?e.maxTimePerIteration:1e3;const r=t.stepsPerIteration;let n=Me.STATE_INIT;const o=[];let h=Be(t.seed,i,t);return{run:function(){for(;n!==Me.STATE_DONE;)for(var e=0;e<r;++e)n===Me.STATE_INIT?h.next()&&(d(),n=Me.STATE_PROCESS_QUEUE):n===Me.STATE_STREAMLINE?h.next()&&(d(),n=Me.STATE_SEED_STREAMLINE):n===Me.STATE_PROCESS_QUEUE?n=0===o.length?Me.STATE_DONE:Me.STATE_SEED_STREAMLINE:n===Me.STATE_SEED_STREAMLINE&&a()}};function a(){const e=o[0].getNextValidSeed();e?(h=Be(e,i,t),n=Me.STATE_STREAMLINE):(o.shift(),n=Me.STATE_PROCESS_QUEUE)}function d(){var e=h.getStreamline();e.length>1&&(o.push(h),t.onStreamlineAdded&&t.onStreamlineAdded(e,t))}}({vectorField:e,isOutsideFct:t,onPointAdded:function(e,t){return void 0===e?(g.length>1&&f.push([...g]),g=[],!1):(g.push(e.x,e.y,0,t.x,t.y,0),!0)},onStreamlineAdded:void 0,maxTimePerIteration:1,maximumPointsPerLine:o,seed:r,boundingBox:{width:s[3]-s[0],height:s[4]-s[1],left:s[0],top:s[1]},stepsPerIteration:a,timeStep:d,dSep:c,dTest:l,forwardOnly:u,seedArray:n}).run(),0!==g.length&&f.push([...g]),f.map((e=>{const t=[];for(let s=0;s<e.length;s+=2)t.push(s,s+1);return i.DataFrame.create({series:{positions:i.Serie.create({array:e,itemSize:3}),indices:i.Serie.create({array:t,itemSize:2})}})}))}function Pe({positions:t,indices:s,vectorField:r,seeds:n,nx:o=100,ny:h=100,maximumPointsPerLine:a=50,dSep:d=.1,timeStep:c=.05,dTest:l=.05,maxTimePerIteration:u=1e3}){const f=new Ee((0,e.minMax)(t),.1),g=f.normalize(t),p=(0,e.minMax)(g),_=new me({positions:g,indices:s,attribute:r,nx:o,ny:h,flatten:!0,scaling:1});let m;n&&(m=[],i.Serie.create({array:n,itemSize:3}).map((e=>f.normalize(e))).forEach((e=>m.push({x:e[0],y:e[1]}))));let x=He({vectorField:e=>{const t=_.interpolate([e.x,e.y]);if(void 0!==t)return new Ae(t[0],t[1])},bounds:p,maximumPointsPerLine:a,maxTimePerIteration:u,dSep:d,timeStep:c,dTest:l,seedArray:m});return x.forEach((e=>{e.series.positions=f.denormalize(e.series.positions)})),x}function je({positions:e,indices:t,serie:s}){const r=ee.create(e,t);if(s.count!==r.nbFacets)throw new Error(`serie must be defined at triangles (count=${r.nbFacets}). Got count=${s.itemSize}`);const n=s.itemSize;let o=s.newInstance({count:r.nbNodes,itemSize:n}).array;const h=new Array(r.nbNodes).fill(0);r.forEachFace(((e,t)=>{const i=e.nodeIds;let r=s.itemAt(t);for(let e=0;e<3;++e){const t=i[e];if(1===n)o[t]+=r;else for(let e=0;e<n;++e)o[n*t+e]+=r[e];h[t]++}}));for(let e=0,t=0;e<o.length;e+=n,++t)for(let s=0;s<n;++s)o[e+s]/=h[t];return i.Serie.create({array:o,itemSize:n})}function Ce({positions:e,indices:t,serie:s}){const r=ee.create(e,t);if(s.count!==r.nbNodes)throw new Error(`serie must be defined at nodes (count=${r.nbNodes}). Got count=${s.itemSize}`);const n=s.itemSize;let o=s.newInstance({count:r.nbFacets,itemSize:n}).array;r.forEachFace(((e,t)=>{const i=e.nodeIds;for(let e=0;e<3;++e){const r=s.itemAt(i[e]);if(1===n)o[t]+=r;else for(let e=0;e<n;++e)o[n*t+e]+=r[e]}}));for(let e=0;e<o.length;++e)o[e]/=3;return i.Serie.create({array:o,itemSize:n})}!function(e){e[e.FORWARD=0]="FORWARD",e[e.BACKWARD=1]="BACKWARD",e[e.DONE=2]="DONE"}(Ie||(Ie={})),function(e){e[e.STATE_INIT=0]="STATE_INIT",e[e.STATE_STREAMLINE=1]="STATE_STREAMLINE",e[e.STATE_PROCESS_QUEUE=2]="STATE_PROCESS_QUEUE",e[e.STATE_DONE=3]="STATE_DONE",e[e.STATE_SEED_STREAMLINE=4]="STATE_SEED_STREAMLINE"}(Me||(Me={}));class De extends e.NormalsDecomposer{serie(e,t,s){const i=super.serie(e,t,s);if(i)return je({positions:e.series.positions,indices:e.series.indices,serie:i})}}class Le{constructor({positions:e,indices:t,decomposer:s}){this.positions=e,this.indices=t,this.decomposer=s}names(e,t,s,i){return this.decomposer.names(e,t,s,i)}serie(e,t,s){return this.decomposer.serie(e,t,s)?je({positions:this.positions,indices:this.indices,serie:this.decomposer.serie(e,t,s)}):void 0}}class Ke{constructor({positions:e,indices:t,names:s}){if(this.names_=["k1","k2","H","K"],e&&t&&(this.geo=new rt(e,t,!0)),void 0!==s){if(4!==s.length)throw new Error("curvature names length must be 4 (principal 1, principal 2, mean, gaussian)");this.names_=s}}names(e,t,s,i){return 1!==t||void 0===this.geo?[]:this.names_}serie(e,t,s){if(this.names_.includes(s))switch(s){case this.names_[0]:return this.geo.k1();case this.names_[1]:return this.geo.k2();case this.names_[2]:return this.geo.H();case this.names_[3]:return this.geo.K();default:return}}}class Re{constructor(){this.vertex=void 0,this.edge=void 0,this.face=void 0,this.corner=void 0,this.next=void 0,this.prev=void 0,this.twin=void 0,this.onBoundary=!1,this.index=-1}toString(){return this.index}}class Ue{constructor(){this.halfedge=void 0,this.index=-1}onBoundary(){return this.halfedge.onBoundary||this.halfedge.twin.onBoundary}toString(){return this.index}}class qe{constructor(){this.halfedge=void 0,this.index=-1}isBoundaryLoop(){return this.halfedge.onBoundary}adjacentVertices(e=!0){return new Ge(this.halfedge,e)}adjacentEdges(e=!0){return new $e(this.halfedge,e)}adjacentFaces(e=!0){return new Ve(this.halfedge,e)}adjacentHalfedges(e=!0){return new We(this.halfedge,e)}adjacentCorners(e=!0){return new Je(this.halfedge,e)}toString(){return this.index}}class Ge{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.vertex;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:e}}return{done:!0}}}}}class $e{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.edge;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:e}}return{done:!0}}}}}class Ve{constructor(e,t){for(;e.twin.onBoundary;)e=e.next;this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.twin.onBoundary;)this.current=this.ccw?this.current.next:this.current.prev;if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.twin.face;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:e}}return{done:!0}}}}}class We{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:e}}return{done:!0}}}}}class Je{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){return this.justStarted||this.current!==this.end?(this.justStarted=!1,this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:this.current.corner}):{done:!0}}}}}class Ye{constructor(){this.halfedge=void 0,this.index=-1}degree(){let e=0;for(let t of this.adjacentEdges())e++;return e}isIsolated(){return void 0===this.halfedge}onBoundary(){for(let e of this.adjacentHalfedges())if(e.onBoundary)return!0;return!1}adjacentVertices(e=!0){return new Qe(this.halfedge,e)}adjacentEdges(e=!0){return new Xe(this.halfedge,e)}adjacentFaces(e=!0){return new Ze(this.halfedge,e)}adjacentHalfedges(e=!0){return new et(this.halfedge,e)}adjacentCorners(e=!0){return new tt(this.halfedge,e)}toString(){return this.index}}class Qe{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.twin.vertex;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:e}}return{done:!0}}}}}class Xe{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.edge;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:e}}return{done:!0}}}}}class Ze{constructor(e,t){for(;e.onBoundary;)e=e.twin.next;this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.onBoundary;)this.current=this.ccw?this.current.twin.next:this.current.prev.twin;if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.face;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:e}}return{done:!0}}}}}class et{constructor(e,t){this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:e}}return{done:!0}}}}}class tt{constructor(e,t){for(;e.onBoundary;)e=e.twin.next;this._halfedge=e,this._ccw=t}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.onBoundary;)this.current=this.ccw?this.current.twin.next:this.current.prev.twin;if(this.justStarted||this.current!==this.end){this.justStarted=!1;let e=this.current.next.corner;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:e}}return{done:!0}}}}}class st{constructor(){this.halfedge=void 0,this.halfedge=void 0,this.index=-1}get vertex(){return this.halfedge.prev.vertex}get face(){return this.halfedge.face}get next(){return this.halfedge.next.corner}get prev(){return this.halfedge.prev.corner}toString(){return this.index}}class it{constructor(){this.vertices=[],this.edges=[],this.faces=[],this.corners=[],this.halfedges=[],this.boundaries=[],this.generators=[],this.vertices=[],this.edges=[],this.faces=[],this.corners=[],this.halfedges=[],this.boundaries=[],this.generators=[]}eulerCharacteristic(){return this.vertices.length-this.edges.length+this.faces.length}build(e,t){this.preallocateElements(e,t);let s=new Map;for(let t=0;t<e.count;t++){let e=new Ye;e.index=t,this.vertices[t]=e,s.set(t,e)}let i=0,r=new Map,n=new Map,o=new Map;for(let e=0;e<t.array.length;e+=3){let h=new qe;this.faces[e/3]=h;for(let t=0;t<3;t++){let s=new Re;this.halfedges[e+t]=s}for(let a=0;a<3;a++){let d=(a+1)%3,c=t.array[e+a],l=t.array[e+d],u=this.halfedges[e+a];u.next=this.halfedges[e+d],u.prev=this.halfedges[e+(a+3-1)%3],u.onBoundary=!1,o.set(u,!1);let f=s.get(c);u.vertex=f,f.halfedge=u,u.face=h,h.halfedge=u,c>l&&(l=[c,c=l][0]);let g=[c,l].toString();if(n.has(g)){let e=n.get(g);u.twin=e,e.twin=u,u.edge=e.edge,o.set(u,!0),o.set(e,!0),r.set(g,r.get(g)+1)}else{let e=new Ue;this.edges[i++]=e,u.edge=e,e.halfedge=u,n.set(g,u),r.set(g,1)}if(r.get(g)>2)return console.warn("Mesh has non-manifold edges!"),!1}}let h=t.array.length,a=0;for(let e=0;e<t.array.length;e++){let t=this.halfedges[e];if(!o.get(t)){let e=new qe;this.boundaries.push(e);let s=[],i=t;do{let t=new Re;this.halfedges[h++]=t,s.push(t);let r=i.next;for(;o.get(r);)r=r.twin.next;t.vertex=r.vertex,t.edge=i.edge,t.onBoundary=!0,t.face=e,e.halfedge=t,t.twin=i,i.twin=t,i=r}while(i!==t);let r=s.length;for(let e=0;e<r;e++)s[e].next=s[(e+r-1)%r],s[e].prev=s[(e+1)%r],o.set(s[e],!0),o.set(s[e].twin,!0)}if(!t.onBoundary){let e=new st;e.halfedge=t,t.corner=e,this.corners[a++]=e}}return!(this.hasIsolatedVertices()||this.hasIsolatedFaces()||this.hasNonManifoldVertices()||(this.indexElements(),0))}preallocateElements(e,t){let s=0,i=new Map;for(let e=0;e<t.array.length;e+=3)for(let r=0;r<3;r++){let n=(r+1)%3,o=t.array[e+r],h=t.array[e+n];o>h&&(h=[o,o=h][0]);let a=[o,h],d=a.toString();i.has(d)?s--:(i.set(d,a),s++)}let r=e.count,n=i.size,o=t.count,h=2*n,a=h-s;this.vertices.length=0,this.edges.length=0,this.faces.length=0,this.halfedges.length=0,this.corners.length=0,this.boundaries.length=0,this.generators.length=0,this.vertices=new Array(r),this.edges=new Array(n),this.faces=new Array(o),this.halfedges=new Array(h),this.corners=new Array(a)}hasIsolatedVertices(){for(let e of this.vertices)if(e.isIsolated())return console.warn("Mesh has isolated vertices!"),!0;return!1}hasIsolatedFaces(){for(let e of this.faces){let t=0;for(let s of e.adjacentHalfedges())s.twin.onBoundary&&t++;if(3===t)return console.warn("Mesh has isolated faces!"),!0}return!1}hasNonManifoldVertices(){let e=new Map;for(let t of this.vertices)e.set(t,0);for(let t of this.faces)for(let s of t.adjacentVertices())e.set(s,e.get(s)+1);for(let t of this.boundaries)for(let s of t.adjacentVertices())e.set(s,e.get(s)+1);for(let t of this.vertices)if(e.get(t)!==t.degree())return!0;return!1}indexElements(){let e=0;for(let t of this.vertices)t.index=e++;e=0;for(let t of this.edges)t.index=e++;e=0;for(let t of this.faces)t.index=e++;e=0;for(let t of this.halfedges)t.index=e++;e=0;for(let t of this.corners)t.index=e++;e=0;for(let t of this.boundaries)t.index=e++}}class rt{constructor(e,t,s=!0){this.mesh=new it,this.mesh.build(e,t),this.positions=e,s&&function(e,t,s=!0){let i=t.length,r=new nt;for(let s of t){let t=e.itemAt(s.index);r.incrementBy(t)}r.divideBy(i);let n=-1;for(let s of t){let t=new nt(e.itemAt(s.index));t.decrementBy(r),n=Math.max(n,t.norm())}if(s)for(let s of t)new nt(e.itemAt(s.index)).divideBy(n)}(this.positions,this.mesh.vertices)}vector(e){let t=this.pos(e.vertex);return this.pos(e.next.vertex).minus(t)}length(e){return this.vector(e.halfedge).norm()}pos(e){return new nt(this.positions.itemAt(e.index))}midpoint(e){let t=e.halfedge,s=this.pos(t.vertex),i=this.pos(t.twin.vertex);return s.plus(i).over(2)}meanEdgeLength(){let e=0,t=this.mesh.edges;for(let s of t)e+=this.length(s);return e/t.length}area(e){if(e.isBoundaryLoop())return 0;let t=this.vector(e.halfedge),s=this.vector(e.halfedge.prev).negated();return.5*t.cross(s).norm()}totalArea(){let e=0;for(let t of this.mesh.faces)e+=this.area(t);return e}faceNormal(e){if(e.isBoundaryLoop())return;let t=this.vector(e.halfedge),s=this.vector(e.halfedge.prev).negated();return t.cross(s).unit()}centroid(e){let t=e.halfedge,s=this.pos(t.vertex),i=this.pos(t.next.vertex),r=this.pos(t.prev.vertex);return e.isBoundaryLoop()?s.plus(i).over(2):s.plus(i).plus(r).over(3)}circumcenter(e){let t=e.halfedge,s=this.pos(t.vertex),i=this.pos(t.next.vertex),r=this.pos(t.prev.vertex);if(e.isBoundaryLoop())return s.plus(i).over(2);let n=r.minus(s),o=i.minus(s),h=o.cross(n),a=h.cross(o).times(n.norm2()),d=n.cross(h).times(o.norm2());return a.plus(d).over(2*h.norm2()).plus(s)}orthonormalBases(e){let t=this.vector(e.halfedge).unit();return[t,this.faceNormal(e).cross(t)]}angle(e){let t=this.vector(e.halfedge.prev).unit(),s=this.vector(e.halfedge.next).negated().unit();return Math.acos(Math.max(-1,Math.min(1,t.dot(s))))}cotan(e){if(e.onBoundary)return 0;let t=this.vector(e.prev),s=this.vector(e.next).negated();return t.dot(s)/t.cross(s).norm()}dihedralAngle(e){if(e.onBoundary||e.twin.onBoundary)return 0;let t=this.faceNormal(e.face),s=this.faceNormal(e.twin.face),i=this.vector(e).unit(),r=t.dot(s),n=t.cross(s).dot(i);return Math.atan2(n,r)}barycentricDualArea(e){let t=0;for(let s of e.adjacentFaces())t+=this.area(s)/3;return t}circumcentricDualArea(e){let t=0;for(let s of e.adjacentHalfedges()){let e=this.vector(s.prev).norm2(),i=this.vector(s).norm2();t+=(e*this.cotan(s.prev)+i*this.cotan(s))/8}return t}vertexNormalEquallyWeighted(e){let t=new nt;for(let s of e.adjacentFaces()){let e=this.faceNormal(s);t.incrementBy(e)}return t.normalize(),t}vertexNormalAreaWeighted(e){let t=new nt;for(let s of e.adjacentFaces()){let e=this.faceNormal(s),i=this.area(s);t.incrementBy(e.times(i))}return t.normalize(),t}vertexNormalAngleWeighted(e){let t=new nt;for(let s of e.adjacentCorners()){let e=this.faceNormal(s.halfedge.face),i=this.angle(s);t.incrementBy(e.times(i))}return t.normalize(),t}vertexNormalGaussCurvature(e){let t=new nt;for(let s of e.adjacentHalfedges()){let e=.5*this.dihedralAngle(s)/this.length(s.edge);t.decrementBy(this.vector(s).times(e))}return t.normalize(),t}vertexNormalMeanCurvature(e){let t=new nt;for(let s of e.adjacentHalfedges()){let e=.5*(this.cotan(s)+this.cotan(s.twin));t.decrementBy(this.vector(s).times(e))}return t.normalize(),t}vertexNormalSphereInscribed(e){let t=new nt;for(let s of e.adjacentCorners()){let e=this.vector(s.halfedge.prev),i=this.vector(s.halfedge.next).negated();t.incrementBy(e.cross(i).over(e.norm2()*i.norm2()))}return t.normalize(),t}angleDefect(e){let t=0;for(let s of e.adjacentCorners())t+=this.angle(s);return e.onBoundary()?Math.PI-t:2*Math.PI-t}totalAngleDefect(){let e=0;for(let t of this.mesh.vertices)e+=this.angleDefect(t);return e}scalarGaussCurvature(e){return this.angleDefect(e)}scalarMeanCurvature(e){let t=0;for(let s of e.adjacentHalfedges())t+=.5*this.length(s.edge)*this.dihedralAngle(s);return t}principalCurvatures(e){let t=this.circumcentricDualArea(e),s=this.scalarMeanCurvature(e)/t,i=s*s-this.angleDefect(e)/t;return i=i>0?Math.sqrt(i):0,[s-i,s+i]}K(){return i.Serie.create({array:this.mesh.vertices.map((e=>this.angleDefect(e))),itemSize:1})}H(){return i.Serie.create({array:this.mesh.vertices.map((e=>this.scalarMeanCurvature(e))),itemSize:1})}k1(){const e=this.mesh.vertices.map(((e,t)=>this.principalCurvatures(e)[0]));return i.Serie.create({array:e,itemSize:1})}k2(){const e=this.mesh.vertices.map(((e,t)=>this.principalCurvatures(e)[1]));return i.Serie.create({array:e,itemSize:1})}}class nt{constructor(e=0,t,s){Array.isArray(e)?(this.x=e[0],this.y=e[1],this.z=e[2]):(this.x=e,this.y=void 0!==t?t:0,this.z=void 0!==s?s:0)}norm(){return Math.sqrt(this.norm2())}norm2(){return this.dot(this)}normalize(){let e=this.norm();this.x/=e,this.y/=e,this.z/=e}unit(){let e=this.norm(),t=this.x/e,s=this.y/e,i=this.z/e;return new nt(t,s,i)}isValid(){return!isNaN(this.x)&&!isNaN(this.y)&&!isNaN(this.z)&&isFinite(this.x)&&isFinite(this.y)&&isFinite(this.z)}incrementBy(e){Array.isArray(e)?(this.x+=e[0],this.y+=e[1],this.z+=e[2]):(this.x+=e.x,this.y+=e.y,this.z+=e.z)}decrementBy(e){Array.isArray(e)?(this.x-=e[0],this.y-=e[1],this.z-=e[2]):(this.x-=e.x,this.y-=e.y,this.z-=e.z)}scaleBy(e){this.x*=e,this.y*=e,this.z*=e}divideBy(e){this.scaleBy(1/e)}plus(e){return new nt(this.x+e.x,this.y+e.y,this.z+e.z)}minus(e){return new nt(this.x-e.x,this.y-e.y,this.z-e.z)}times(e){return new nt(this.x*e,this.y*e,this.z*e)}over(e){return this.times(1/e)}negated(){return this.times(-1)}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e){return new nt(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}}})(),n})()}));
//# sourceMappingURL=geometry.js.map